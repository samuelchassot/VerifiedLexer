

VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x[x](x), x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x) >= x[x](x, x) || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x.x)))
    x
  }
  x[x](x) >= x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x.x) < x[x](x)
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || x.isInstanceOf[x] || x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  {
    val x: x[x] = x[x](x, x[x](x.x, x[x]()))
    x[x](x.x)
  } < x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x[x](x, x))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x, x) == x
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x[x](x[x](x), x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x) >= x[x](x)
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || true


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || x[x](x.x, x[x](x))


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(!x[x](x))
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x)))
      x
    }
    x[x](x, x[x](x))
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  x[x](x.x, x) && x[x](x.x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || x[x](x[x](x), x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x == x)

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  require(x[x](x) == x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x != x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x == x
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x.x == x)
      x
    }
    x == x
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
x.isInstanceOf[x] || x[x](x) < x[x](x) || x[x](x, x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x == x
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x[x](x[x](x), x)
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x) >= x[x](x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || x[x](x, (x: x) => !x[x](x, x))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x, x: x[x]): Unit = {
  require(x[x](x[x](x, x[x](x, x[x]())), x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x.x, x[x](x, x[x]())), x) || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x))
      x
    }
    x[x](x, x)
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x) < x[x](x) || x[x](x, x)
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

def x[x](x: x[x], x: x[x], x: x[x]): x[x] = {
  require(x[x](x))
  require(x[x](x, x))
  require(x[x](x, x[x](x, x)))
  require(x[x](x[x](x, x)) == x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      x[x](x, x, x)
    case x(x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaSubSeqAddSameElmtPreserves")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: Unit = x[x](x)
        assume((x[x](x, (x: x) => !x[x](x[x](), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x]()
        val x: x = x
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (1/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        assert((!x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, (x: x) => !x[x](x[x](x, x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x[x]())
        assert((x[x](x)): @DropVCs , "Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x)): @DropVCs , "Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis")
        val x: Unit = x[x](x, x)
        assume((x[x](x[x](x, x))): @DropVCs )
        x
      }
      x[x](x, x, x[x](x, x[x](x, x[x]())))
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => ((x[x](x) && x[x](x, x)) && x[x](x) == x[x](x[x](x, x))) && x[x](x) == x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x.x, x)
  x[x](x) && x[x](x, x) && x[x](x) == x[x](x[x](x, x)) && x[x](x) == x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x[x](x), x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x != x || x.isInstanceOf[x] || x[x](x, x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x), x) != x[x](x, x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || {
  val x: x[x] = x[x](x[x](x), x[x]())
  val x: x[x] = x[x](x)
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))
    x
  }
  x != x[x]()
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x) == x || true
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x) < x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x, x) || x[x](x) != x
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  require(x[x](x, x) == x)
  require(x[x](x, x) == x)
  require(x == x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x != x)), "Choose satisfiability")
  x[x](x, x, x, x, x)
} ensuring {
  (x: Unit) => x == x
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x == x)

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || {
    val x: Unit = x[x](x.x, x, x, x, x)
    val x: Unit = {
      assume(x == x)
      x
    }
    x == x
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x.x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) == x[x](x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x.x)))
    x
  }
  x[x](x) < x[x](x) || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x == x)

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x) == x[x](x))
  require(x[x](x) == x[x](x))
  require(x[x](x) <= BigInt("1"))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x != x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x == x
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x.x == x)
      x
    }
    x == x
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || !x[x](x[x](x))


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  require(!x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x.x) || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x), x.x))
    x
  }
  true
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x) < x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || {
  val x: Boolean = x[x](x[x](x), x[x](x))
  true
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x), x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x, x) != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  !x[x](x) || !x[x](x.x, x) || !x[x](x, x[x](x, x.x)) || x[x](x[x](x, x.x)) == x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) != x
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || x[x](x) >= BigInt("0")


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x.x, x[x](x, x[x]())), x) || x[x](x[x](x.x, x[x](x, x[x]())), x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) == x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x) >= x[x](x, x) || x[x](x[x](x), x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= BigInt("0")


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) <= BigInt("1")
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) < x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x[x](x), x[x](x))


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x[x](x)) < x[x](x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x, x) || x[x](x) == x || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || x[x](x) >= BigInt("0")


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) != x[x](x) || x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x) < x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x) < x[x](x)
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x[x](x[x](x), x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x, x) == x


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x) < x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || true


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) == x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x != x[x]()
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x) < x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x[x](x) != x || x == x


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x) <= x[x](x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x) <= x[x](x))
      x
    }
    x[x](x) <= x[x](x)
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || x != x[x]()
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || true


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x.x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  !x[x](x) || x[x](x[x](x.x, x[x]()))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) == x.x


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  !x[x](x[x](x), x) || x != x[x]()
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x) == x)
  require(!x[x](x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || {
      val x: Unit = x[x](x.x, x, x, x)
      val x: Unit = {
        assume(x[x](x, x[x](x)))
        x
      }
      x[x](x, x[x](x))
    }
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || !x[x](x[x](x), x) || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x), x) != x[x](x, x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || {
  val x: x[x] = x[x](x[x](x), x[x]())
  val x: x[x] = x[x](x)
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x[x](x[x](x), x[x]()))
  x != x[x]()
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || x[x](x[x](x), x[x](x))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || x[x](x) >= BigInt("0")


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x), x) || x[x](x.x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || !x[x](x[x](x), x) || x[x](x[x](x), x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || true
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || x[x](x) >= BigInt("0")


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    !x[x](x[x](x), x) || x[x](x.x, x) != x || true
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || x.isInstanceOf[x] || x[x](x, x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x.x != x || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x))
      x
    }
    x[x](x, x)
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || !x[x](x[x](x.x, x[x](x, x[x]())), x[x](x)) || x[x](x.x) < x[x](x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || x.isInstanceOf[x] || x[x](x, x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  !x[x](x) || x[x](x.x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || {
    val x: x[x] = x[x](x, x)
    x != x[x]()
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x[x](x), x) || x[x](x.x, x) == x
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || x[x](x) >= BigInt("0")


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

def x[x](x: x[x], x: x[x], x: x[x]): x[x] = {
  require(x[x](x))
  require(x[x](x, x))
  require(x[x](x, x[x](x, x)))
  require(x[x](x[x](x, x)) == x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      x[x](x, x, x)
    case x(x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaSubSeqAddSameElmtPreserves")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: Unit = x[x](x)
        assume((x[x](x, (x: x) => !x[x](x[x](), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x]()
        val x: x = x
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (1/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        assert((!x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, (x: x) => !x[x](x[x](x, x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x[x]())
        assert((x[x](x)): @DropVCs , "Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x)): @DropVCs , "Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis")
        val x: Unit = x[x](x, x)
        assume((x[x](x[x](x, x))): @DropVCs )
        x
      }
      x[x](x, x, x[x](x, x[x](x, x[x]())))
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => ((x[x](x) && x[x](x, x)) && x[x](x) == x[x](x[x](x, x))) && x[x](x) == x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x.x, x[x](x, x[x](x.x, x[x]())))
  x[x](x) && x[x](x, x) && x[x](x) == x[x](x[x](x, x)) && x[x](x) == x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) < x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  !x[x](x, (x: x) => !x[x](x[x](), x)) || !x[x](x, x.x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x[x](x, x) == x[x](x[x](x), x) + BigInt("1")


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || x[x](x) < x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x != x[x]()
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) == x[x](x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x) < x[x](x) || x[x](x, x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x.x, x[x](x.x, x)))
    x
  }
  x[x](x, x[x](x, x))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x) == x || x[x](x, x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || x[x](x) == x


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || x[x](x.x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || true


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x.x) == x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x[x](x), x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  x[x](x[x](x, x[x](x.x, x[x]())))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
x[x](x) || !x.isInstanceOf[x] || !x.x.isInstanceOf[x] || x[x](x[x](x), x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x.isInstanceOf[x] || x != x[x]()
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || x[x](x) >= BigInt("0")


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x) < x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || true


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x[x](x) == x


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || x[x](x.x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || !x[x](x[x](x), x[x](x)) || x[x](x) >= x[x](x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x, x)
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x) == x || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x.x, x[x](x))


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  x[x](x, (x: x) => !x[x](x[x](), x))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  !x[x](x[x](x, x[x](x.x, x[x]()))) || x[x](x.x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  !x[x](x, x) || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x.x) <= x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) < x[x](x)
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) < x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x[x](x.x, x[x]()))
  !x[x](x) || !x[x](x.x, x) || x[x](x, x[x](x, x.x))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x) >= BigInt("0")


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x) < x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || true
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x.x) || x[x](x, (x: x) => !x[x](x, x))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x, x[x](x[x](x), x.x)) == x


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x.isInstanceOf[x] || x[x](x, x[x](x, x))


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  require(x[x](x) <= x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || {
    val x: Unit = x[x](x, x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x))
      x
    }
    x[x](x, x)
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || true
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) <= BigInt("1")
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x) != x


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) == x


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || x.isInstanceOf[x] || x == x


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || true


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  x != x[x]()
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
x.isInstanceOf[x] || x[x](x[x](x, x))


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x[x](x, x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) <= x[x](x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x) == x || true


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x, x)))
      x
    }
    x[x](x, x[x](x, x))
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || true


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x[x](x.x, x[x]()))
  !x[x](x) || !x[x](x.x, x) || !x[x](x, x[x](x, x.x)) || x[x](x[x](x, x.x)) == x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || x[x](x[x](x), x[x](x))


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x.x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || x[x](x.x) == x[x](x[x](x))


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    !x[x](x[x](x), x) || x[x](x.x, x) == x
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || x[x](x[x](x.x, x[x](x, x[x]())), x[x](x))


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x.x) || !x[x](x, (x: x) => !x[x](x, x)) || true
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || x != x[x]()
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || x.isInstanceOf[x] || x == x


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x, x[x](x))


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || x[x](x) >= BigInt("0")


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x[x](x)) >= x[x](x.x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
true


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || x[x](x.x) < x[x](x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x, x) || x[x](x) == x || true
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x[x](x))) + x[x](x[x](x))
} < {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x)) + x[x](x)
} || {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x[x](x))) + x[x](x[x](x))
} == {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x)) + x[x](x)
} && {
  val x: BigInt = (BigInt("0") + x[x](x[x](x))) + x[x](x[x](x))
  BigInt("0")
} < {
  val x: BigInt = (BigInt("0") + x[x](x)) + x[x](x)
  BigInt("0")
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x.x) < x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || x[x](x, x) && x[x](x, x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || x[x](x.x, x) && x[x](x.x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) == x
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || true


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x[x](x, x)
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  require(!x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x.x) || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x), x.x))
    x
  }
  x[x](x[x](x), x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x) != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x) < x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x.x, x) == x
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || x[x](x) >= BigInt("0")


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x[x](x) != x || x != x || x == x


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
x.isInstanceOf[x] || x[x](x, x[x](x, x))


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x[x](x), x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x.x)))
    x
  }
  x[x](x[x](x, x))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x), x) != x[x](x, x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || {
  val x: x[x] = x[x](x[x](x), x[x]())
  val x: x[x] = x[x](x)
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))
    x
  }
  x[x](x[x](x, x[x](x[x](x), x[x]())), x[x](x)) == x
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  !x[x](x[x](x), x) || x[x](x[x](x), x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
x.isInstanceOf[x] || x[x](x) >= x[x](x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x.isInstanceOf[x] || x[x](x, x[x](x))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(!x[x](x))
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x)))
      x
    }
    true
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || x[x](x.x, x[x](x))


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  !x[x](x) || !x[x](x.x, x) || x[x](x, x[x](x, x.x))
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) <= x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) < x[x](x.x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  x[x](x[x](x), x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) < x[x](x.x) || x[x](x.x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || x[x](x.x, x[x](x))


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) == x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x.x == x
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || x[x](x, x) < x[x](x, x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x) != x
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  true
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x.x, x) == x
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || true
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) == x[x](x) || !false || x[x](x) >= x[x](x)


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x, x) != x[x]()
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) == x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || true


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x) == x)
  require(!x[x](x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || {
      val x: Unit = x[x](x.x, x, x, x)
      val x: Unit = {
        assume(x[x](x, x[x](x)))
        x
      }
      x != x[x]()
    }
  }
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) == x


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || x != x[x]()


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || x[x](x.x) < x[x](x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || true
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || x[x](x.x, x) < x[x](x.x, x)
}


VC BEGIN ----------------------------------------------------------------------------------------------------------------------
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x), x) || x[x](x) < x[x](x)
}
