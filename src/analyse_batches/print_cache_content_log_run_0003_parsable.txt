VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x[x](x, x)) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x) >= x[x](x, x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || x[x](x.x, x) < x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
x.isInstanceOf[x] || x[x](x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x), (x: x) => x[x](x, x)))
    x
  }
  x[x](x[x](x, x), (x: x) => x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x.x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x, x[x]())), x[x](x.x, x[x](x, x[x]()))))
    x
  }
  x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x, x.x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x.x) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(!x[x](x))
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x)))
      x
    }
    true
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x.x)))
    x
  }
  x[x](x) >= x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x.x) < x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || x.isInstanceOf[x] || x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  !x[x](x) || x[x](x[x](x.x, x[x]()))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x != x || !x.isInstanceOf[x] || x.x == x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  {
    val x: x[x] = x[x](x, x[x](x.x, x[x]()))
    x[x](x.x)
  } < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x, x) == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x, x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x) >= x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || x[x](x[x](x.x, x[x](x, x[x]())), x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x)
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || {
            val x: Unit = if (x[x](x.x, x.x)) {
              val x: Unit = x[x](x.x, x.x)
              val x: Unit = {
                assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
                x
              }
              assume(false)
              ()
            } else {
              ()
            }
            !x[x](x) || x[x](x) == x[x](x.x)
          }
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x.x) || x[x](x.x) < x[x](x)
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, (x: x) => x(x)) || x.isInstanceOf[x] || x[x](x.x, (x: x) => x(x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  x[x](x).subsetOf(x[x](x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x), x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x, (x: x) => x[x](x, x))
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] || !x[x](x[x](x, x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !(x.x == x.x && x[x](x.x, x.x)) || !x[x](x.x, x.x) || {
  val x: Unit = x[x](x.x, x.x, x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x[x](x, x[x]())), x[x](x.x, x[x](x, x[x]()))))
    x
  }
  x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || x[x](x.x, x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x).subsetOf(x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !!x[x](x) || !x[x](x[x](x), x) || !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x), x) != x[x](x, x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || {
  val x: x[x] = x[x](x[x](x), x[x]())
  val x: x[x] = x[x](x)
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))
    x
  }
  x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) != x[x](x) || x[x](x[x](), x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(!x[x](x))
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x)))
      x
    }
    x[x](x, x[x](x))
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || x[x](x.x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x) < x[x](x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          !x[x](x, (x: x) => x[x](x, x)) || x[x](x, x.x) || x != x[x](x, x.x) || !x[x](x, (x: x) => x[x](x, x)) || x == x[x](x, x.x)
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  x[x](x.x, x) && x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x[x]()
      case x(x, x) if x(x) =>
        x[x](x, x[x](x, x))
      case x(_, x) =>
        x[x](x, x)
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) <= x[x](x) && x[x](x).subsetOf(x[x](x))) && x[x](x, x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] || {
  val x: Boolean = false
  !x || {
    val x: Unit = {
      assume(x)
      ()
    }
    !x[x](x[x](x, (x: x) => x[x](x, x)))
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x[x](x) != x || x != x || x == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x, x) != x[x](x.x, x) || !x[x](x.x, x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x)) < x[x](x.x))
    x
  }
  x[x](x[x](x, x)) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) <= x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) != x[x](x) || x[x](x) || {
  val x: x[x] = x[x](x, x)
  x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x == x)

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  require(x[x](x) == x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x != x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x == x
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x.x == x)
      x
    }
    x == x
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x) || !x[x](x, x.x) || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          !x[x](x, (x: x) => x[x](x, x)) || x[x](x)
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    !x[x](x) || x[x](x, x.x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          x[x](x, (x: x) => x[x](x, x))
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) >= x[x](x)
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          x[x](x, (x: x) => x[x](x, x))
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || x.x != x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  !x[x](x) || !x[x](x.x, x) || !x[x](x, x[x](x, x.x)) || x[x](x[x](x, x.x)) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
x.isInstanceOf[x] || x[x](x) < x[x](x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x[x](x[x](x), x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x.x, x)) || !x[x](x.x, (x: x) => !x[x](x, x)) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x)))
      x
    }
    x[x](x[x](x, x))
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x) != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x[x](x, x), x)) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || x.isInstanceOf[x] || x == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) >= x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x.isInstanceOf[x] || x[x](x.x, (x: x) => !x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      val x: Unit = x[x](x, x.x)
      val x: Unit = {
        assume(x[x](x.x) <= x[x](x))
        x
      }
      x[x](x.x) > x[x](x) || x[x](x.x) + BigInt("1") != x[x](x) || !x[x](x, x.x) || x[x](x) != x[x](x) \\ Set(x.x) || {
        val x: Unit = x[x](x, x.x)
        val x: Unit = {
          assume(x[x](x[x](x, x.x)) < x[x](x))
          x
        }
        x[x](x) > x[x](x)
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || x[x](x.x, x) == x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x[x](x), x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  decreases(x[x](x))
  {
    require(!x[x](x, x))
    require(x != x)
    assert(!forall((x: Unit) => !!x[x](x[x](x, x), x)), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => !x[x](x[x](x, x), x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => !x[x](x[x](x, x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x == x || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  !x[x](x[x](x, x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x == x.x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] && x.x != x || !x.isInstanceOf[x] || BigInt("-1") >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x) >= x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || x[x](x, (x: x) => !x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || !x.isInstanceOf[x] || x[x](x[x](x.x, x[x](x, x[x]())), x) == x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x, x: x[x]): Unit = {
  require(x[x](x[x](x, x[x](x, x[x]())), x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x.x, x[x](x, x[x]())), x) || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x))
      x
    }
    x[x](x, x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x || !x[x](x, x.x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x) || !x[x](x, x.x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x || !x[x](x, x.x) || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x) < x[x](x) || x[x](x, x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

def x[x](x: x[x], x: x[x], x: x[x]): x[x] = {
  require(x[x](x))
  require(x[x](x, x))
  require(x[x](x, x[x](x, x)))
  require(x[x](x[x](x, x)) == x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      x[x](x, x, x)
    case x(x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaSubSeqAddSameElmtPreserves")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: Unit = x[x](x)
        assume((x[x](x, (x: x) => !x[x](x[x](), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x]()
        val x: x = x
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (1/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        assert((!x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, (x: x) => !x[x](x[x](x, x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x[x]())
        assert((x[x](x)): @DropVCs , "Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x)): @DropVCs , "Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis")
        val x: Unit = x[x](x, x)
        assume((x[x](x[x](x, x))): @DropVCs )
        x
      }
      x[x](x, x, x[x](x, x[x](x, x[x]())))
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => ((x[x](x) && x[x](x, x)) && x[x](x) == x[x](x[x](x, x))) && x[x](x) == x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x.x, x)
  x[x](x) && x[x](x, x) && x[x](x) == x[x](x[x](x, x)) && x[x](x) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x != x || x.isInstanceOf[x] || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x), x) != x[x](x, x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || {
  val x: x[x] = x[x](x[x](x), x[x]())
  val x: x[x] = x[x](x)
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))
    x
  }
  x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || x[x](x, (x: x) => !x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x.x)
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@opaque
@library
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = x[x](x, x, x.x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x.x) || !x[x](x, x.x) || x[x](x.x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x.x, x[x](x, x[x]())), x) || x[x](x[x](x.x, x[x](x, x[x]())), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x) == x || true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x == x)

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  require(x[x](x, x) == x)
  require(x[x](x, x) == x)
  require(x == x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x != x)), "Choose satisfiability")
  x[x](x, x, x, x, x)
} ensuring {
  (x: Unit) => x == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || {
    val x: Unit = x[x](x.x, x, x, x, x)
    val x: Unit = {
      assume(x == x)
      x
    }
    x == x
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x, x) || x[x](x) != x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, (x: x) => x(x)) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  require(x[x](x, x) == x)
  require(x[x](x, x) == x)
  require(x == x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x != x)), "Choose satisfiability")
  x[x](x, x, x, x, x)
} ensuring {
  (x: Unit) => x == x
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x == x)

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || {
    val x: Unit = x[x](x.x, x, x, x, x)
    val x: Unit = {
      assume(x == x)
      x
    }
    x == x
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x, x) || x[x](x) != x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x) != x || x[x](x.x, x) == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)) == x[x](x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x) == x)
  require(!x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x[x](x)) != x[x](x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x)) == x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x) != x || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x)) == x[x](x))
      x
    }
    !x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x) >= x[x](x, x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !(x.x == x.x && x[x](x.x, x.x)) || !x[x](x.x, x.x) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x.isInstanceOf[x] || x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x, x: x[x]): Unit = {
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x, x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x.x)
  val x: Unit = {
    assume(x[x](x.x, x[x](x.x, x.x)))
    x
  }
  x[x](x) || x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(!x[x](x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(x, x), x(x, x)) =>
      val x: Boolean = x[x](x, x)
      if (x) {
        x[x](x, x)
      } else {
        val x: Boolean = !x[x](x)
        if (x) {
          x[x](x, x)
        } else {
          ()
        }
      }
    case _ =>
      ()
  }
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
x.isInstanceOf[x] || x.x != x || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: Unit = x[x](x, x)
  !x[x](x.x, x) || x[x](x, x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || !x.isInstanceOf[x] || !x[x](x) || x == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(!x[x](x, x))
  require(!x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !!x[x](x[x](x, x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => !x[x](x[x](x, x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => !x[x](x[x](x, x), x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x[x](x.x, x) || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(!x[x](x[x](x.x, x), x))
    x
  }
  !x[x](x[x](x, x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) == x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x.x) || x[x](x, (x: x) => !x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x) <= BigInt("0") || !x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x.x)))
    x
  }
  x[x](x) < x[x](x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x == x)

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x) == x[x](x))
  require(x[x](x) == x[x](x))
  require(x[x](x) <= BigInt("1"))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x != x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x == x
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x.x == x)
      x
    }
    x == x
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || !x[x](x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)) == x[x](x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x) == x)
  require(!x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x[x](x)) != x[x](x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x)) == x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x) != x || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x)) == x[x](x))
      x
    }
    x[x](x, x[x](x)) == x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x.x) || x[x](x.x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  require(!x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x.x) || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x), x.x))
    x
  }
  true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x.x)))
    x
  }
  x[x](x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x) || !x.isInstanceOf[x] || x[x](x, (x: x) => !x[x](x[x](x, x), x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x).subsetOf(x[x](x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, (x: x) => x[x](x, x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x, (x: x) => x[x](x, x), x.x)
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x.x).subsetOf(x[x](x)) || {
    val x: Unit = x[x](x, x.x, x)
    val x: Unit = {
      assume(x[x](x.x, (x: x) => x[x](x, x)))
      x
    }
    x[x](x, (x: x) => x[x](x, x))
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || {
  val x: Boolean = x[x](x[x](x), x[x](x))
  true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x, x) != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
    x
  }
  x[x](x[x](x, x), (x: x) => x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  !x[x](x) || !x[x](x.x, x) || !x[x](x, x[x](x, x.x)) || x[x](x[x](x, x.x)) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) != x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || !x[x](x).subsetOf(x[x](x)) || x[x](x).subsetOf(x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x[x](x[x](x, x), (x: x) => !x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || x.isInstanceOf[x] || x[x](x) || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x && x[x](x.x, x.x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x) || !x[x](x, x.x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      val x: Unit = x[x](x, x.x)
      val x: Unit = {
        assume(x[x](x.x) <= x[x](x))
        x
      }
      x[x](x.x) > x[x](x) || x[x](x.x) + BigInt("1") != x[x](x) || !x[x](x, x.x) || x[x](x) == x[x](x) \\ Set(x.x)
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) != x || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) <= x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !!x[x](x) || {
    val x: x[x] = x[x](x)
    !x[x](x, x) || !x[x](x, x) || {
      val x: Unit = x[x](x, x, x)
      val x: Unit = {
        assume(x[x](x, x))
        x
      }
      x[x](x) || x[x](x[x](x), x)
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

def x[x](x: x[x], x: x[x]): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x) == x[x](x))
  require(x[x](x) == x[x](x))
  decreases(x[x](x))
  val x: Unit = {
    val x: x[x] = x
    val x: x[x] = x
    assert((x[x](x).subsetOf(x[x](x))): @DropVCs , "Inlined precondition of lemmaSubsetContentThenForallContains")
    val x: Unit = x[x](x, x)
    assume((x[x](x, (x: x) => x[x](x, x))): @DropVCs )
    x
  }
  val x: Unit = {
    val x: x[x] = x
    val x: x[x] = x
    assert((x[x](x).subsetOf(x[x](x))): @DropVCs , "Inlined precondition of lemmaSubsetContentThenForallContains")
    val x: Unit = x[x](x, x)
    assume((x[x](x, (x: x) => x[x](x, x))): @DropVCs )
    x
  }
  assert(x[x](x, (x: x) => x[x](x, x)))
  assert(x[x](x, (x: x) => x[x](x, x)))
  x match {
    case x() =>
      ()
    case x(x, x) =>
      assert(x[x](x, x))
      val x: x[x] = x[x](x, x)
      val x: Unit = {
        val x: x[x] = x
        val x: x = x
        assert(({
          val x: x[x] = x
          (x[x](x)): @DropVCs 
        }): @DropVCs , "Inlined precondition of lemmaRemoveOneElmtPreservesNoDuplicate")
        val x: Unit = x[x](x, x)
        assume(({
          val x: x[x] = x[x](x, x)
          (x[x](x)): @DropVCs 
        }): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x = x
        assert(({
          val x: x[x] = x
          (x[x](x)): @DropVCs 
        }): @DropVCs , "Inlined precondition (1/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))): @DropVCs )
        x
      }
      assert(x[x](x) >= x[x](x))
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        val x: x = x
        assert((x[x](x, (x: x) => x[x](x, x))): @DropVCs , "Inlined precondition of lemmaForallContainsPreservedRemoveElmt")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x[x](x, x), (x: x) => x[x](x, x))): @DropVCs )
        x
      }
      assert(x[x](x, (x: x) => x[x](x, x)))
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, (x: x) => x[x](x, x))): @DropVCs , "Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList")
        assert((x[x](x)): @DropVCs , "Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) <= x[x](x))): @DropVCs )
        x
      }
      assert(x[x](x) >= x[x](x))
      assert(!x[x](x, x))
      assert({
        val x: x[x] = x
        (x[x](x)): @DropVCs 
      })
      assert(x[x](x, (x: x) => x[x](x, x)))
      val x: x[x] = x[x](x, x)
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        val x: x[x] = x
        val x: x = x
        assert((x[x](x, (x: x) => x[x](x, x))): @DropVCs , "Inlined precondition (1/3) of lemmaForallContainsPreservedRemoveElmtInRefList")
        assert((!x[x](x, x)): @DropVCs , "Inlined precondition (2/3) of lemmaForallContainsPreservedRemoveElmtInRefList")
        assert(((x == x[x](x, x))): @DropVCs , "Inlined precondition (3/3) of lemmaForallContainsPreservedRemoveElmtInRefList")
        val x: Unit = x[x](x, x, x, x)
        assume((x[x](x, (x: x) => x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: Boolean = x[x](x, (x: x) => x[x](x, x))
        assert((x): @ghost  @DropVCs , "Inlined precondition of check")
        val x: Unit = (()): @DropVCs 
        assume((x): @ghost  @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, (x: x) => x[x](x, x))): @DropVCs , "Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList")
        assert((x[x](x)): @DropVCs , "Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) <= x[x](x))): @DropVCs )
        x
      }
      assert(x[x](x[x](x, x)) >= x[x](x))
      val x: Boolean = x[x](x, x)
      val x: Unit = if (x) {
        val x: Unit = {
          val x: x[x] = x
          val x: x = x
          assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemoveElmtContainedSizeSmaller")
          val x: Unit = x[x](x, x)
          assume(((x[x](x[x](x, x)) < x[x](x))): @DropVCs )
          x
        }
        assert(x[x](x[x](x, x)) < x[x](x))
        assert(x[x](x[x](x, x)) < x[x](x))
        assert(x[x](x[x](x, x)) < x[x](x))
        val x: Boolean = false
        assert((x): @ghost  @DropVCs , "Inlined precondition of check")
        val x: Unit = (()): @DropVCs 
        assume((x): @ghost  @DropVCs )
        x
      } else {
        ()
      }
      val x: Unit = x
      val x: Unit = x
      x[x](x, x)
  }
} ensuring {
  (x: Unit) => {
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || {
            val x: Unit = if (x[x](x.x, x.x)) {
              val x: Unit = x[x](x.x, x.x)
              val x: Unit = {
                assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
                x
              }
              assume(false)
              ()
            } else {
              ()
            }
            val x: Unit = x[x](x, x.x)
            x[x](x)
          }
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x[x](x.x, x) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !!x[x](x) || x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x.x)))
    x
  }
  x[x](x) >= x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}
!x[x](x) || !x[x](x, x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x[x](x)) >= x[x](x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x, (x: x) => x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x.x, x.x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || x[x](x.x, x) != x[x](x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x == x || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || !x[x](x[x](x), x) || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x.x, x[x](x, x[x]())), x) || x[x](x[x](x.x, x[x](x, x[x]())), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x[x](x), x) || x[x](x.x, x) == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x != x || {
  val x: BigInt = x[x](x)
  x[x](x)
} >= BigInt("0") && {
  val x: BigInt = x[x](x)
  x[x](x)
} >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
x.isInstanceOf[x] || x[x](x) >= x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x) >= x[x](x, x) || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x.isInstanceOf[x] || x[x](x) || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x[x](x, x), x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, (x: x) => x[x](x[x](x, x), x))
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x[x](x, x), x)))
!x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(x[x](x.x, (x: x) => x[x](x[x](x, x), x)))
    x
  }
  x[x](x, (x: x) => x[x](x[x](x, x), x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => !x[x](x, x)) || x == x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x[x](x, x)) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || x[x](x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !!x[x](x[x](x, (x: x) => x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => !x[x](x[x](x, (x: x) => x[x](x, x)))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x[x]()
      case x(x, x) if x(x) =>
        x[x](x, x[x](x, x))
      case x(_, x) =>
        x[x](x, x)
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) <= x[x](x) && x[x](x).subsetOf(x[x](x))) && x[x](x, x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => !x[x](x[x](x, (x: x) => x[x](x, x))))
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !(x.x != x) || !x[x](x.x, x) || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(!x[x](x[x](x.x, (x: x) => x[x](x, x))))
    x
  }
  !x[x](x[x](x, (x: x) => x[x](x, x)))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || x[x](x[x](x, x.x)) == x[x](x) \\ Set(x.x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x, x)))
      x
    }
    x[x](x, x[x](x, x))
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x == x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x.isInstanceOf[x] || x[x](x, x) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  {
    val x: x[x] = x[x](x, x[x](x.x, x[x]()))
    x[x](x.x)
  } < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || x.isInstanceOf[x] || x[x](x.x, (x: x) => !x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x) == x)
  require(!x[x](x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || {
      val x: Unit = x[x](x.x, x, x, x)
      val x: Unit = {
        assume(x[x](x, x[x](x)))
        x
      }
      x[x](x, x[x](x))
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) + x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x) <= x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x) || x.isInstanceOf[x] || x[x](x.x, (x: x) => !x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) <= BigInt("1")
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} >= BigInt("0") && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} >= BigInt("0") && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x || !x[x](x, x.x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x.x, x[x](x.x, x)))
    x
  }
  x[x](x, x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x[x](x), x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x)

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(!x[x](x, x))
    assert(!forall((x: Unit) => (x[x](x, x) != x)), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, x) == x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}
x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x, x) == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  x[x](x, (x: x) => !x[x](x[x](), x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x[x](x, x)) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x[x](x)) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x, x) || x[x](x) == x || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x.x) || !x[x](x, x.x) || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x.x, x)) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x.x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x, x) && x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x, x.x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || !x[x](x.x, x.x) || {
            val x: Unit = x[x](x.x, x.x)
            val x: Unit = {
              assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
              x
            }
            x[x](x[x](x.x, x.x)) >= x[x](x.x) || x[x](x[x](x, x.x)) >= x[x](x.x) || x[x](x[x](x, x.x)) < x[x](x)
          }
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x) == x)

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x, x: x[x], x: x[x]): Unit = {
  require(x[x](x, x[x](x, x)) == x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x[x](x, x[x]())), x) != x)), "Choose satisfiability")
  x[x](x, x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x[x](x, x)) != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x[x](x, x)) != x || {
    val x: Unit = x[x](x.x, x, x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x, x[x]())), x) == x)
      x
    }
    x[x](x[x](x, x[x](x, x[x]())), x) == x
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) != x[x](x) || x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || x[x](x, (x: x) => x[x](x, x))
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || x[x](x[x](x), x[x](x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || x[x](x.x, x) && x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x).subsetOf(x[x](x)) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x[x](x, x)) != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x[x](x, x)) != x || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x) < x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || !x[x](x[x](x), x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x) == x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      val x: Unit = x[x](x, x.x)
      val x: Unit = {
        assume(x[x](x.x) <= x[x](x))
        x
      }
      x[x](x.x) > x[x](x) || x[x](x.x) + BigInt("1") != x[x](x) || x[x](x, x.x)
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: (x) => Boolean): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@opaque
@library
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: (x) => Boolean): Unit = choose((x: Unit) => x[x](x, x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = x[x](x, x, x.x)
  !x[x](x.x, x) || !x[x](x, x) || {
    val x: Unit = x[x](x, x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x))
      x
    }
    x[x](x, x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x.x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || x.isInstanceOf[x]
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || x.isInstanceOf[x] || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x, x) || x == x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@opaque
@library
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = x[x](x, x, x.x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || x[x](x, (x: x) => x[x](x[x](x, x), x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x) || !x[x](x, x.x) || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x) >= x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      x[x](x.x, (x: x) => x[x](x, x))
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x, x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, x) || !x.isInstanceOf[x] || !x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !(x.x == x.x && x[x](x.x, x.x)) || x[x](x.x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x) || !x[x](x.x, x.x) || x[x](x.x) + x[x](x.x) < x[x](x) + x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x.x) || !x[x](x, (x: x) => !x[x](x, x)) || x == x[x](x, x.x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      val x: Unit = x[x](x, x.x)
      val x: Unit = {
        assume(x[x](x.x) <= x[x](x))
        x
      }
      x[x](x.x) <= x[x](x)
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || x.isInstanceOf[x] || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x != x[x]()
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x.isInstanceOf[x] || x[x](x, x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || x[x](x[x](x, x), (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x.isInstanceOf[x] || x[x](x, x[x](x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) != x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x)) < x[x](x.x))
    x
  }
  x[x](x[x](x, x)) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      val x: Unit = x[x](x, x.x)
      val x: Unit = {
        assume(x[x](x.x) <= x[x](x))
        x
      }
      x[x](x.x) > x[x](x) || x[x](x.x) + BigInt("1") != x[x](x) || !x[x](x, x.x) || x[x](x) != x[x](x) \\ Set(x.x) || x[x](x, x.x)
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x[x](x) != x || x == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x) <= x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x) <= x[x](x))
      x
    }
    x[x](x) <= x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || BigInt("1") + x[x](x.x, x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x) == x)
  require(!x[x](x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || {
      val x: Unit = x[x](x.x, x, x, x)
      val x: Unit = {
        assume(x[x](x, x[x](x)))
        x
      }
      x != x[x]()
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x, x) != x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x.isInstanceOf[x] || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || x[x](x, x.x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x) || !x.isInstanceOf[x] || x[x](x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x, x[x](x, x)) != x || !x.isInstanceOf[x] || x[x](x.x, x[x](x, x)) == x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) != x[x](x) || x[x](x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  !x[x](x) || x[x](x[x](x.x, x[x]()))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) == x.x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x, x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  x[x](x.x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x, x) != x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(!x[x](x))
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x)))
      x
    }
    x[x](x, x[x](x))
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  !x[x](x[x](x), x) || x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) < x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x) == x)
  require(!x[x](x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || {
      val x: Unit = x[x](x.x, x, x, x)
      val x: Unit = {
        assume(x[x](x, x[x](x)))
        x
      }
      x[x](x, x[x](x))
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x, x) || x[x](x) == x || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || !x[x](x[x](x), x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x.isInstanceOf[x] || !x.x.isInstanceOf[x] || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || x[x](x.x, x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x[x](x, x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x, (x: x) => !x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || x[x](x, (x: x) => x[x](x, x))
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x[x](x, x)) != x || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x), x) != x[x](x, x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || {
  val x: x[x] = x[x](x[x](x), x[x]())
  val x: x[x] = x[x](x)
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x[x](x[x](x), x[x]()))
  x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x) >= x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || !x[x](x) || x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || x[x](x[x](x), x[x](x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
x.isInstanceOf[x] || x[x](x) < x[x](x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x) != x || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x) || !x[x](x, x.x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !!x[x](x) || !x[x](x[x](x), x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x[x](x.x, x[x](x, x[x]())), x) != x || x[x](x[x](x.x, x[x](x, x[x]())), x) == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x), x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x.x, (x: x) => !x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@opaque
@library
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = x[x](x, x, x.x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || !x[x](x[x](x), x) || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x.x == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x == x[x](x[x](x.x, x[x]()), x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x.x, x) == x
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || x.isInstanceOf[x] && !x[x](x, x.x) || !x.isInstanceOf[x] || x[x](x) && x[x](x[x](x, x)) == x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || true
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !!x[x](x) || {
    val x: x[x] = x[x](x)
    !x[x](x, x) || !x[x](x, x) || {
      val x: Unit = x[x](x, x, x)
      val x: Unit = {
        assume(x[x](x, x))
        x
      }
      x[x](x) || x != x[x]()
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] && x.x != x || x.isInstanceOf[x]
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    !x[x](x[x](x), x) || x[x](x.x, x) != x || true
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  require(!x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x), x))
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x.x) || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x), x.x))
    x
  }
  x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x.x) || !x[x](x, (x: x) => !x[x](x, x)) || true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  x[x](x.x, x) && x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x]
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) == x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || x.isInstanceOf[x] || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          x[x](x, (x: x) => x[x](x, x))
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  !x[x](x) || !x[x](x.x, x) || x[x](x, x[x](x, x.x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x.x != x || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x))
      x
    }
    x[x](x, x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] && x.x != x || x.isInstanceOf[x]
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || !x[x](x[x](x.x, x[x](x, x[x]())), x[x](x)) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !!x[x](x) || x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || x.isInstanceOf[x] || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  !x[x](x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x[x]()
      case x(x, x) if x(x) =>
        x[x](x, x[x](x, x))
      case x(_, x) =>
        x[x](x, x)
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) <= x[x](x) && x[x](x).subsetOf(x[x](x))) && x[x](x, x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || x.x != x || !x[x](x[x](x, (x: x) => x[x](x, x)))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  x[x](x[x](x, x[x](x.x, x[x]())))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x) == x || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || {
    val x: x[x] = x[x](x, x)
    x != x[x]()
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x[x](x, (x: x) => !x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => !x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => !x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  x[x](x[x](x, x), (x: x) => !x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x) || !x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x[x](x), x) || x[x](x.x, x) == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x, x) != x[x](x.x, x) || x[x](x.x, x) || x[x](x[x](x, x)) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x[x](x.x, x[x](x.x)), x[x](x[x](x), x[x]())) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x != x[x](x, x[x]()) || !x.isInstanceOf[x] || x[x](x.x, x) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

def x[x](x: x[x], x: x[x], x: x[x]): x[x] = {
  require(x[x](x))
  require(x[x](x, x))
  require(x[x](x, x[x](x, x)))
  require(x[x](x[x](x, x)) == x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      x[x](x, x, x)
    case x(x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaSubSeqAddSameElmtPreserves")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: Unit = x[x](x)
        assume((x[x](x, (x: x) => !x[x](x[x](), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x]()
        val x: x = x
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (1/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        assert((!x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, (x: x) => !x[x](x[x](x, x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x[x]())
        assert((x[x](x)): @DropVCs , "Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x)): @DropVCs , "Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis")
        val x: Unit = x[x](x, x)
        assume((x[x](x[x](x, x))): @DropVCs )
        x
      }
      x[x](x, x, x[x](x, x[x](x, x[x]())))
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => ((x[x](x) && x[x](x, x)) && x[x](x) == x[x](x[x](x, x))) && x[x](x) == x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x.x, x[x](x, x[x](x.x, x[x]())))
  x[x](x) && x[x](x, x) && x[x](x) == x[x](x[x](x, x)) && x[x](x) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  !x[x](x, (x: x) => !x[x](x[x](), x)) || !x[x](x, x.x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x) == x[x](x))
  require(x[x](x) == x[x](x))
  require(x[x](x) <= BigInt("1"))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x != x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x == x)

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x.x == x)
      x
    }
    x == x
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x, x: x[x]): Unit = {
  require(x[x](x[x](x, x[x](x, x[x]())), x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x.x, x[x](x, x[x]())), x) || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x))
      x
    }
    x[x](x, x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x, x)
  x[x](x, (x: x) => !x[x](x[x](x, x), x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] || {
  val x: Boolean = false
  !x || {
    val x: Unit = {
      assume(x)
      ()
    }
    x[x](x[x](x, x)) < x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x.x, x.x)
  val x: Unit = {
    assume(x[x](x, x.x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) >= x[x](x) || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x.x))
    x
  }
  x[x](x) || x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, (x: x) => x(x)) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x.x) || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x.x, x.x)
  val x: Unit = {
    assume(x[x](x, x.x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x, x: x[x]): Unit = {
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x, x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x.x)
  val x: Unit = {
    assume(x[x](x.x, x[x](x.x, x.x)))
    x
  }
  x[x](x) || x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x.x, x)) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    !x[x](x) || x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x.x != x || BigInt("0") >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !!x[x](x) || {
    val x: x[x] = x[x](x)
    !x[x](x, x) || !x[x](x, x) || x[x](x, x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || x.isInstanceOf[x] || x[x](x[x](), x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x) || !x[x](x, x.x) || x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || x.isInstanceOf[x] || x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => !x[x](x, x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x[x](x, x))
    assert(!forall((x: Unit) => !!x[x](x, x)), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => !x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  !x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: x[x]) => !(x[x](x) && x[x](x[x](x, x)) == x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: x[x]) => x[x](x) && x[x](x[x](x, x)) == x[x](x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): x[x] = choose((x: x[x]) => x[x](x) && x[x](x[x](x, x)) == x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: x[x] = x[x](x, x.x)
  val x: x[x] = {
    assume(x[x](x) && x[x](x[x](x, x.x)) == x[x](x))
    x
  }
  x[x](x) && x[x](x[x](x, x)) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x != x[x](x, x[x]()) || !x.isInstanceOf[x] || x[x](x.x, x) || x == x[x](x, x[x]())
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x.x) <= x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x.x) < x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): x[x] = choose((x: x[x]) => x[x](x) && x[x](x[x](x, x)) == x[x](x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: x[x]) => !(x[x](x) && x[x](x[x](x, x)) == x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: x[x]) => x[x](x) && x[x](x[x](x, x)) == x[x](x)
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || x[x](x, x.x) || {
  val x: x[x] = x[x](x.x, x)
  !x[x](x) || {
    val x: x[x] = x[x](x, x.x)
    val x: x[x] = {
      assume(x[x](x) && x[x](x[x](x, x.x)) == x[x](x))
      x
    }
    x[x](x) && x[x](x[x](x, x)) == x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || x[x](x.x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      val x: Unit = x[x](x, x.x)
      val x: Unit = {
        assume(x[x](x.x) <= x[x](x))
        x
      }
      x[x](x.x) > x[x](x) || x[x](x.x) + BigInt("1") != x[x](x) || !x[x](x, x.x) || x[x](x) != x[x](x) \\ Set(x.x) || {
        val x: Unit = x[x](x, x.x)
        val x: Unit = {
          assume(x[x](x[x](x, x.x)) < x[x](x))
          x
        }
        x[x](x) <= x[x](x) || x[x](x) <= x[x](x)
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x.x)))
    x
  }
  x[x](x) < x[x](x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          !x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x)
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x == x || !x.isInstanceOf[x] || !x[x](x[x](x, x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          !x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || x[x](x, (x: x) => x[x](x, x))
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          !x[x](x, (x: x) => x[x](x, x)) || x[x](x, x.x) || x != x[x](x, x.x) || x[x](x, (x: x) => x[x](x, x))
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x == x || x.isInstanceOf[x] || !x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x.isInstanceOf[x] || x[x](x, x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x[x](x, x)) || x.isInstanceOf[x] || x[x](x[x](x.x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || x[x](x, (x: x) => x[x](x, x)) && x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x, x[x](x[x](x), x.x)) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x]
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) == x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x == x.x || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) + x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x) < x[x](x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || !x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !(x[x](x) || !x[x](x[x](x), x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x) || !x[x](x[x](x), x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x) || !x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x.x, x[x](x.x, x)))
    x
  }
  x[x](x, x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x) || !x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) >= x[x](x) || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x.x)
  val x: Unit = {
    assume(x[x](x, x.x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(!x[x](x, x))
  require(x == x[x](x, x[x]()))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, (x: x) => x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, (x: x) => x[x](x, x)))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x[x]()
      case x(x, x) if x(x) =>
        x[x](x, x[x](x, x))
      case x(_, x) =>
        x[x](x, x)
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) <= x[x](x) && x[x](x).subsetOf(x[x](x))) && x[x](x, x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, (x: x) => x[x](x, x))))
x[x](x, x) || x != x[x](x, x[x]()) || !x.isInstanceOf[x] || x[x](x.x, x) || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x.x, (x: x) => x[x](x, x))))
    x
  }
  x[x](x[x](x, (x: x) => x[x](x, x)))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x.x) || x[x](x.x, (x: x) => x[x](x, x))
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || !x[x](x.x, (x: x) => x[x](x, x)) || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  require(x[x](x) <= x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || {
    val x: Unit = x[x](x, x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x))
      x
    }
    x[x](x, x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  !x[x](x[x](x, x[x](x.x, x[x]()))) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x[x](x, x)) != x || x.isInstanceOf[x] || x[x](x[x](x, x[x](x, x[x]())), x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    !x[x](x[x](x), x) || x[x](x.x, x) == x
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) != x[x](x) || x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x) == x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x.x) || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) || !x.isInstanceOf[x] || x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  !x[x](x[x](x), x) || x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !x[x](x) || x[x](x) || x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || x[x](x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x, x)
  x[x](x, (x: x) => x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    !x[x](x) || !x[x](x, x.x) || x[x](x, x.x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || {
            val x: Unit = if (x[x](x.x, x.x)) {
              val x: Unit = x[x](x.x, x.x)
              val x: Unit = {
                assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
                x
              }
              assume(false)
              ()
            } else {
              ()
            }
            x[x](x.x) < x[x](x)
          }
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x[x](x) != x || x == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] || x[x](x, x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x && x[x](x.x, x.x) || !x[x](x, x.x) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || x[x](x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || x[x](x, x.x) || !x[x](x[x](x.x, x)) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x, x) != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || x.isInstanceOf[x] || x[x](x, x[x](x[x](x, x[x]()), x)) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x[x](x.x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || {
    val x: x[x] = x[x](x, x)
    x != x[x]()
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x, x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x == x || !x[x](x.x) || !x[x](x.x, x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x.x) || x[x](x[x](x.x, x)) == x[x](x.x) - BigInt("1"))
    x
  }
  x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x[x](x, x), x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || !x[x](x, x.x)
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x.x, x)) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x != x[x](x, x[x]()) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x.x, x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || x.isInstanceOf[x] || x[x](x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x, x) || x[x](x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) != x[x](x) || x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x) || !x[x](x.x, (x: x) => !x[x](x, x)) || {
  val x: Unit = x[x](x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x)))
    x
  }
  x[x](x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || x[x](x, (x: x) => !x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || x.isInstanceOf[x] || x[x](x, x[x](x)) == x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x.x) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || x[x](x[x](x.x, x[x](x.x, x)), x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  x[x](x[x](x, x[x](x.x, x[x]())))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  !x[x](x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
x[x](x) || !x.isInstanceOf[x] || !x.x.isInstanceOf[x] || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || x[x](x.x).subsetOf(x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x) || x[x](x.x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) < x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x.isInstanceOf[x] || x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x) || !x[x](x.x, x.x) || x[x](x.x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
x.isInstanceOf[x] || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || x[x](x[x](x, x), (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          !x[x](x, (x: x) => x[x](x, x)) || x[x](x, x.x) || x == x[x](x, x.x)
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x) != x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !x[x](x) || x[x](x) || x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || x[x](x, (x: x) => !x[x](x.x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x.x) || x[x](x.x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x[x](x, x), x)) || x.isInstanceOf[x] || x[x](x.x, (x: x) => !x[x](x[x](x, x), x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x) == x || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || x[x](x.x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x.isInstanceOf[x] || x[x](x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, (x: x) => x(x)) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || x[x](x, x.x) || x[x](x[x](x.x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || x[x](x, (x: x) => x[x](x, x))
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x[x](x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x) >= x[x](x, x) || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x, (x: x) => x[x](x, x), x.x)
  !x[x](x, (x: x) => x[x](x, x)) || x[x](x.x).subsetOf(x[x](x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x.x) || {
  val x: Unit = x[x](x.x, x.x, x.x)
  val x: Unit = {
    assume(x[x](x.x, x.x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || {
            val x: Unit = if (x[x](x.x, x.x)) {
              val x: Unit = x[x](x.x, x.x)
              val x: Unit = {
                assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
                x
              }
              assume(false)
              ()
            } else {
              ()
            }
            x[x](x)
          }
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || x[x](x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || !x[x](x[x](x), x[x](x)) || x[x](x) >= x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x, x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x[x](x)) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x) || x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x) == x || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    !x[x](x) || !x[x](x, x.x) || x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || x[x](x, x.x) || {
  val x: x[x] = x[x](x.x, x)
  !x[x](x) || x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
!x.isInstanceOf[x] || x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || !x[x](x) || !x[x](x) || x[x](x) || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x[x](x, x), x)) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x[x](x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x.isInstanceOf[x] || x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) + x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x.x, x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x.x != x || {
    val x: BigInt = x[x](x)
    x[x](x.x)
  } < {
    val x: BigInt = x[x](x)
    x[x](x)
  } || {
    val x: BigInt = x[x](x)
    x[x](x.x)
  } == {
    val x: BigInt = x[x](x)
    x[x](x)
  } && {
    val x: BigInt = x[x](x.x)
    x[x](x)
  } < {
    val x: BigInt = x[x](x)
    x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) <= BigInt("1")
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  x[x](x, (x: x) => !x[x](x[x](), x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  !x[x](x[x](x, x[x](x.x, x[x]()))) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, x) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x) < x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || x[x](x, x) && x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x.x) <= x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  x[x](x, (x: x) => !x[x](x[x](), x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => !x[x](x, x)) || !x[x](x.x) || x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x, x) || x[x](x) == x || true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) < x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x[x](x.x, x[x]()))
  !x[x](x) || !x[x](x.x, x) || x[x](x, x[x](x, x.x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || x[x](x.x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x.x) || x[x](x, (x: x) => !x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x, (x: x) => x[x](x, x), x.x)
  x[x](x, (x: x) => x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x.isInstanceOf[x] || !x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x).subsetOf(x[x](x)) || x[x](x).subsetOf(x[x](x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x, x[x](x[x](x), x.x)) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x.isInstanceOf[x] || x[x](x, x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x.x != x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x, (x: x) => x[x](x, x), x.x)
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x.x).subsetOf(x[x](x)) || x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x) || !x[x](x.x, x.x) || {
  val x: Unit = x[x](x.x, x.x)
  val x: Unit = {
    assume(x[x](x.x, x.x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x != x[x](x, x[x]()) || !x.isInstanceOf[x] || !x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x) != x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  require(x[x](x) <= x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || {
    val x: Unit = x[x](x, x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x))
      x
    }
    x[x](x, x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || !x[x](x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || {
            val x: Unit = if (x[x](x.x, x.x)) {
              val x: Unit = x[x](x.x, x.x)
              val x: Unit = {
                assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
                x
              }
              assume(false)
              ()
            } else {
              ()
            }
            !x[x](x) || x[x](x) != x[x](x.x) || x[x](x) == x[x](x.x)
          }
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) >= x[x](x) || !x[x](x, x.x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) <= BigInt("1")
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x) != x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x.x, x[x](x.x, x)))
    x
  }
  x[x](x, x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x) || !x.isInstanceOf[x] || x[x](x, (x: x) => !x[x](x[x](x, x), x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x[x]()
      case x(x, x) if x(x) =>
        x[x](x, x[x](x, x))
      case x(_, x) =>
        x[x](x, x)
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) <= x[x](x) && x[x](x).subsetOf(x[x](x))) && x[x](x, x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x, x) || x != x[x](x, x[x]()) || x.isInstanceOf[x] || x[x](x[x](x, (x: x) => x[x](x, x)))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || x.isInstanceOf[x] || x == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || !x.isInstanceOf[x] || x.x != x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@opaque
@library
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = x[x](x, x, x.x)
  x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || x.isInstanceOf[x] || x[x](x.x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
x.isInstanceOf[x] || x[x](x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x != x || x.isInstanceOf[x] || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  !x[x](x[x](x), x) || x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

def x[x](x: x[x], x: x[x], x: x[x]): x[x] = {
  require(x[x](x))
  require(x[x](x, x))
  require(x[x](x, x[x](x, x)))
  require(x[x](x[x](x, x)) == x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      x[x](x, x, x)
    case x(x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaSubSeqAddSameElmtPreserves")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: Unit = x[x](x)
        assume((x[x](x, (x: x) => !x[x](x[x](), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x]()
        val x: x = x
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (1/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        assert((!x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, (x: x) => !x[x](x[x](x, x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x[x]())
        assert((x[x](x)): @DropVCs , "Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x)): @DropVCs , "Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis")
        val x: Unit = x[x](x, x)
        assume((x[x](x[x](x, x))): @DropVCs )
        x
      }
      x[x](x, x, x[x](x, x[x](x, x[x]())))
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => ((x[x](x) && x[x](x, x)) && x[x](x) == x[x](x[x](x, x))) && x[x](x) == x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x.x, x[x](x, x[x](x.x, x[x]())))
  x[x](x) && x[x](x, x) && x[x](x) == x[x](x[x](x, x)) && x[x](x) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x == x || !x[x](x.x) || !x[x](x.x, x) || x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x[x](x.x, x[x]()))
  !x[x](x) || !x[x](x.x, x) || x[x](x, x[x](x, x.x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x.x != x || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x))
      x
    }
    x[x](x, x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || x.isInstanceOf[x] || x[x](x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x == x || x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) <= x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x[x](x))) + x[x](x[x](x))
} < {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x)) + x[x](x)
} || {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x[x](x))) + x[x](x[x](x))
} == {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x)) + x[x](x)
} && {
  val x: BigInt = (BigInt("0") + x[x](x[x](x))) + x[x](x[x](x))
  BigInt("0")
} < {
  val x: BigInt = (BigInt("0") + x[x](x)) + x[x](x)
  BigInt("0")
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || x[x](x.x).subsetOf(x[x](x))
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x) == x || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) == x[x](x) || !false || x[x](x) >= x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || !x[x](x[x](x), x[x](x)) || x[x](x) >= x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x, x)))
      x
    }
    x[x](x, x[x](x, x))
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x[x](x.x, x[x]()))
  !x[x](x) || !x[x](x.x, x) || !x[x](x, x[x](x, x.x)) || x[x](x[x](x, x.x)) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          !x[x](x, (x: x) => x[x](x, x)) || x[x](x, x.x) || x != x[x](x, x.x) || !x[x](x, (x: x) => x[x](x, x)) || true
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || x[x](x[x](x), x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x.x, x)) || x[x](x.x, (x: x) => !x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x), x) || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) == x.x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x != x || x[x](x.x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x == x.x || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x == x || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x, (x: x) => x[x](x, x), x.x)
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x.x).subsetOf(x[x](x)) || x[x](x, (x: x) => x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || true
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  x[x](x, (x: x) => !x[x](x[x](x, x.x), x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x, (x: x) => x[x](x, x), x.x)
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x.x).subsetOf(x[x](x)) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x.x).subsetOf(x[x](x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || x[x](x.x) == x[x](x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    !x[x](x[x](x), x) || x[x](x.x, x) == x
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || x[x](x)
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || x[x](x.x) == x[x](x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || x[x](x[x](x.x, x[x](x, x[x]())), x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x.x) || !x[x](x, (x: x) => !x[x](x, x)) || true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x[x](x, x)) != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x[x](x, x)) != x || x[x](x.x, x[x](x, x)) == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x[x](x, x), (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x.x)
  val x: Unit = {
    assume(x[x](x, x.x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x) <= x[x](x))
      x
    }
    x[x](x) <= x[x](x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || !x[x](x.x, x.x) || x[x](x.x, x.x)
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || x.isInstanceOf[x] || !x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x, x.x)
  x[x](x, x) && x[x](x, x.x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x.x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || x.isInstanceOf[x] || x == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x, x) != x[x]()
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x.x, x)) || !x[x](x.x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x.x, x)) || x[x](x.x, (x: x) => !x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || {
  val x: Boolean = x[x](x[x](x), x[x](x))
  true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x, x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x != x[x](x, x[x]()) || !x.isInstanceOf[x] || x[x](x.x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x[x](x)) >= x[x](x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  !x[x](x, (x: x) => !x[x](x[x](), x)) || !x[x](x, x.x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  require(x[x](x, x) == x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x != x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x == x)

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || {
    val x: Unit = x[x](x, x, x)
    val x: Unit = {
      assume(x == x)
      x
    }
    x == x
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) >= x[x](x)
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x, x) || x[x](x, x) == x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x.x) || !x[x](x, x.x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x.isInstanceOf[x] || x[x](x) >= x[x](x) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------


x.isInstanceOf[x] || x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@opaque
@library
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = x[x](x, x, x.x)
  !x[x](x.x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || !x[x](x) || !x[x](x) || x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x == x || x[x](x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x, x) || x[x](x) == x || true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x, x) == x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x && x[x](x.x, x.x) || !x[x](x, x.x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) >= x[x](x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || x.isInstanceOf[x] || x == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      x[x](x, (x: x) => x[x](x, x))
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x == x.x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x[x](x))) + x[x](x[x](x))
} < {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x)) + x[x](x)
} || {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x[x](x))) + x[x](x[x](x))
} == {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x)) + x[x](x)
} && {
  val x: BigInt = (BigInt("0") + x[x](x[x](x))) + x[x](x[x](x))
  BigInt("0")
} < {
  val x: BigInt = (BigInt("0") + x[x](x)) + x[x](x)
  BigInt("0")
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)) == x[x](x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x) == x)
  require(!x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x[x](x)) != x[x](x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x)) == x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x) != x || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x)) == x[x](x))
      x
    }
    true
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || x[x](x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || !x.isInstanceOf[x] || x[x](x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x, x) == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || x[x](x, x) && x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || x[x](x.x, x) && x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: (x) => Boolean, x: (x) => Boolean): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x(x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x(x) || x(x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x(x) || x(x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: (x) => Boolean): Unit = choose((x: Unit) => x[x](x, (x: x) => x(x) || x(x)))
!x[x](x, (x: x) => x(x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  x[x](x, (x: x) => x(x) || x(x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, (x: x) => x(x)) || !x.isInstanceOf[x] || x[x](x, (x: x) => x(x) || x(x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

def x[x](x: x[x], x: x[x], x: x[x]): x[x] = {
  require(x[x](x))
  require(x[x](x, x))
  require(x[x](x, x[x](x, x)))
  require(x[x](x[x](x, x)) == x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      x[x](x, x, x)
    case x(x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaSubSeqAddSameElmtPreserves")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: Unit = x[x](x)
        assume((x[x](x, (x: x) => !x[x](x[x](), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x]()
        val x: x = x
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (1/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        assert((!x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, (x: x) => !x[x](x[x](x, x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x[x]())
        assert((x[x](x)): @DropVCs , "Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x)): @DropVCs , "Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis")
        val x: Unit = x[x](x, x)
        assume((x[x](x[x](x, x))): @DropVCs )
        x
      }
      x[x](x, x, x[x](x, x[x](x, x[x]())))
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => ((x[x](x) && x[x](x, x)) && x[x](x) == x[x](x[x](x, x))) && x[x](x) == x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x.x, x)
  x[x](x) && x[x](x, x) && x[x](x) == x[x](x[x](x, x)) && x[x](x) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  x[x](x[x](x, x), (x: x) => x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || x[x](x[x](x, x[x](x, x[x]())), x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x[x](x, x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] && x.x != x || x.isInstanceOf[x] || stainless.lang.error[BigInt]("match exhaustiveness") >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !(x.x != x) || !x[x](x.x, x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, (x: x) => x(x)) || !x.isInstanceOf[x] || x[x](x, (x: x) => x(x) || x(x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x.x, x)))
    x
  }
  x[x](x, x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || x.isInstanceOf[x] && !x[x](x, x.x) || x.isInstanceOf[x] || {
  val x: x[x] = stainless.lang.error[x[x]]("match exhaustiveness")
  x[x](x) && x[x](x[x](x, x)) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  require(!x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x), x))
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x.x) || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x), x.x))
    x
  }
  true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x) < x[x](x) || x[x](x, x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  require(!x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x.x) || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x), x.x))
    x
  }
  x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x && x[x](x.x, x.x) || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x.x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x, x[x]())), x[x](x.x, x[x](x, x[x]()))))
    x
  }
  x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x) + x[x](x.x) < x[x](x) + x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      val x: Unit = x[x](x, x.x)
      val x: Unit = {
        assume(x[x](x.x) <= x[x](x))
        x
      }
      x[x](x.x) > x[x](x) || x[x](x.x) + BigInt("1") == x[x](x)
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x) == x || true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x) != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || !x.isInstanceOf[x] || x[x](x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || !x.isInstanceOf[x] || x[x](x) || !x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x.isInstanceOf[x] || !true || x[x](x) >= x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x) || x[x](x.x, (x: x) => !x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  x[x](x).subsetOf(x[x](x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x), x) != x[x](x, x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x), x) == x[x](x.x, x[x](x, x)))
    x
  }
  x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) >= x[x](x) || !x[x](x, x.x) || x[x](x.x) + x[x](x) < x[x](x) + x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || x[x](x.x, x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || !x[x](x.x, x.x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x).subsetOf(x[x](x)) || !x.isInstanceOf[x] || x[x](x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x) || x.isInstanceOf[x] || x[x](x.x, (x: x) => !x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x.x, x) == x
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x.x, x[x](x.x))
  true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x[x](x, x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x[x](x) != x || x != x || x == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
x.isInstanceOf[x] || x[x](x, x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x.x)))
    x
  }
  x[x](x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x), x) != x[x](x, x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || {
  val x: x[x] = x[x](x[x](x), x[x]())
  val x: x[x] = x[x](x)
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))
    x
  }
  x[x](x[x](x, x[x](x[x](x), x[x]())), x[x](x)) == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || !x[x](x.x, x.x) || {
            val x: Unit = x[x](x.x, x.x)
            val x: Unit = {
              assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
              x
            }
            x[x](x[x](x.x, x.x)) < x[x](x.x)
          }
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !(x.x != x) || x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || x.isInstanceOf[x] || x[x](x) <= x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  !x[x](x[x](x), x) || x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || x[x](x[x](x), x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || x.isInstanceOf[x] || x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
x.isInstanceOf[x] || x[x](x) >= x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  x[x](x, x) && x[x](x, x.x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) <= BigInt("1")
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x]
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    !x[x](x[x](x), x) || x[x](x.x, x) != x || true
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x), x) != x[x](x, x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || {
  val x: x[x] = x[x](x[x](x), x[x]())
  val x: x[x] = x[x](x)
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))
    x
  }
  x[x](x[x](x, x[x](x[x](x), x[x]())), x[x](x)) == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(!x[x](x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(x, x), x(x, x)) =>
      val x: Boolean = x[x](x, x)
      if (x) {
        x[x](x, x)
      } else {
        val x: Boolean = !x[x](x)
        if (x) {
          x[x](x, x)
        } else {
          ()
        }
      }
    case _ =>
      ()
  }
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
x.isInstanceOf[x] || x.x != x || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: Unit = x[x](x, x)
  x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x)
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
{
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x)) + x[x](x)
} >= BigInt("0") && {
  val x: BigInt = (BigInt("0") + x[x](x)) + x[x](x)
  BigInt("0")
} >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || !x.isInstanceOf[x] || !false || x[x](x) >= x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------


x != x || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || !x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !(x[x](x) || !x[x](x[x](x), x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x) || !x[x](x[x](x), x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x) || x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) != x[x](x) || x[x](x) || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x.x != x || x.x == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x), x) != x[x](x, x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || {
  val x: x[x] = x[x](x[x](x), x[x]())
  val x: x[x] = x[x](x)
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x[x](x[x](x), x[x]()))
  x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x[x](x, x)) != x || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x.isInstanceOf[x] || x[x](x, x[x](x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(!x[x](x))
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x)))
      x
    }
    true
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || x[x](x.x, x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  !x[x](x) || !x[x](x.x, x) || x[x](x, x[x](x, x.x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || !x.isInstanceOf[x] || x[x](x, x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) <= x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || !x[x](x[x](x.x, x[x](x, x[x]())), x[x](x)) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) >= x[x](x) || !x[x](x, x.x) || x[x](x) + x[x](x.x) < x[x](x) + x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x.x, x)) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x.x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x) || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x, x.x)
  val x: Unit = {
    assume(x[x](x.x, x.x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x, (x: x) => !x[x](x[x](x, x.x), x)) || x[x](x, (x: x) => !x[x](x[x](x, x.x), x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) < x[x](x.x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !(x.x == x.x && x[x](x.x, x.x)) || !x[x](x.x, x.x) || x[x](x.x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) < x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x.x, (x: x) => !x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x == x)

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  require(x[x](x) == x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x != x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x == x
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x.x == x)
      x
    }
    x == x
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) || !x.isInstanceOf[x] || !x.x.isInstanceOf[x] || x[x](x[x](), x[x](x[x](x), x[x]())) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || x[x](x, (x: x) => x[x](x, x))
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || !x[x](x, (x: x) => !x[x](x, x)) || x == x[x](x[x](x.x, x[x]()), x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x.isInstanceOf[x] || x[x](x, x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x.x) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  x[x](x[x](x), x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x)

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(!x[x](x, x))
    assert(!forall((x: Unit) => (x[x](x, x) != x)), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, x) == x
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x != x || x[x](x.x, x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x.x, x) == x.x)
    x
  }
  x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || !x[x](x.x, x.x) || {
            val x: Unit = x[x](x.x, x.x)
            val x: Unit = {
              assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
              x
            }
            x[x](x[x](x.x, x.x)) >= x[x](x.x) || x[x](x[x](x, x.x)) >= x[x](x.x) || true
          }
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || x.isInstanceOf[x] && !x[x](x, x.x) || x.isInstanceOf[x]
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || !x.isInstanceOf[x] || x[x](x[x](x.x, x[x](x, x[x]())), x) != x[x](x) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x != x || x != x || x[x](x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) < x[x](x.x) || x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || x[x](x.x, x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------


x.isInstanceOf[x] || x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || x[x](x.x, x[x](x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x)
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || !x.isInstanceOf[x] || x.x != x || {
  val x: Boolean = false
  !x || {
    val x: Unit = {
      assume(x)
      ()
    }
    !x[x](x[x](x, x), x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x != x || !x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x.x == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x[x](x[x](x), x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || x[x](x, x) < x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !(x.x != x) || !x[x](x.x, x) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x.isInstanceOf[x] || x[x](x, (x: x) => !x[x](x[x](), x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x[x](x, x), x)) || !x.isInstanceOf[x] || x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x) != x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x == x || !x[x](x.x) || !x[x](x.x, x) || x[x](x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || x[x](x.x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x.x, x) == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}
x[x](x) <= BigInt("0") || x[x](x[x](x)) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x))
    require(x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x)), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x))
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || x.isInstanceOf[x] || x[x](x) || {
  val x: x[x] = x[x](x, x)
  x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x == x || !x[x](x.x) || x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) == x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x.isInstanceOf[x] || x[x](x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) == x[x](x) || !false || x[x](x) >= x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x, x) != x[x]()
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](stainless.lang.error[x[x]]("match exhaustiveness"), x[x](x[x](x), x[x]())) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || x[x](x, x) < x[x](x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x[x](x, x)) || !x.isInstanceOf[x] || x[x](x, (x: x) => !x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x).subsetOf(x[x](x)) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || x.isInstanceOf[x] || x[x](x) && x[x](x, x) && x[x](x) == x[x](x[x](x, x)) && x[x](x) == x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  x[x](x, (x: x) => !x[x](x[x](x, x), x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || x[x](x, (x: x) => x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] && x.x != x || !x.isInstanceOf[x]
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x) || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x, x.x))
    x
  }
  x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x.x) || x[x](x, x.x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x[x](x.x, x[x]()))
  !x[x](x) || !x[x](x.x, x) || !x[x](x, x[x](x, x.x)) || x[x](x[x](x, x.x)) == x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x == x || x.isInstanceOf[x] || x[x](x.x, x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x[x](x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x[x](x, x), x)) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x) == x)
  require(!x[x](x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || {
      val x: Unit = x[x](x.x, x, x, x)
      val x: Unit = {
        assume(x[x](x, x[x](x)))
        x
      }
      x != x[x]()
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: (x) => Boolean, x: (x) => Boolean): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x(x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x(x) || x(x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x(x) || x(x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: (x) => Boolean): Unit = choose((x: Unit) => x[x](x, (x: x) => x(x) || x(x)))
!x[x](x, (x: x) => x(x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  x[x](x, (x: x) => x(x) || x(x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) == x
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || x != x[x]()
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x[x](x, x)) != x || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) >= x[x](x) || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x.x))
    x
  }
  x[x](x) || x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || x[x](x.x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || true
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || true
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x != x[x]()
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  x[x](x, (x: x) => x[x](x, x))
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || x != x[x]()
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x.x) || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x)
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !(x.x != x) || !x[x](x.x, x) || x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || !x.isInstanceOf[x] || x[x](x, (x: x) => x[x](x, x))
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x[x](x) >= BigInt("0")
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || !x[x](x.x, x.x) || {
            val x: Unit = x[x](x.x, x.x)
            val x: Unit = {
              assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
              x
            }
            x[x](x[x](x.x, x.x)) >= x[x](x.x) || x[x](x[x](x, x.x)) < x[x](x.x)
          }
        }
      }
    }
  }
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || !x.isInstanceOf[x] || x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
x.isInstanceOf[x] || x.x != x || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  !x[x](x) && x[x](x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => !x[x](x, x)) || !x[x](x.x, x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x.x, x) == x
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || x[x](x.x, x) < x[x](x.x, x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x == x || !x[x](x.x) || !x[x](x.x, x) || x[x](x.x) < x[x](x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): x = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x), x) || x[x](x) < x[x](x)
}
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x == x || x[x](x) || x[x](x[x](x), x)
VC BEGIN
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x[x](x, x[x]()), x)) == x)

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x, x: x[x], x: x[x]): Unit = {
  require(x[x](x[x](x, x[x](x, x[x]())), x) == x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x[x](x[x](x, x[x]()), x)) != x)), "Choose satisfiability")
  x[x](x, x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x[x](x, x[x]()), x)) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x[x](x.x, x[x](x, x[x]())), x) != x || {
    val x: Unit = x[x](x.x, x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x[x](x, x[x]()), x)) == x)
      x
    }
    x[x](x, x[x](x[x](x, x[x]()), x)) == x
  }
}