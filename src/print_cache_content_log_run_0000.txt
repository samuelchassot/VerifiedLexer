CACHE CONTENT
VC number 0
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 1
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x[x](x, x)) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 2
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 3
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || x[x](x.x, x) < x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 4
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
x.isInstanceOf[x] || x[x](x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 5
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x), (x: x) => x[x](x, x)))
    x
  }
  x[x](x[x](x, x), (x: x) => x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 6
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x.x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x, x[x]())), x[x](x.x, x[x](x, x[x]()))))
    x
  }
  x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 7
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x, x.x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 8
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x.x) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 9
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 10
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(!x[x](x))
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x)))
      x
    }
    true
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 11
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 12
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  !x[x](x) || x[x](x[x](x.x, x[x]()))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 13
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x != x || !x.isInstanceOf[x] || x.x == x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 14
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 15
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 16
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x, x[x](x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 17
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 18
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 19
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || x[x](x[x](x.x, x[x](x, x[x]())), x[x](x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 20
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x)
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 21
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 22
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || {
            val x: Unit = if (x[x](x.x, x.x)) {
              val x: Unit = x[x](x.x, x.x)
              val x: Unit = {
                assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
                x
              }
              assume(false)
              ()
            } else {
              ()
            }
            !x[x](x) || x[x](x) == x[x](x.x)
          }
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 23
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x.x) || x[x](x.x) < x[x](x)
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 24
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, (x: x) => x(x)) || x.isInstanceOf[x] || x[x](x.x, (x: x) => x(x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 25
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 26
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  x[x](x).subsetOf(x[x](x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 27
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x), x) || x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 28
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x, (x: x) => x[x](x, x))
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 29
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 30
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] || !x[x](x[x](x, x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 31
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 32
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 33
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !(x.x == x.x && x[x](x.x, x.x)) || !x[x](x.x, x.x) || {
  val x: Unit = x[x](x.x, x.x, x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x[x](x, x[x]())), x[x](x.x, x[x](x, x[x]()))))
    x
  }
  x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 34
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x == x
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 35
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 36
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x).subsetOf(x[x](x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 37
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !!x[x](x) || !x[x](x[x](x), x) || !x[x](x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 38
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x), x) != x[x](x, x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || {
  val x: x[x] = x[x](x[x](x), x[x]())
  val x: x[x] = x[x](x)
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))
    x
  }
  x != x[x]()
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 39
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 40
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 41
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 42
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) != x[x](x) || x[x](x[x](), x) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 43
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 44
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 45
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || x[x](x.x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 46
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x) < x[x](x) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 47
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          !x[x](x, (x: x) => x[x](x, x)) || x[x](x, x.x) || x != x[x](x, x.x) || !x[x](x, (x: x) => x[x](x, x)) || x == x[x](x, x.x)
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 48
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x[x]()
      case x(x, x) if x(x) =>
        x[x](x, x[x](x, x))
      case x(_, x) =>
        x[x](x, x)
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) <= x[x](x) && x[x](x).subsetOf(x[x](x))) && x[x](x, x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] || {
  val x: Boolean = false
  !x || {
    val x: Unit = {
      assume(x)
      ()
    }
    !x[x](x[x](x, (x: x) => x[x](x, x)))
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 49
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x[x](x) != x || x != x || x == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 50
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x, x) != x[x](x.x, x) || !x[x](x.x, x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x)) < x[x](x.x))
    x
  }
  x[x](x[x](x, x)) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 51
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) <= x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 52
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || true
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 53
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) != x[x](x) || x[x](x) || {
  val x: x[x] = x[x](x, x)
  x != x[x]()
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 54
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 55
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 56
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x) || !x[x](x, x.x) || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 57
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          !x[x](x, (x: x) => x[x](x, x)) || x[x](x)
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 58
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    !x[x](x) || x[x](x, x.x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 59
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          x[x](x, (x: x) => x[x](x, x))
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 60
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
---------------------------------------------------------------------------------------------------------------------------------
VC number 61
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 62
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 63
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) >= x[x](x)
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 64
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          x[x](x, (x: x) => x[x](x, x))
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 65
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || x.x != x || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 66
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 67
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || x[x](x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 68
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  !x[x](x) || !x[x](x.x, x) || !x[x](x, x[x](x, x.x)) || x[x](x[x](x, x.x)) == x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 69
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x[x](x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 70
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 71
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || true
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 72
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 73
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 74
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 75
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x.x, x)) || !x[x](x.x, (x: x) => !x[x](x, x)) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x)))
      x
    }
    x[x](x[x](x, x))
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 76
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x) != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 77
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x[x](x, x), x)) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 78
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || x.isInstanceOf[x] || x == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 79
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) >= x[x](x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 80
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 81
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x.isInstanceOf[x] || x[x](x.x, (x: x) => !x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 82
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      val x: Unit = x[x](x, x.x)
      val x: Unit = {
        assume(x[x](x.x) <= x[x](x))
        x
      }
      x[x](x.x) > x[x](x) || x[x](x.x) + BigInt("1") != x[x](x) || !x[x](x, x.x) || x[x](x) != x[x](x) \\ Set(x.x) || {
        val x: Unit = x[x](x, x.x)
        val x: Unit = {
          assume(x[x](x[x](x, x.x)) < x[x](x))
          x
        }
        x[x](x) > x[x](x)
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 83
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 84
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || x[x](x.x, x) == x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 85
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || true
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 86
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x[x](x), x[x](x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 87
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  decreases(x[x](x))
  {
    require(!x[x](x, x))
    require(x != x)
    assert(!forall((x: Unit) => !!x[x](x[x](x, x), x)), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => !x[x](x[x](x, x), x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => !x[x](x[x](x, x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x == x || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  !x[x](x[x](x, x), x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 88
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x == x.x || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 89
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] && x.x != x || !x.isInstanceOf[x] || BigInt("-1") >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 90
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 91
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 92
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || !x.isInstanceOf[x] || x[x](x[x](x.x, x[x](x, x[x]())), x) == x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 93
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x || !x[x](x, x.x) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 94
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  !x[x](x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 95
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x) || !x[x](x, x.x) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 96
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 97
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x || !x[x](x, x.x) || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 98
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 99
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 100
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 101
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 102
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || x[x](x, (x: x) => !x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 103
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x.x)
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 104
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 105
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 106
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@opaque
@library
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = x[x](x, x, x.x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 107
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x.x) || !x[x](x, x.x) || x[x](x.x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 108
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x.x, x[x](x, x[x]())), x) || x[x](x[x](x.x, x[x](x, x[x]())), x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 109
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 110
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || true
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 111
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x == x)

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  require(x[x](x, x) == x)
  require(x[x](x, x) == x)
  require(x == x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x != x)), "Choose satisfiability")
  x[x](x, x, x, x, x)
} ensuring {
  (x: Unit) => x == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || {
    val x: Unit = x[x](x.x, x, x, x, x)
    val x: Unit = {
      assume(x == x)
      x
    }
    x == x
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 112
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, (x: x) => x(x)) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 113
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 114
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 115
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 116
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x, x) || x[x](x) != x
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 117
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 118
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x) != x || x[x](x.x, x) == x
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 119
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)) == x[x](x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x) == x)
  require(!x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x[x](x)) != x[x](x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x)) == x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x) != x || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x)) == x[x](x))
      x
    }
    !x[x](x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 120
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 121
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 122
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 123
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x) >= x[x](x, x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 124
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !(x.x == x.x && x[x](x.x, x.x)) || !x[x](x.x, x.x) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 125
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x.isInstanceOf[x] || x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 126
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x, x: x[x]): Unit = {
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x, x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x.x)
  val x: Unit = {
    assume(x[x](x.x, x[x](x.x, x.x)))
    x
  }
  x[x](x) || x != x[x]()
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 127
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 128
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 129
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(!x[x](x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(x, x), x(x, x)) =>
      val x: Boolean = x[x](x, x)
      if (x) {
        x[x](x, x)
      } else {
        val x: Boolean = !x[x](x)
        if (x) {
          x[x](x, x)
        } else {
          ()
        }
      }
    case _ =>
      ()
  }
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
x.isInstanceOf[x] || x.x != x || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: Unit = x[x](x, x)
  !x[x](x.x, x) || x[x](x, x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 130
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || !x.isInstanceOf[x] || !x[x](x) || x == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 131
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(!x[x](x, x))
  require(!x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !!x[x](x[x](x, x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => !x[x](x[x](x, x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => !x[x](x[x](x, x), x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x[x](x.x, x) || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(!x[x](x[x](x.x, x), x))
    x
  }
  !x[x](x[x](x, x), x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 132
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 133
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 134
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x.x) || x[x](x, (x: x) => !x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 135
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x) <= BigInt("0") || !x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 136
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 137
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 138
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 139
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 140
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)) == x[x](x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x) == x)
  require(!x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x[x](x)) != x[x](x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x)) == x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x) != x || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x)) == x[x](x))
      x
    }
    x[x](x, x[x](x)) == x[x](x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 141
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 142
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x.x) || x[x](x.x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 143
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x.x)))
    x
  }
  x[x](x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 144
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 145
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 146
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x) || !x.isInstanceOf[x] || x[x](x, (x: x) => !x[x](x[x](x, x), x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 147
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x).subsetOf(x[x](x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, (x: x) => x[x](x, x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x, (x: x) => x[x](x, x), x.x)
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x.x).subsetOf(x[x](x)) || {
    val x: Unit = x[x](x, x.x, x)
    val x: Unit = {
      assume(x[x](x.x, (x: x) => x[x](x, x)))
      x
    }
    x[x](x, (x: x) => x[x](x, x))
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 148
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 149
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 150
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 151
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 152
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
    x
  }
  x[x](x[x](x, x), (x: x) => x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 153
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 154
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 155
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 156
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 157
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || !x[x](x).subsetOf(x[x](x)) || x[x](x).subsetOf(x[x](x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 158
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 159
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 160
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 161
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x[x](x[x](x, x), (x: x) => !x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 162
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || x.isInstanceOf[x] || x[x](x) || x[x](x[x](x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 163
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x && x[x](x.x, x.x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 164
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x) || !x[x](x, x.x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 165
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      val x: Unit = x[x](x, x.x)
      val x: Unit = {
        assume(x[x](x.x) <= x[x](x))
        x
      }
      x[x](x.x) > x[x](x) || x[x](x.x) + BigInt("1") != x[x](x) || !x[x](x, x.x) || x[x](x) == x[x](x) \\ Set(x.x)
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 166
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) != x || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 167
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) <= x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 168
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 169
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !!x[x](x) || {
    val x: x[x] = x[x](x)
    !x[x](x, x) || !x[x](x, x) || {
      val x: Unit = x[x](x, x, x)
      val x: Unit = {
        assume(x[x](x, x))
        x
      }
      x[x](x) || x[x](x[x](x), x)
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 170
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 171
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

def x[x](x: x[x], x: x[x]): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x) == x[x](x))
  require(x[x](x) == x[x](x))
  decreases(x[x](x))
  val x: Unit = {
    val x: x[x] = x
    val x: x[x] = x
    assert((x[x](x).subsetOf(x[x](x))): @DropVCs , "Inlined precondition of lemmaSubsetContentThenForallContains")
    val x: Unit = x[x](x, x)
    assume((x[x](x, (x: x) => x[x](x, x))): @DropVCs )
    x
  }
  val x: Unit = {
    val x: x[x] = x
    val x: x[x] = x
    assert((x[x](x).subsetOf(x[x](x))): @DropVCs , "Inlined precondition of lemmaSubsetContentThenForallContains")
    val x: Unit = x[x](x, x)
    assume((x[x](x, (x: x) => x[x](x, x))): @DropVCs )
    x
  }
  assert(x[x](x, (x: x) => x[x](x, x)))
  assert(x[x](x, (x: x) => x[x](x, x)))
  x match {
    case x() =>
      ()
    case x(x, x) =>
      assert(x[x](x, x))
      val x: x[x] = x[x](x, x)
      val x: Unit = {
        val x: x[x] = x
        val x: x = x
        assert(({
          val x: x[x] = x
          (x[x](x)): @DropVCs 
        }): @DropVCs , "Inlined precondition of lemmaRemoveOneElmtPreservesNoDuplicate")
        val x: Unit = x[x](x, x)
        assume(({
          val x: x[x] = x[x](x, x)
          (x[x](x)): @DropVCs 
        }): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x = x
        assert(({
          val x: x[x] = x
          (x[x](x)): @DropVCs 
        }): @DropVCs , "Inlined precondition (1/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))): @DropVCs )
        x
      }
      assert(x[x](x) >= x[x](x))
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        val x: x = x
        assert((x[x](x, (x: x) => x[x](x, x))): @DropVCs , "Inlined precondition of lemmaForallContainsPreservedRemoveElmt")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x[x](x, x), (x: x) => x[x](x, x))): @DropVCs )
        x
      }
      assert(x[x](x, (x: x) => x[x](x, x)))
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, (x: x) => x[x](x, x))): @DropVCs , "Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList")
        assert((x[x](x)): @DropVCs , "Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) <= x[x](x))): @DropVCs )
        x
      }
      assert(x[x](x) >= x[x](x))
      assert(!x[x](x, x))
      assert({
        val x: x[x] = x
        (x[x](x)): @DropVCs 
      })
      assert(x[x](x, (x: x) => x[x](x, x)))
      val x: x[x] = x[x](x, x)
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        val x: x[x] = x
        val x: x = x
        assert((x[x](x, (x: x) => x[x](x, x))): @DropVCs , "Inlined precondition (1/3) of lemmaForallContainsPreservedRemoveElmtInRefList")
        assert((!x[x](x, x)): @DropVCs , "Inlined precondition (2/3) of lemmaForallContainsPreservedRemoveElmtInRefList")
        assert(((x == x[x](x, x))): @DropVCs , "Inlined precondition (3/3) of lemmaForallContainsPreservedRemoveElmtInRefList")
        val x: Unit = x[x](x, x, x, x)
        assume((x[x](x, (x: x) => x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: Boolean = x[x](x, (x: x) => x[x](x, x))
        assert((x): @ghost  @DropVCs , "Inlined precondition of check")
        val x: Unit = (()): @DropVCs 
        assume((x): @ghost  @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, (x: x) => x[x](x, x))): @DropVCs , "Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList")
        assert((x[x](x)): @DropVCs , "Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) <= x[x](x))): @DropVCs )
        x
      }
      assert(x[x](x[x](x, x)) >= x[x](x))
      val x: Boolean = x[x](x, x)
      val x: Unit = if (x) {
        val x: Unit = {
          val x: x[x] = x
          val x: x = x
          assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemoveElmtContainedSizeSmaller")
          val x: Unit = x[x](x, x)
          assume(((x[x](x[x](x, x)) < x[x](x))): @DropVCs )
          x
        }
        assert(x[x](x[x](x, x)) < x[x](x))
        assert(x[x](x[x](x, x)) < x[x](x))
        assert(x[x](x[x](x, x)) < x[x](x))
        val x: Boolean = false
        assert((x): @ghost  @DropVCs , "Inlined precondition of check")
        val x: Unit = (()): @DropVCs 
        assume((x): @ghost  @DropVCs )
        x
      } else {
        ()
      }
      val x: Unit = x
      val x: Unit = x
      x[x](x, x)
  }
} ensuring {
  (x: Unit) => {
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || {
            val x: Unit = if (x[x](x.x, x.x)) {
              val x: Unit = x[x](x.x, x.x)
              val x: Unit = {
                assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
                x
              }
              assume(false)
              ()
            } else {
              ()
            }
            val x: Unit = x[x](x, x.x)
            x[x](x)
          }
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 172
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x[x](x.x, x) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 173
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !!x[x](x) || x[x](x[x](x), x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 174
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 175
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x.x)))
    x
  }
  x[x](x) >= x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 176
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}
!x[x](x) || !x[x](x, x) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 177
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 178
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x[x](x)) >= x[x](x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 179
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x, (x: x) => x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 180
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x.x, x.x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 181
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 182
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || x[x](x.x, x) != x[x](x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 183
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x == x || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 184
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || !x[x](x[x](x), x) || x[x](x[x](x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 185
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 186
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 187
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 188
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 189
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 190
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 191
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x[x](x), x) || x[x](x.x, x) == x
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 192
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x != x || {
  val x: BigInt = x[x](x)
  x[x](x)
} >= BigInt("0") && {
  val x: BigInt = x[x](x)
  x[x](x)
} >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 193
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
x.isInstanceOf[x] || x[x](x) >= x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 194
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x.isInstanceOf[x] || x[x](x) || x[x](x[x](x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 195
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || x[x](x[x](x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 196
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x[x](x, x), x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, (x: x) => x[x](x[x](x, x), x))
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x[x](x, x), x)))
!x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(x[x](x.x, (x: x) => x[x](x[x](x, x), x)))
    x
  }
  x[x](x, (x: x) => x[x](x[x](x, x), x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 197
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => !x[x](x, x)) || x == x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 198
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x[x](x, x)) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 199
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || x[x](x) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 200
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !!x[x](x[x](x, (x: x) => x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => !x[x](x[x](x, (x: x) => x[x](x, x)))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x[x]()
      case x(x, x) if x(x) =>
        x[x](x, x[x](x, x))
      case x(_, x) =>
        x[x](x, x)
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) <= x[x](x) && x[x](x).subsetOf(x[x](x))) && x[x](x, x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => !x[x](x[x](x, (x: x) => x[x](x, x))))
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !(x.x != x) || !x[x](x.x, x) || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(!x[x](x[x](x.x, (x: x) => x[x](x, x))))
    x
  }
  !x[x](x[x](x, (x: x) => x[x](x, x)))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 201
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x.x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 202
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || x[x](x[x](x, x.x)) == x[x](x) \\ Set(x.x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 203
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x, x)))
      x
    }
    x[x](x, x[x](x, x))
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 204
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x == x || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 205
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 206
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x.isInstanceOf[x] || x[x](x, x) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 207
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  {
    val x: x[x] = x[x](x, x[x](x.x, x[x]()))
    x[x](x.x)
  } < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 208
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || x.isInstanceOf[x] || x[x](x.x, (x: x) => !x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 209
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x) == x)
  require(!x[x](x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || {
      val x: Unit = x[x](x.x, x, x, x)
      val x: Unit = {
        assume(x[x](x, x[x](x)))
        x
      }
      x[x](x, x[x](x))
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 210
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) + x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 211
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x) <= x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 212
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x) || x.isInstanceOf[x] || x[x](x.x, (x: x) => !x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 213
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} >= BigInt("0") && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} >= BigInt("0") && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 214
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x || !x[x](x, x.x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 215
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x[x](x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 216
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x.x, x[x](x.x, x)))
    x
  }
  x[x](x, x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 217
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x)

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(!x[x](x, x))
    assert(!forall((x: Unit) => (x[x](x, x) != x)), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, x) == x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}
x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x, x) == x
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 218
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  x[x](x, (x: x) => !x[x](x[x](), x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 219
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x[x](x, x)) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 220
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x.x) || !x[x](x, x.x) || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 221
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x.x, x)) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x.x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 222
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x, x) && x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 223
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x, x.x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 224
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || !x[x](x.x, x.x) || {
            val x: Unit = x[x](x.x, x.x)
            val x: Unit = {
              assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
              x
            }
            x[x](x[x](x.x, x.x)) >= x[x](x.x) || x[x](x[x](x, x.x)) >= x[x](x.x) || x[x](x[x](x, x.x)) < x[x](x)
          }
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 225
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 226
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x) == x)

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x, x: x[x], x: x[x]): Unit = {
  require(x[x](x, x[x](x, x)) == x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x[x](x, x[x]())), x) != x)), "Choose satisfiability")
  x[x](x, x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x[x](x, x)) != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x[x](x, x)) != x || {
    val x: Unit = x[x](x.x, x, x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x, x[x]())), x) == x)
      x
    }
    x[x](x[x](x, x[x](x, x[x]())), x) == x
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 227
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || x[x](x, (x: x) => x[x](x, x))
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 228
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || x[x](x[x](x), x[x](x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 229
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 230
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || x[x](x.x, x) && x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 231
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x).subsetOf(x[x](x)) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 232
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 233
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 234
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 235
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x[x](x, x)) != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x[x](x, x)) != x || x[x](x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 236
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || !x[x](x[x](x), x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 237
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x) == x || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 238
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      val x: Unit = x[x](x, x.x)
      val x: Unit = {
        assume(x[x](x.x) <= x[x](x))
        x
      }
      x[x](x.x) > x[x](x) || x[x](x.x) + BigInt("1") != x[x](x) || x[x](x, x.x)
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 239
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: (x) => Boolean): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@opaque
@library
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: (x) => Boolean): Unit = choose((x: Unit) => x[x](x, x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = x[x](x, x, x.x)
  !x[x](x.x, x) || !x[x](x, x) || {
    val x: Unit = x[x](x, x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x))
      x
    }
    x[x](x, x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 240
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 241
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x.x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 242
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || x.isInstanceOf[x]
---------------------------------------------------------------------------------------------------------------------------------
VC number 243
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || x.isInstanceOf[x] || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 244
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 245
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x, x) || x == x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 246
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@opaque
@library
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = x[x](x, x, x.x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 247
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || x[x](x, (x: x) => x[x](x[x](x, x), x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 248
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x) || !x[x](x, x.x) || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 249
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x) >= x[x](x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 250
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      x[x](x.x, (x: x) => x[x](x, x))
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 251
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, x) || !x.isInstanceOf[x] || !x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 252
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !(x.x == x.x && x[x](x.x, x.x)) || x[x](x.x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 253
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 254
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 255
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 256
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x) || !x[x](x.x, x.x) || x[x](x.x) + x[x](x.x) < x[x](x) + x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 257
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 258
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x.x) || !x[x](x, (x: x) => !x[x](x, x)) || x == x[x](x, x.x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 259
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      val x: Unit = x[x](x, x.x)
      val x: Unit = {
        assume(x[x](x.x) <= x[x](x))
        x
      }
      x[x](x.x) <= x[x](x)
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 260
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || x.isInstanceOf[x] || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 261
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x.isInstanceOf[x] || x[x](x, x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 262
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || x[x](x[x](x, x), (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 263
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x.isInstanceOf[x] || x[x](x, x[x](x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 264
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 265
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 266
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) != x
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 267
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 268
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x)) < x[x](x.x))
    x
  }
  x[x](x[x](x, x)) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 269
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 270
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 271
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x[x](x[x](x), x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 272
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 273
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      val x: Unit = x[x](x, x.x)
      val x: Unit = {
        assume(x[x](x.x) <= x[x](x))
        x
      }
      x[x](x.x) > x[x](x) || x[x](x.x) + BigInt("1") != x[x](x) || !x[x](x, x.x) || x[x](x) != x[x](x) \\ Set(x.x) || x[x](x, x.x)
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 274
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 275
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 276
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || BigInt("1") + x[x](x.x, x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 277
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x) == x)
  require(!x[x](x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || {
      val x: Unit = x[x](x.x, x, x, x)
      val x: Unit = {
        assume(x[x](x, x[x](x)))
        x
      }
      x != x[x]()
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 278
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x, x) != x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 279
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x.isInstanceOf[x] || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 280
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || x[x](x, x.x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 281
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x) || !x.isInstanceOf[x] || x[x](x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 282
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x, x[x](x, x)) != x || !x.isInstanceOf[x] || x[x](x.x, x[x](x, x)) == x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 283
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 284
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) != x[x](x) || x[x](x) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 285
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 286
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 287
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x, x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 288
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  x[x](x.x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 289
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 290
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x, x) != x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 291
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 292
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(!x[x](x))
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x)))
      x
    }
    x[x](x, x[x](x))
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 293
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) < x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 294
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x, x) || x[x](x) == x || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 295
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x.isInstanceOf[x] || !x.x.isInstanceOf[x] || x[x](x[x](x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 296
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 297
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || x[x](x.x, x[x](x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 298
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 299
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x[x](x, x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x, (x: x) => !x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 300
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || x[x](x, (x: x) => x[x](x, x))
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 301
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 302
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x[x](x, x)) != x || !x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 303
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 304
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 305
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x) >= x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 306
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 307
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 308
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || !x[x](x) || x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 309
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
x.isInstanceOf[x] || x[x](x) < x[x](x) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 310
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x) != x || x[x](x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 311
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x) || !x[x](x, x.x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 312
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !!x[x](x) || !x[x](x[x](x), x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 313
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x[x](x.x, x[x](x, x[x]())), x) != x || x[x](x[x](x.x, x[x](x, x[x]())), x) == x
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 314
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 315
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x.x, (x: x) => !x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 316
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 317
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@opaque
@library
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = x[x](x, x, x.x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 318
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 319
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 320
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x.x == x
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 321
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 322
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x == x[x](x[x](x.x, x[x]()), x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 323
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x.x, x) == x
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 324
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || x.isInstanceOf[x] && !x[x](x, x.x) || !x.isInstanceOf[x] || x[x](x) && x[x](x[x](x, x)) == x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 325
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 326
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 327
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !!x[x](x) || {
    val x: x[x] = x[x](x)
    !x[x](x, x) || !x[x](x, x) || {
      val x: Unit = x[x](x, x, x)
      val x: Unit = {
        assume(x[x](x, x))
        x
      }
      x[x](x) || x != x[x]()
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 328
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || x[x](x[x](x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 329
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] && x.x != x || x.isInstanceOf[x]
---------------------------------------------------------------------------------------------------------------------------------
VC number 330
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 331
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  require(!x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x), x))
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x.x) || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x), x.x))
    x
  }
  x[x](x[x](x), x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 332
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 333
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x.x) || !x[x](x, (x: x) => !x[x](x, x)) || true
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 334
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  true
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 335
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  x[x](x.x, x) && x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 336
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x]
---------------------------------------------------------------------------------------------------------------------------------
VC number 337
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 338
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 339
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) == x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 340
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) == x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 341
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          x[x](x, (x: x) => x[x](x, x))
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 342
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 343
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  !x[x](x) || !x[x](x.x, x) || x[x](x, x[x](x, x.x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 344
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 345
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || x != x[x]()
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 346
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x[x](x), x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 347
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 348
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] && x.x != x || x.isInstanceOf[x]
---------------------------------------------------------------------------------------------------------------------------------
VC number 349
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !!x[x](x) || x != x[x]()
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 350
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
true
---------------------------------------------------------------------------------------------------------------------------------
VC number 351
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x[x]()
      case x(x, x) if x(x) =>
        x[x](x, x[x](x, x))
      case x(_, x) =>
        x[x](x, x)
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) <= x[x](x) && x[x](x).subsetOf(x[x](x))) && x[x](x, x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || x.x != x || !x[x](x[x](x, (x: x) => x[x](x, x)))
---------------------------------------------------------------------------------------------------------------------------------
VC number 352
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  x[x](x[x](x, x[x](x.x, x[x]())))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 353
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x) == x || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 354
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x[x](x, (x: x) => !x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => !x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => !x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  x[x](x[x](x, x), (x: x) => !x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 355
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x) || !x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 356
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x, x) != x[x](x.x, x) || x[x](x.x, x) || x[x](x[x](x, x)) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 357
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x[x](x.x, x[x](x.x)), x[x](x[x](x), x[x]())) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 358
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x != x[x](x, x[x]()) || !x.isInstanceOf[x] || x[x](x.x, x) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 359
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x) == x[x](x))
  require(x[x](x) == x[x](x))
  require(x[x](x) <= BigInt("1"))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x != x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x == x)

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x.x == x)
      x
    }
    x == x
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 360
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x, x: x[x]): Unit = {
  require(x[x](x[x](x, x[x](x, x[x]())), x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x.x, x[x](x, x[x]())), x) || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x))
      x
    }
    x[x](x, x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 361
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x, x)
  x[x](x, (x: x) => !x[x](x[x](x, x), x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 362
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 363
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 364
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 365
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 366
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] || {
  val x: Boolean = false
  !x || {
    val x: Unit = {
      assume(x)
      ()
    }
    x[x](x[x](x, x)) < x[x](x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 367
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x.x, x.x)
  val x: Unit = {
    assume(x[x](x, x.x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 368
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 369
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 370
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) >= x[x](x) || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x.x))
    x
  }
  x[x](x) || x[x](x[x](x), x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 371
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 372
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, (x: x) => x(x)) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 373
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x.x) || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x.x, x.x)
  val x: Unit = {
    assume(x[x](x, x.x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 374
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x, x: x[x]): Unit = {
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x, x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x.x)
  val x: Unit = {
    assume(x[x](x.x, x[x](x.x, x.x)))
    x
  }
  x[x](x) || x[x](x[x](x), x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 375
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x.x, x)) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x.x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 376
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 377
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    !x[x](x) || x[x](x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 378
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 379
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x.x != x || BigInt("0") >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 380
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !!x[x](x) || {
    val x: x[x] = x[x](x)
    !x[x](x, x) || !x[x](x, x) || x[x](x, x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 381
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || x.isInstanceOf[x] || x[x](x[x](), x) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 382
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x) || !x[x](x, x.x) || x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 383
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || x.isInstanceOf[x] || x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 384
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => !x[x](x, x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x[x](x, x))
    assert(!forall((x: Unit) => !!x[x](x, x)), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => !x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  !x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 385
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: x[x]) => !(x[x](x) && x[x](x[x](x, x)) == x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: x[x]) => x[x](x) && x[x](x[x](x, x)) == x[x](x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): x[x] = choose((x: x[x]) => x[x](x) && x[x](x[x](x, x)) == x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: x[x] = x[x](x, x.x)
  val x: x[x] = {
    assume(x[x](x) && x[x](x[x](x, x.x)) == x[x](x))
    x
  }
  x[x](x) && x[x](x[x](x, x)) == x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 386
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x != x[x](x, x[x]()) || !x.isInstanceOf[x] || x[x](x.x, x) || x == x[x](x, x[x]())
---------------------------------------------------------------------------------------------------------------------------------
VC number 387
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x.x) <= x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 388
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x.x) < x[x](x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 389
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): x[x] = choose((x: x[x]) => x[x](x) && x[x](x[x](x, x)) == x[x](x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: x[x]) => !(x[x](x) && x[x](x[x](x, x)) == x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: x[x]) => x[x](x) && x[x](x[x](x, x)) == x[x](x)
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || x[x](x, x.x) || {
  val x: x[x] = x[x](x.x, x)
  !x[x](x) || {
    val x: x[x] = x[x](x, x.x)
    val x: x[x] = {
      assume(x[x](x) && x[x](x[x](x, x.x)) == x[x](x))
      x
    }
    x[x](x) && x[x](x[x](x, x)) == x[x](x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 390
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || x[x](x.x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 391
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 392
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 393
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x[x](x[x](x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 394
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 395
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 396
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 397
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x[x](x), x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 398
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 399
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      val x: Unit = x[x](x, x.x)
      val x: Unit = {
        assume(x[x](x.x) <= x[x](x))
        x
      }
      x[x](x.x) > x[x](x) || x[x](x.x) + BigInt("1") != x[x](x) || !x[x](x, x.x) || x[x](x) != x[x](x) \\ Set(x.x) || {
        val x: Unit = x[x](x, x.x)
        val x: Unit = {
          assume(x[x](x[x](x, x.x)) < x[x](x))
          x
        }
        x[x](x) <= x[x](x) || x[x](x) <= x[x](x)
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 400
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x.x)))
    x
  }
  x[x](x) < x[x](x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 401
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          !x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x)
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 402
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x == x || !x.isInstanceOf[x] || !x[x](x[x](x, x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 403
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          !x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || x[x](x, (x: x) => x[x](x, x))
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 404
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          !x[x](x, (x: x) => x[x](x, x)) || x[x](x, x.x) || x != x[x](x, x.x) || x[x](x, (x: x) => x[x](x, x))
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 405
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x == x || x.isInstanceOf[x] || !x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 406
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x.isInstanceOf[x] || x[x](x, x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 407
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x[x](x, x)) || x.isInstanceOf[x] || x[x](x[x](x.x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 408
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 409
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 410
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 411
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || x[x](x, (x: x) => x[x](x, x)) && x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 412
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x, x[x](x[x](x), x.x)) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 413
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 414
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 415
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 416
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x]
---------------------------------------------------------------------------------------------------------------------------------
VC number 417
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 418
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x == x.x || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 419
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 420
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) + x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 421
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || !x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !(x[x](x) || !x[x](x[x](x), x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x) || !x[x](x[x](x), x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x) || !x[x](x[x](x), x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 422
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x) || !x[x](x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 423
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) >= x[x](x) || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x.x)
  val x: Unit = {
    assume(x[x](x, x.x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 424
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(!x[x](x, x))
  require(x == x[x](x, x[x]()))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, (x: x) => x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, (x: x) => x[x](x, x)))
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x[x]()
      case x(x, x) if x(x) =>
        x[x](x, x[x](x, x))
      case x(_, x) =>
        x[x](x, x)
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) <= x[x](x) && x[x](x).subsetOf(x[x](x))) && x[x](x, x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, (x: x) => x[x](x, x))))
x[x](x, x) || x != x[x](x, x[x]()) || !x.isInstanceOf[x] || x[x](x.x, x) || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x.x, (x: x) => x[x](x, x))))
    x
  }
  x[x](x[x](x, (x: x) => x[x](x, x)))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 425
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x.x) || x[x](x.x, (x: x) => x[x](x, x))
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 426
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || !x[x](x.x, (x: x) => x[x](x, x)) || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 427
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  require(x[x](x) <= x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || {
    val x: Unit = x[x](x, x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x))
      x
    }
    x[x](x, x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 428
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  !x[x](x[x](x, x[x](x.x, x[x]()))) || x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 429
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x[x](x, x)) != x || x.isInstanceOf[x] || x[x](x[x](x, x[x](x, x[x]())), x) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 430
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 431
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 432
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    !x[x](x[x](x), x) || x[x](x.x, x) == x
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 433
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) != x[x](x) || x[x](x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 434
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x.x) || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 435
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x.x, x) || x[x](x.x) > x[x](x) || x[x](x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 436
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) || !x.isInstanceOf[x] || x[x](x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 437
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 438
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 439
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 440
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  !x[x](x[x](x), x) || x != x[x]()
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 441
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !x[x](x) || x[x](x) || x != x[x]()
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 442
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 443
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x, x)
  x[x](x, (x: x) => x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 444
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    !x[x](x) || !x[x](x, x.x) || x[x](x, x.x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 445
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 446
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 447
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || {
            val x: Unit = if (x[x](x.x, x.x)) {
              val x: Unit = x[x](x.x, x.x)
              val x: Unit = {
                assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
                x
              }
              assume(false)
              ()
            } else {
              ()
            }
            x[x](x.x) < x[x](x)
          }
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 448
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x[x](x) != x || x == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 449
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] || x[x](x, x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 450
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 451
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    x[x](x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 452
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x && x[x](x.x, x.x) || !x[x](x, x.x) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 453
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || x[x](x, x.x) || !x[x](x[x](x.x, x)) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 454
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x, x) || x[x](x) >= x[x](x) || x.isInstanceOf[x] || x[x](x, x) != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 455
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 456
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || x.isInstanceOf[x] || x[x](x, x[x](x[x](x, x[x]()), x)) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 457
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x[x](x.x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 458
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 459
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || {
    val x: x[x] = x[x](x, x)
    x != x[x]()
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 460
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 461
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x, x) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 462
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 463
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x == x || !x[x](x.x) || !x[x](x.x, x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x.x) || x[x](x[x](x.x, x)) == x[x](x.x) - BigInt("1"))
    x
  }
  x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 464
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x[x](x)) != x || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 465
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 466
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x[x](x, x), x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 467
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || !x[x](x, x.x)
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 468
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x.x, x)) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 469
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x != x[x](x, x[x]()) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 470
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) == x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 471
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x.x, x[x](x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 472
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || x.isInstanceOf[x] || x[x](x) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 473
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x, x) || x[x](x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 474
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 475
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 476
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) != x[x](x) || x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 477
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
---------------------------------------------------------------------------------------------------------------------------------
VC number 478
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x) || !x[x](x.x, (x: x) => !x[x](x, x)) || {
  val x: Unit = x[x](x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x)))
    x
  }
  x[x](x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 479
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || x[x](x, (x: x) => !x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 480
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 481
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || x.isInstanceOf[x] || x[x](x, x[x](x)) == x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 482
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || x[x](x[x](x.x, x[x](x.x, x)), x) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 483
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  !x[x](x) || x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 484
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 485
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 486
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || x[x](x.x).subsetOf(x[x](x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 487
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x) || x[x](x.x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 488
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 489
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 490
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) < x[x](x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 491
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 492
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x.x, x) || !x[x](x.x, x) || x[x](x.x, x) >= x[x](x.x, x) || x[x](x.x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 493
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 494
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 495
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x) || !x[x](x.x, x.x) || x[x](x.x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 496
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 497
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 498
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
x.isInstanceOf[x] || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 499
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || x[x](x[x](x, x), (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 500
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          !x[x](x, (x: x) => x[x](x, x)) || x[x](x, x.x) || x == x[x](x, x.x)
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 501
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || true
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 502
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 503
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x) != x
---------------------------------------------------------------------------------------------------------------------------------
VC number 504
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 505
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 506
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 507
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@opaque
def x[x](x: x[x]): Unit = {
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}
!x[x](x, x) || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  !x[x](x) || x[x](x) || x[x](x[x](x), x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 508
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || x[x](x, (x: x) => !x[x](x.x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 509
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 510
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 511
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 512
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x.x) || x[x](x.x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 513
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x[x](x, x), x)) || x.isInstanceOf[x] || x[x](x.x, (x: x) => !x[x](x[x](x, x), x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 514
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x) == x || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 515
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x.isInstanceOf[x] || x[x](x.x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 516
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x.isInstanceOf[x] || x[x](x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 517
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, (x: x) => x(x)) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 518
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || x[x](x, x.x) || x[x](x[x](x.x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 519
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || x[x](x, (x: x) => x[x](x, x))
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 520
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 521
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 522
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x) != x || x[x](x, x) >= x[x](x, x) || x[x](x[x](x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 523
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x, (x: x) => x[x](x, x), x.x)
  !x[x](x, (x: x) => x[x](x, x)) || x[x](x.x).subsetOf(x[x](x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 524
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x.x) || {
  val x: Unit = x[x](x.x, x.x, x.x)
  val x: Unit = {
    assume(x[x](x.x, x.x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 525
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || {
            val x: Unit = if (x[x](x.x, x.x)) {
              val x: Unit = x[x](x.x, x.x)
              val x: Unit = {
                assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
                x
              }
              assume(false)
              ()
            } else {
              ()
            }
            x[x](x)
          }
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 526
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || x[x](x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 527
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x[x](x)) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 528
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x) || x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 529
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    !x[x](x) || !x[x](x, x.x) || x[x](x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 530
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || x[x](x, x.x) || {
  val x: x[x] = x[x](x.x, x)
  !x[x](x) || x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 531
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
!x.isInstanceOf[x] || x[x](x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 532
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || !x[x](x) || !x[x](x) || x[x](x) || x[x](x[x](x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 533
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x[x](x, x), x)) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 534
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x[x](x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 535
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x.isInstanceOf[x] || x != x[x]()
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 536
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) + x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 537
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 538
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x.x != x || {
    val x: BigInt = x[x](x)
    x[x](x.x)
  } < {
    val x: BigInt = x[x](x)
    x[x](x)
  } || {
    val x: BigInt = x[x](x)
    x[x](x.x)
  } == {
    val x: BigInt = x[x](x)
    x[x](x)
  } && {
    val x: BigInt = x[x](x.x)
    x[x](x)
  } < {
    val x: BigInt = x[x](x)
    x[x](x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 539
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 540
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 541
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) <= BigInt("1")
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 542
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, x) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 543
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || x[x](x) < x[x](x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 544
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || x[x](x, x) && x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 545
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  x[x](x, (x: x) => !x[x](x[x](), x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 546
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) == x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 547
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => !x[x](x, x)) || !x[x](x.x) || x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 548
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x.x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 549
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
    x
  }
  !x[x](x, x) || x[x](x) == x || true
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 550
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 551
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
val x: Unit = x[x](x, x)
val x: Unit = {
  assume(x[x](x, x))
  x
}
!x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 552
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 553
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || x[x](x.x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 554
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 555
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} || {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x.x)
  x[x](x)
} == {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
} && {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x.x)
} < {
  val x: BigInt = x[x](x)
  val x: BigInt = x[x](x)
  x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 556
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x, (x: x) => x[x](x, x), x.x)
  x[x](x, (x: x) => x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 557
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x.isInstanceOf[x] || !x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 558
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x).subsetOf(x[x](x)) || x[x](x).subsetOf(x[x](x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 559
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x.x != x
---------------------------------------------------------------------------------------------------------------------------------
VC number 560
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x, (x: x) => x[x](x, x), x.x)
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x.x).subsetOf(x[x](x)) || x[x](x.x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 561
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x) || !x[x](x.x, x.x) || {
  val x: Unit = x[x](x.x, x.x)
  val x: Unit = {
    assume(x[x](x.x, x.x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 562
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x != x[x](x, x[x]()) || !x.isInstanceOf[x] || !x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 563
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x) != x
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 564
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 565
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 566
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || !x[x](x[x](x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 567
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || {
            val x: Unit = if (x[x](x.x, x.x)) {
              val x: Unit = x[x](x.x, x.x)
              val x: Unit = {
                assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
                x
              }
              assume(false)
              ()
            } else {
              ()
            }
            !x[x](x) || x[x](x) != x[x](x.x) || x[x](x) == x[x](x.x)
          }
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 568
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) >= x[x](x) || !x[x](x, x.x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 569
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 570
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 571
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 572
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 573
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x.x, x[x](x.x, x)))
    x
  }
  x[x](x, x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 574
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 575
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 576
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x) || !x.isInstanceOf[x] || x[x](x, (x: x) => !x[x](x[x](x, x), x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 577
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 578
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x[x]()
      case x(x, x) if x(x) =>
        x[x](x, x[x](x, x))
      case x(_, x) =>
        x[x](x, x)
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) <= x[x](x) && x[x](x).subsetOf(x[x](x))) && x[x](x, x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x, x) || x != x[x](x, x[x]()) || x.isInstanceOf[x] || x[x](x[x](x, (x: x) => x[x](x, x)))
---------------------------------------------------------------------------------------------------------------------------------
VC number 579
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 580
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || !x.isInstanceOf[x] || x.x != x
---------------------------------------------------------------------------------------------------------------------------------
VC number 581
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@opaque
@library
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = x[x](x, x, x.x)
  x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 582
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 583
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || x.isInstanceOf[x] || x[x](x.x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 584
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x != x || x.isInstanceOf[x] || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 585
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  !x[x](x[x](x), x) || x[x](x[x](x), x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 586
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 587
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x, (x: x) => !x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 588
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

def x[x](x: x[x], x: x[x], x: x[x]): x[x] = {
  require(x[x](x))
  require(x[x](x, x))
  require(x[x](x, x[x](x, x)))
  require(x[x](x[x](x, x)) == x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      x[x](x, x, x)
    case x(x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaSubSeqAddSameElmtPreserves")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: Unit = x[x](x)
        assume((x[x](x, (x: x) => !x[x](x[x](), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x]()
        val x: x = x
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (1/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        assert((!x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, (x: x) => !x[x](x[x](x, x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x[x]())
        assert((x[x](x)): @DropVCs , "Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x)): @DropVCs , "Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis")
        val x: Unit = x[x](x, x)
        assume((x[x](x[x](x, x))): @DropVCs )
        x
      }
      x[x](x, x, x[x](x, x[x](x, x[x]())))
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => ((x[x](x) && x[x](x, x)) && x[x](x) == x[x](x[x](x, x))) && x[x](x) == x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x.x, x[x](x, x[x](x.x, x[x]())))
  x[x](x) && x[x](x, x) && x[x](x) == x[x](x[x](x, x)) && x[x](x) == x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 589
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x == x || !x[x](x.x) || !x[x](x.x, x) || x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 590
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x[x](x.x, x[x]()))
  !x[x](x) || !x[x](x.x, x) || x[x](x, x[x](x, x.x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 591
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x == x)
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}
x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x.x != x || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x.x, x))
      x
    }
    x[x](x, x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 592
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || x.isInstanceOf[x] || x[x](x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 593
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x == x || x[x](x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 594
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 595
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 596
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x[x](x))) + x[x](x[x](x))
} < {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x)) + x[x](x)
} || {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x[x](x))) + x[x](x[x](x))
} == {
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x)) + x[x](x)
} && {
  val x: BigInt = (BigInt("0") + x[x](x[x](x))) + x[x](x[x](x))
  BigInt("0")
} < {
  val x: BigInt = (BigInt("0") + x[x](x)) + x[x](x)
  BigInt("0")
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 597
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 598
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || x[x](x.x).subsetOf(x[x](x))
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 599
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) == x[x](x) || !false || x[x](x) >= x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 600
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || !x[x](x[x](x), x[x](x)) || x[x](x) >= x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 601
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 602
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 603
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 604
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 605
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          !x[x](x, (x: x) => x[x](x, x)) || x[x](x, x.x) || x != x[x](x, x.x) || !x[x](x, (x: x) => x[x](x, x)) || true
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 606
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x.x, x)) || x[x](x.x, (x: x) => !x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 607
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x[x](x), x) || x[x](x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 608
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) == x.x
---------------------------------------------------------------------------------------------------------------------------------
VC number 609
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x != x || x[x](x.x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 610
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x == x.x || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 611
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x == x || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 612
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x, (x: x) => x[x](x, x), x.x)
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x.x).subsetOf(x[x](x)) || x[x](x, (x: x) => x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 613
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    val x: x[x] = x[x](x)
    !x[x](x, x) || x[x](x.x, x) != x || x[x](x.x) >= x[x](x) || true
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 614
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 615
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 616
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  x[x](x, (x: x) => !x[x](x[x](x, x.x), x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 617
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x, (x: x) => x[x](x, x), x.x)
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x.x).subsetOf(x[x](x)) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x.x).subsetOf(x[x](x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 618
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 619
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || x[x](x)
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 620
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || x[x](x.x) == x[x](x[x](x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 621
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 622
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 623
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x[x](x, x)) != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x[x](x, x)) != x || x[x](x.x, x[x](x, x)) == x
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 624
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 625
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x[x](x, x), (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 626
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x.x)
  val x: Unit = {
    assume(x[x](x, x.x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 627
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x) <= x[x](x))
      x
    }
    x[x](x) <= x[x](x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 628
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || !x[x](x.x, x.x) || x[x](x.x, x.x)
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 629
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || x.isInstanceOf[x] || !x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 630
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x, x.x)
  x[x](x, x) && x[x](x, x.x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 631
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x.x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 632
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x, x) != x[x]()
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 633
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x.x, x)) || !x[x](x.x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x.x, x)) || x[x](x.x, (x: x) => !x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 634
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](x) != x[x](x) || {
  val x: Boolean = x[x](x[x](x), x[x](x))
  true
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 635
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x != x[x](x, x[x]()) || !x.isInstanceOf[x] || x[x](x.x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 636
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 637
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  !x[x](x, (x: x) => !x[x](x[x](), x)) || !x[x](x, x.x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 638
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  require(x[x](x, x) == x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x != x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x == x)

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || {
    val x: Unit = x[x](x, x, x)
    val x: Unit = {
      assume(x == x)
      x
    }
    x == x
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 639
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) >= x[x](x)
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 640
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x, x) || x[x](x, x) == x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 641
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x.x) || !x[x](x, x.x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 642
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x.isInstanceOf[x] || x[x](x) >= x[x](x) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 643
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 644
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
---------------------------------------------------------------------------------------------------------------------------------
VC number 645
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------


x.isInstanceOf[x] || x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 646
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 647
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
@library
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x(x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x(x)
}

@opaque
@library
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: x): Unit = choose((x: Unit) => x(x))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = x[x](x, x, x.x)
  !x[x](x.x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 648
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || !x[x](x) || !x[x](x) || x[x](x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 649
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x == x || x[x](x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 650
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 651
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x, x) == x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 652
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x && x[x](x.x, x.x) || !x[x](x, x.x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 653
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) >= x[x](x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 654
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || x.isInstanceOf[x] || x == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 655
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      x[x](x, (x: x) => x[x](x, x))
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 656
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x == x.x || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 657
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 658
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x)) == x[x](x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x) == x)
  require(!x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x[x](x)) != x[x](x))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x)) == x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x.x, x) != x || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x)) == x[x](x))
      x
    }
    true
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 659
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  x != x[x]()
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 660
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || x[x](x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 661
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || !x.isInstanceOf[x] || x[x](x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 662
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 663
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x, x) == x
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 664
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 665
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: (x) => Boolean, x: (x) => Boolean): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x(x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x(x) || x(x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x(x) || x(x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: (x) => Boolean): Unit = choose((x: Unit) => x[x](x, (x: x) => x(x) || x(x)))
!x[x](x, (x: x) => x(x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  x[x](x, (x: x) => x(x) || x(x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 666
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, (x: x) => x(x)) || !x.isInstanceOf[x] || x[x](x, (x: x) => x(x) || x(x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 667
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 668
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

def x[x](x: x[x], x: x[x], x: x[x]): x[x] = {
  require(x[x](x))
  require(x[x](x, x))
  require(x[x](x, x[x](x, x)))
  require(x[x](x[x](x, x)) == x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      x[x](x, x, x)
    case x(x, x) =>
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaIsSuffixThenTailIsSuffix")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger")
        val x: Unit = x[x](x, x)
        assume(((x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x, x[x]())
        val x: Unit = x[x](x, x)
        assume((x[x](x, x[x](x, x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x[x] = x[x](x[x](x, x), x[x](x, x[x]()))
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (1/2) of lemmaSubSeqTransitive")
        assert((x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaSubSeqTransitive")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, x)): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x)
        val x: x = x
        assert((x[x](x, x)): @DropVCs , "Inlined precondition of lemmaSubSeqAddSameElmtPreserves")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: Unit = x[x](x)
        assume((x[x](x, (x: x) => !x[x](x[x](), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x]()
        val x: x = x
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (1/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        assert((!x[x](x, x)): @DropVCs , "Inlined precondition (2/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList")
        val x: Unit = x[x](x, x, x)
        assume((x[x](x, (x: x) => !x[x](x[x](x, x), x))): @DropVCs )
        x
      }
      val x: Unit = {
        val x: x[x] = x
        val x: x[x] = x[x](x, x[x]())
        assert((x[x](x)): @DropVCs , "Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x)): @DropVCs , "Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis")
        assert((x[x](x, (x: x) => !x[x](x, x))): @DropVCs , "Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis")
        val x: Unit = x[x](x, x)
        assume((x[x](x[x](x, x))): @DropVCs )
        x
      }
      x[x](x, x, x[x](x, x[x](x, x[x]())))
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => ((x[x](x) && x[x](x, x)) && x[x](x) == x[x](x[x](x, x))) && x[x](x) == x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x.x, x)
  x[x](x) && x[x](x, x) && x[x](x) == x[x](x[x](x, x)) && x[x](x) == x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 669
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  x[x](x[x](x, x), (x: x) => x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 670
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || x[x](x[x](x, x[x](x, x[x]())), x) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 671
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] && x.x != x || x.isInstanceOf[x] || stainless.lang.error[BigInt]("match exhaustiveness") >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 672
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 673
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !(x.x != x) || !x[x](x.x, x) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 674
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, (x: x) => x(x)) || !x.isInstanceOf[x] || x[x](x, (x: x) => x(x) || x(x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 675
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 676
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x.x, x)))
    x
  }
  x[x](x, x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 677
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || x.isInstanceOf[x] && !x[x](x, x.x) || x.isInstanceOf[x] || {
  val x: x[x] = stainless.lang.error[x[x]]("match exhaustiveness")
  x[x](x) && x[x](x[x](x, x)) == x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 678
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  require(!x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x), x))
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || x[x](x.x) || {
  val x: Unit = x[x](x.x)
  val x: Unit = {
    assume(x[x](x[x](x.x), x.x))
    x
  }
  true
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 679
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x) < x[x](x) || x[x](x, x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 680
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x == x.x && x[x](x.x, x.x) || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x.x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x, x[x]())), x[x](x.x, x[x](x, x[x]()))))
    x
  }
  x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 681
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x, x) || x[x](x, x)
    case x() =>
      x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) if x == x =>
      x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x[x](x, x) || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x) + x[x](x.x) < x[x](x) + x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 682
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      val x: Unit = x[x](x, x.x)
      val x: Unit = {
        assume(x[x](x.x) <= x[x](x))
        x
      }
      x[x](x.x) > x[x](x) || x[x](x.x) + BigInt("1") == x[x](x)
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 683
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x), x))
    x
  }
  !x[x](x, x) || x[x](x) == x || true
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 684
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 685
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) == x
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 686
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 687
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 688
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 689
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x) || !x[x](x) || !x.isInstanceOf[x] || x[x](x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 690
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || !x.isInstanceOf[x] || x[x](x) || !x[x](x[x](x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 691
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 692
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x.isInstanceOf[x] || !true || x[x](x) >= x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 693
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x) || x[x](x.x, (x: x) => !x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 694
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x) == x)
  require(x[x](x, x) < x[x](x, x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@opaque
def x[x](x: x[x], x: x, x: x): Unit = {
  require(x[x](x, x) && x[x](x, x))
  require(x != x)
  require(x[x](x, x) < x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x), x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x): Unit = choose((x: Unit) => x[x](x[x](x), x))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || {
  val x: Unit = x match {
    case x(x, x) if x == x =>
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x(x, x) if x != x =>
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x[x](x), x))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x)
      val x: Unit = {
        assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
        x
      }
      val x: Unit = x[x](x, x, x)
      assume(x[x](x[x](x), x))
      x
    case x() =>
      assume(false)
      ()
  }
  x[x](x[x](x), x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 695
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 696
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  x[x](x).subsetOf(x[x](x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 697
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x), x) != x[x](x, x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x.x, x), x) == x[x](x.x, x[x](x, x)))
    x
  }
  x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 698
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) >= x[x](x) || !x[x](x, x.x) || x[x](x.x) + x[x](x) < x[x](x) + x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 699
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || x[x](x.x, x[x](x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 700
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || !x[x](x.x, x.x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 701
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || !x[x](x.x, x) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 702
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] || x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 703
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x).subsetOf(x[x](x)) || !x.isInstanceOf[x] || x[x](x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 704
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x) || x.isInstanceOf[x] || x[x](x.x, (x: x) => !x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 705
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x.x, x[x](x.x))
  true
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 706
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x[x](x, x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 707
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 708
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || !x[x](x.x, x.x) || {
            val x: Unit = x[x](x.x, x.x)
            val x: Unit = {
              assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
              x
            }
            x[x](x[x](x.x, x.x)) < x[x](x.x)
          }
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 709
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !(x.x != x) || x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 710
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x, x) || !x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 711
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 712
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 713
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || x.isInstanceOf[x] || x[x](x) <= x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 714
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || x[x](x[x](x), x[x](x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 715
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 716
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || x.isInstanceOf[x] || x[x](x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 717
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || !x.isInstanceOf[x] || x.x == x || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 718
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 719
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  x[x](x, x) && x[x](x, x.x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 720
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => !x[x](x, x)) || x != x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 721
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x.x, x), x[x](x[x](x), x[x]())) == x[x](x.x, x[x](x)))
    x
  }
  x[x](x) || x != x[x]()
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 722
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) != x[x](x) || x[x](x.x) > BigInt("1") || x[x](x.x) <= BigInt("1")
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 723
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 724
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x]
---------------------------------------------------------------------------------------------------------------------------------
VC number 725
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || {
    val x: x[x] = x[x](x)
    !x[x](x[x](x), x) || x[x](x.x, x) != x || true
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 726
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x), x) != x[x](x, x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || {
  val x: x[x] = x[x](x[x](x), x[x]())
  val x: x[x] = x[x](x)
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))
    x
  }
  x[x](x[x](x, x[x](x[x](x), x[x]())), x[x](x)) == x
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 727
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(!x[x](x) && x[x](x, x))
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(x, x), x(x, x)) =>
      val x: Boolean = x[x](x, x)
      if (x) {
        x[x](x, x)
      } else {
        val x: Boolean = !x[x](x)
        if (x) {
          x[x](x, x)
        } else {
          ()
        }
      }
    case _ =>
      ()
  }
} ensuring {
  (x: Unit) => x[x](x[x](x), x)
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
x.isInstanceOf[x] || x.x != x || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: Unit = x[x](x, x)
  x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 728
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 729
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x[x](x, x) || x != x[x](x, x) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 730
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x[x](x)
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 731
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
{
  val x: BigInt = BigInt("0")
  (BigInt("0") + x[x](x)) + x[x](x)
} >= BigInt("0") && {
  val x: BigInt = (BigInt("0") + x[x](x)) + x[x](x)
  BigInt("0")
} >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 732
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x.isInstanceOf[x] || !x.isInstanceOf[x] || !false || x[x](x) >= x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 733
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------


x != x || !x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 734
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || !x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !(x[x](x) || !x[x](x[x](x), x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x) || !x[x](x[x](x), x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x) || x != x[x]()
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 735
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) != x[x](x) || x[x](x) || x[x](x[x](x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 736
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x.x != x || x.x == x
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 737
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x[x](x, x), x) != x[x](x, x[x](x, x)))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x))
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x, x) != x || x[x](x) || {
  val x: x[x] = x[x](x[x](x), x[x]())
  val x: x[x] = x[x](x)
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x), x) == x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x[x](x[x](x), x[x]()))
  x != x[x]()
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 738
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x[x](x, x)) != x || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 739
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 740
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || !x.isInstanceOf[x] || x[x](x, x) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 741
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x[x](x, x[x](x, x[x]())), x) || !x.isInstanceOf[x] || !x[x](x[x](x.x, x[x](x, x[x]())), x[x](x)) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 742
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) >= x[x](x) || !x[x](x, x.x) || x[x](x) + x[x](x.x) < x[x](x) + x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 743
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) > x[x](x) || !x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 744
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 745
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 746
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    assert(!forall((x: Unit) => !(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x)))
    x
  }
  !x[x](x.x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x.x, x)) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x.x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 747
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || !x[x](x.x, x) || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x, x.x)
  val x: Unit = {
    assume(x[x](x.x, x.x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 748
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || {
  val x: x[x] = x[x](x.x, x[x]())
  val x: x[x] = x.x
  val x: Unit = x[x](x, x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  !x[x](x, (x: x) => !x[x](x[x](x, x.x), x)) || x[x](x, (x: x) => !x[x](x[x](x, x.x), x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 749
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) < x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) < x[x](x.x) || x[x](x.x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 750
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] || x.isInstanceOf[x] && x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !(x.x == x.x && x[x](x.x, x.x)) || !x[x](x.x, x.x) || x[x](x.x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 751
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || !x[x](x.x) || !x[x](x.x, (x: x) => !x[x](x, x)) || x[x](x.x, (x: x) => !x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 752
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) == BigInt("0") || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 753
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x == x)

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  require(x[x](x) == x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x != x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x == x
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || {
    val x: Unit = x[x](x.x, x, x)
    val x: Unit = {
      assume(x.x == x)
      x
    }
    x == x
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 754
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) || !x.isInstanceOf[x] || !x.x.isInstanceOf[x] || x[x](x[x](), x[x](x[x](x), x[x]())) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 755
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || x[x](x, (x: x) => x[x](x, x))
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 756
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 757
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x, x) || !x.isInstanceOf[x] || x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
---------------------------------------------------------------------------------------------------------------------------------
VC number 758
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || !x.isInstanceOf[x] || x != x[x](x[x](x.x, x[x]()), x.x) || !x[x](x, (x: x) => !x[x](x, x)) || x == x[x](x[x](x.x, x[x]()), x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 759
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x.isInstanceOf[x] || x[x](x, x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 760
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x) != x[x](x) || x[x](x.x) == x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 761
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x)

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(!x[x](x, x))
    assert(!forall((x: Unit) => (x[x](x, x) != x)), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, x) == x
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x != x || x[x](x.x, x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x.x, x) == x.x)
    x
  }
  x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 762
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || !x[x](x.x, x.x) || {
            val x: Unit = x[x](x.x, x.x)
            val x: Unit = {
              assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
              x
            }
            x[x](x[x](x.x, x.x)) >= x[x](x.x) || x[x](x[x](x, x.x)) >= x[x](x.x) || true
          }
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 763
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || x.isInstanceOf[x] && !x[x](x, x.x) || x.isInstanceOf[x]
---------------------------------------------------------------------------------------------------------------------------------
VC number 764
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || !x.isInstanceOf[x] || x[x](x[x](x.x, x[x](x, x[x]())), x) != x[x](x) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 765
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
x[x](x) || !x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x) || !x[x](x.x, x) || x[x](x.x) >= x[x](x) || x[x](x.x) < x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 766
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || x != x || x != x || x[x](x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 767
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 768
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x[x](x) != x[x](x) || !x.isInstanceOf[x] || x[x](x.x, x[x](x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 769
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 770
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 771
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------


x.isInstanceOf[x] || x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 772
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x)
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 773
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || x.isInstanceOf[x] || x[x](x) != x.x || !x[x](x.x) || {
  val x: x[x] = x[x](x)
  x[x](x.x) != x[x](x) || x[x](x.x) == x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 774
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x[x](x, x) || !x.isInstanceOf[x] || x.x != x || {
  val x: Boolean = false
  !x || {
    val x: Unit = {
      assume(x)
      ()
    }
    !x[x](x[x](x, x), x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 775
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x != x || !x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 776
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x[x](x[x](x), x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 777
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !(x.x != x) || !x[x](x.x, x) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 778
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}
!x[x](x) || !x[x](x) || !x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 779
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x.isInstanceOf[x] || x[x](x, (x: x) => !x[x](x[x](), x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 780
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x) < x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x) >= x[x](x))
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) =>
      x[x](x[x](x), x)
    case x() =>
      x
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x, x) || x[x](x) >= x[x](x) || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || x[x](x.x) >= x[x](x) || {
    val x: Unit = x[x](x.x, x)
    val x: Unit = {
      assume(x[x](x[x](x.x, x[x](x[x](x[x](x, x.x)), x[x]())), x))
      x
    }
    x[x](x[x](x, x[x](x[x](x[x](x, x)), x[x]())), x)
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 781
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x[x](x, x), x)) || !x.isInstanceOf[x] || x[x](x, (x: x) => !x[x](x, x)) && x[x](x, (x: x) => !x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 782
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || !x.isInstanceOf[x] || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 783
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x == x || !x[x](x.x) || !x[x](x.x, x) || x[x](x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 784
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 785
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || !x.isInstanceOf[x] || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 786
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x == x.x || !x[x](x, x.x) || x[x](x.x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 787
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x]): x[x] = {
  require(!x[x](x))
  decreases(x[x](x))
  x match {
    case x(x, x()) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x))
  }
} ensuring {
  (x: x[x]) => x[x](x, x[x](x[x](x), x[x]())) == x
}
x[x](x) <= BigInt("0") || x[x](x[x](x)) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 788
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x))
    require(x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x)), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x))
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x)
  x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 789
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) == x[x](x) || x.isInstanceOf[x] || x[x](x) || {
  val x: x[x] = x[x](x, x)
  x != x[x]()
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 790
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x == x || !x[x](x.x) || x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 791
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) == x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 792
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x.isInstanceOf[x] || x[x](x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 793
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x != x || x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || x != x[x]()
---------------------------------------------------------------------------------------------------------------------------------
VC number 794
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): x = {
  decreases(x[x](x))
  {
    require((!x[x](x)): @ghost )
    x match {
      case x(x, x()) =>
        x
      case x(_, x) =>
        x[x](x)
    }
  } ensuring {
    (x: x) => (x[x](x, x)): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
x[x](x) || x.isInstanceOf[x] && x.x.isInstanceOf[x] || x.isInstanceOf[x] || x[x](stainless.lang.error[x[x]]("match exhaustiveness"), x[x](x[x](x), x[x]())) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 795
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || !x.isInstanceOf[x] || x.x != x || x[x](x) != x || x[x](x, x) < x[x](x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 796
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}
!x[x](x[x](x, x)) || !x.isInstanceOf[x] || x[x](x, (x: x) => !x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 797
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x).subsetOf(x[x](x)) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 798
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || x.isInstanceOf[x] || x[x](x) && x[x](x, x) && x[x](x) == x[x](x[x](x, x)) && x[x](x) == x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 799
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))
!x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  x[x](x, (x: x) => !x[x](x[x](x, x), x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 800
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || x[x](x, (x: x) => x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 801
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x == x || x[x](x, x) >= x[x](x, x) || x.isInstanceOf[x] && x.x == x || x.isInstanceOf[x] && x.x != x || !x.isInstanceOf[x]
---------------------------------------------------------------------------------------------------------------------------------
VC number 802
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x) || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x, x.x))
    x
  }
  x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 803
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x[x](x, x) || x.isInstanceOf[x] && x.isInstanceOf[x] && x.isInstanceOf[x] && x.x != x.x || !x.isInstanceOf[x] || !x.isInstanceOf[x] || !x.isInstanceOf[x] || x.x != x.x || !x[x](x.x, x.x) || x.x != x.x || x[x](x.x, x.x) || x[x](x, x.x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 804
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]()))))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  {
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](), x))), "Choose satisfiability")
    x[x](x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](), x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => !x[x](x, x)))
    require(!x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => !x[x](x[x](x, x), x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => !x[x](x[x](x, x), x))
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x[x](x, x[x]())), x[x](x, x[x](x, x[x]())))
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x[x](x, x)))

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x))
  require(x[x](x))
  require(x[x](x, (x: x) => !x[x](x, x)))
  require(x[x](x, (x: x) => !x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  require(x[x](x, x))
  decreases((x[x](x), x[x](x), x[x](x)))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || x.isInstanceOf[x] && x[x](x, x.x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: Unit = x[x](x, x, x.x)
  val x: Unit = {
    assume(x[x](x[x](x, x[x](x.x, x[x]())), x[x](x, x[x](x.x, x[x]()))))
    x
  }
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](), x)))
    x
  }
  val x: x[x] = x[x]()
  val x: x = x.x
  val x: Unit = x[x](x, x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => !x[x](x[x](x, x), x)))
    x
  }
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x[x](x.x, x[x]()))
  !x[x](x) || !x[x](x.x, x) || !x[x](x, x[x](x, x.x)) || x[x](x[x](x, x.x)) == x[x](x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 805
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x) || x == x || x.isInstanceOf[x] || x[x](x.x, x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 806
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, x) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 807
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x[x](x, x) || x[x](x, x) != BigInt("0") || x[x](x) != x || x[x](x) == x
---------------------------------------------------------------------------------------------------------------------------------
VC number 808
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, (x: x) => !x[x](x[x](x, x), x)) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 809
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: (x) => Boolean, x: (x) => Boolean): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x(x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x(x) || x(x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x(x) || x(x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: (x) => Boolean, x: (x) => Boolean): Unit = choose((x: Unit) => x[x](x, (x: x) => x(x) || x(x)))
!x[x](x, (x: x) => x(x)) || x.isInstanceOf[x] || {
  val x: Unit = x[x](x.x, x, x)
  x[x](x, (x: x) => x(x) || x(x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 810
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x, x[x](x, x)) != x || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 811
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || !x.isInstanceOf[x] || x[x](x) >= x[x](x) || !x[x](x, x.x) || {
  val x: Unit = x[x](x.x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x.x))
    x
  }
  x[x](x) || x != x[x]()
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 812
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || true
---------------------------------------------------------------------------------------------------------------------------------
VC number 813
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  require(x[x](x) != x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x) != x[x](x[x](x), x) + BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x) == x[x](x[x](x), x) + BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

def x[x](x: x[x], x: x): BigInt = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x == x =>
      BigInt("0")
    case x(x, x) if x != x =>
      BigInt("1") + x[x](x, x)
    case x() =>
      BigInt("-1")
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}
!x[x](x, x) || x[x](x) == x || !(x[x](x[x](x)) != x) || {
  val x: x[x] = x[x](x)
  !x[x](x, x) || x[x](x) == x || {
    val x: Unit = x[x](x, x)
    val x: Unit = {
      assume(x[x](x, x) == x[x](x[x](x), x) + BigInt("1"))
      x
    }
    x != x[x]()
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 814
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  x[x](x, (x: x) => x[x](x, x))
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 815
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}
!x[x](x, x) || x[x](x, x) != x || x[x](x) || x[x](x) >= x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  !x.isInstanceOf[x] || x != x[x]()
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 816
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x), x))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x, x)))

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x[x](x, x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x, x))
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, x))
  decreases(x[x](x) + x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x), x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x), x)
}

def x[x](x: x[x], x: x[x]): x[x] = {
  require(x[x](x, x))
  decreases(x[x](x))
  x match {
    case x(x, x) if x[x](x) == x[x](x) =>
      x[x]()
    case x(x, x) =>
      x[x](x, x[x](x, x))
    case x() =>
      x[x]()
  }
} ensuring {
  (x: x[x]) => x[x](x, x) == x
}
!x[x](x) || !x[x](x, x) || !x[x](x, x[x](x, x)) || x[x](x[x](x, x)) != x[x](x) || !x.isInstanceOf[x] || !x[x](x, x.x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x), x))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x) || x[x](x[x](x, x), x[x](x[x](x), x[x]())) == x[x](x, x[x](x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x.x, x[x]())
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, x[x](x, x)))
    x
  }
  val x: x[x] = x[x](x, x)
  val x: x[x] = x[x](x[x](x, x), x[x](x.x, x[x]()))
  !x[x](x, x) || !x[x](x, x) || x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 817
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x).subsetOf(x[x](x)))

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x).subsetOf(x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x).subsetOf(x[x](x))
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@opaque
@library
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x) || !x.isInstanceOf[x] || {
  val x: Unit = x[x](x, x)
  !x[x](x).subsetOf(x[x](x)) || x[x](x.x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    x[x](x) != x[x](x) \\ Set(x.x) || {
      val x: Unit = x[x](x.x, x)
      !x[x](x.x, (x: x) => x[x](x, x)) || !x[x](x.x) || !x[x](x.x, (x: x) => x[x](x, x)) || x[x](x.x)
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 818
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || !x.isInstanceOf[x] || !(x.x != x) || !x[x](x.x, x) || x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 819
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => x[x](x, x)) || !x[x](x).subsetOf(x[x](x)) || !x.isInstanceOf[x] || x[x](x, (x: x) => x[x](x, x))
---------------------------------------------------------------------------------------------------------------------------------
VC number 820
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}
!x[x](x, x) || x[x](x) >= BigInt("0")
---------------------------------------------------------------------------------------------------------------------------------
VC number 821
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@opaque
def x[x](x: x[x], x: x): Unit = {
  require({
    val x: x[x] = x
    (x[x](x)): @DropVCs 
  })
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1")
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@opaque
def x[x](x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    assert(!forall((x: Unit) => !x[x](x[x](x, x), (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x)
  } ensuring {
    (x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x))
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x) || x[x](x[x](x, x)) == x[x](x) - BigInt("1"))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        val x: Boolean = x == x
        if (x) {
          x[x](x, x)
        } else {
          x[x](x, x[x](x, x))
        }
      case x() =>
        x[x]()
    }
  } ensuring {
    (x: x[x]) => ((x[x](x) <= x[x](x) && x[x](x) == x[x](x) \\ Set(x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@opaque
def x[x](x: x[x], x: x): Unit = {
  require(x[x](x, x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x[x](x, x)) < x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x[x](x, x)) < x[x](x)
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x).subsetOf(x[x](x)))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x), (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x) <= x[x](x))

@opaque
def x[x](x: x[x], x: x[x], x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require(x[x](x, (x: x) => x[x](x, x)))
    require(!x[x](x, x))
    require(x == x[x](x, x))
    assert(!forall((x: Unit) => !x[x](x, (x: x) => x[x](x, x))), "Choose satisfiability")
    x[x](x, x, x, x)
  } ensuring {
    (x: Unit) => x[x](x, (x: x) => x[x](x, x))
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, (x: x) => x[x](x, x)))

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => x[x](x[x](x, x)) < x[x](x))

@opaque
def x[x](x: x[x], x: x): Unit = {
  decreases(x[x](x))
  {
    require({
      val x: x[x] = x
      (x[x](x)): @DropVCs 
    })
    assert(!forall((x: Unit) => !{
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }), "Choose satisfiability")
    x[x](x, x)
  } ensuring {
    (x: Unit) => {
      val x: x[x] = x[x](x, x)
      (x[x](x)): @DropVCs 
    }
  }
}

@opaque
def x[x](x: x[x], x: x[x]): Unit = {
  require(x[x](x, (x: x) => x[x](x, x)))
  require(x[x](x))
  decreases(x[x](x))
  assert(!forall((x: Unit) => !(x[x](x) <= x[x](x))), "Choose satisfiability")
  x[x](x, x)
} ensuring {
  (x: Unit) => x[x](x) <= x[x](x)
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x): Unit = choose((x: Unit) => {
  val x: x[x] = x[x](x, x)
  (x[x](x)): @DropVCs 
})
!x[x](x) || x[x](x) != x[x](x) || x[x](x) != x[x](x) || {
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  val x: Unit = x[x](x, x)
  val x: Unit = {
    assume(x[x](x, (x: x) => x[x](x, x)))
    x
  }
  !x[x](x, (x: x) => x[x](x, x)) || !x[x](x, (x: x) => x[x](x, x)) || x.isInstanceOf[x] || !x[x](x, x.x) || {
    val x: x[x] = x[x](x, x.x)
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x[x](x, x.x)))
      x
    }
    val x: Unit = x[x](x, x.x)
    val x: Unit = {
      assume(x[x](x) || x[x](x[x](x, x.x)) == x[x](x) - BigInt("1"))
      x
    }
    x[x](x) < x[x](x) || {
      val x: Unit = x[x](x, x, x.x)
      val x: Unit = {
        assume(x[x](x[x](x, x.x), (x: x) => x[x](x, x)))
        x
      }
      !x[x](x, (x: x) => x[x](x, x)) || {
        val x: Unit = x[x](x, x)
        val x: Unit = {
          assume(x[x](x) <= x[x](x))
          x
        }
        x[x](x) < x[x](x) || x[x](x, x.x) || !x[x](x) || !x[x](x, (x: x) => x[x](x, x)) || {
          val x: x[x] = x[x](x, x.x)
          val x: Unit = x[x](x, x, x, x.x)
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            x
          }
          val x: Unit = {
            assume(x[x](x, (x: x) => x[x](x, x)))
            ()
          }
          val x: Unit = x[x](x, x)
          val x: Unit = {
            assume(x[x](x) <= x[x](x))
            x
          }
          x[x](x[x](x, x.x)) < x[x](x) || !x[x](x.x, x.x) || {
            val x: Unit = x[x](x.x, x.x)
            val x: Unit = {
              assume(x[x](x[x](x.x, x.x)) < x[x](x.x))
              x
            }
            x[x](x[x](x.x, x.x)) >= x[x](x.x) || x[x](x[x](x, x.x)) < x[x](x.x)
          }
        }
      }
    }
  }
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 822
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}
x[x](x) != x[x](x) || x[x](x) != x[x](x) || x[x](x) > BigInt("1") || !x.isInstanceOf[x] || x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 823
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x]): Unit = choose((x: Unit) => x[x](x, x))

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x]): Unit = {
  decreases(x[x](x))
  assert(!forall((x: Unit) => !x[x](x, x)), "Choose satisfiability")
  x[x](x)
} ensuring {
  (x: Unit) => x[x](x, x)
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases((x[x](x), x[x](x)))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (x(), _) =>
      true
    case (x(x, x), x(x, x)) =>
      x == x && x[x](x, x) || x[x](x, x)
    case _ =>
      false
  }
}
x.isInstanceOf[x] || x.x != x || {
  val x: Unit = x[x](x)
  val x: Unit = {
    assume(x[x](x, x))
    x
  }
  !x[x](x) && x[x](x, x)
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 824
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || x[x](x, x) || x.isInstanceOf[x] || !x[x](x.x, (x: x) => !x[x](x, x)) || !x[x](x.x, x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 825
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@library
def x[x](x: x[x]): { x: x | (BigInt("0") < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(x, _) =>
      x
  }
}

@termination(Terminating)
def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(((BigInt("0") + x[x](x)) + x[x](x), BigInt("0")))
  {
    val x: (x[x], x[x]) = (x, x)
    x match {
      case (x(), _) =>
        true
      case (_, x()) =>
        false
      case (x, x) =>
        val x: Boolean = x[x](x) == x[x](x)
        if (x) {
          x[x](x[x](x), x[x](x))
        } else {
          false
        }
    }
  } ensuring {
    (x: Boolean) => if (x) {
      x[x](x) >= x[x](x)
    } else {
      true
    }
  }
}

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, x) || !x[x](x, x) || x[x](x, x) != x || x[x](x, x) != x || x != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  val x: x[x] = x[x](x)
  !x[x](x.x, x) || !x[x](x, x) || x[x](x.x, x) != x || x[x](x, x) != x || x.x != x || x[x](x.x, x) == x
}
---------------------------------------------------------------------------------------------------------------------------------
VC number 826
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x], x: (x) => Boolean): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      x(x) && x[x](x, x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x, (x: x) => !x[x](x, x)) || !x[x](x, (x: x) => !x[x](x, x)) || x.isInstanceOf[x] || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 827
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): Boolean = {
  decreases(x[x](x))
  x match {
    case x() =>
      true
    case x(x, x) =>
      !x[x](x, x) && x[x](x)
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x], x: x): Boolean = {
  decreases(x[x](x))
  {
    x match {
      case x(x, x) =>
        x == x || x[x](x, x)
      case x() =>
        false
    }
  } ensuring {
    (x: Boolean) => ((x == x[x](x).contains(x))): @ghost 
  }
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
!x[x](x) || !x[x](x, x) || x.isInstanceOf[x] || x.x == x || !x[x](x.x) || !x[x](x.x, x) || x[x](x.x) < x[x](x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 828
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

def x[x](x: x[x], x: x[x]): Boolean = {
  decreases(x[x](x))
  val x: (x[x], x[x]) = (x, x)
  x match {
    case (_, x(x, x)) if x[x](x) < x[x](x) =>
      x[x](x, x)
    case (_, _) if x == x =>
      true
    case _ =>
      false
  }
}

@library
def x[x](x: x[x]): Boolean = x match {
  case x() =>
    true
  case _ =>
    false
}

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}
!x[x](x, x) || x.isInstanceOf[x] && x[x](x) < x[x](x) || x == x || x[x](x) || x[x](x[x](x), x)
---------------------------------------------------------------------------------------------------------------------------------
VC number 829
false
@library
abstract class x[x]
case class x[x]() extends x[x]
case class x[x](x: x, x: x[x]) extends x[x]

-----------

@library
@termination(Terminating)
def x[x](x: x[x]): { x: BigInt | (((x >= BigInt("0"))): @ghost  && x(x) <= x[x](x)) } = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        BigInt("0")
      case x(x, x) =>
        BigInt("1") + x[x](x)
    }
  } ensuring {
    (x: BigInt) => ((x >= BigInt("0"))): @ghost 
  }
}

@derived(x)
@DropVCs
def x[x](x: x[x], x: x, x: x[x], x: x[x]): Unit = choose((x: Unit) => x[x](x, x[x](x[x](x, x[x]()), x)) == x)

@library
@termination(Terminating)
def x[x](x: x[x], x: x[x]): x[x] = {
  decreases(x[x](x))
  {
    x match {
      case x() =>
        x
      case x(x, x) =>
        x[x](x, x[x](x, x))
    }
  } ensuring {
    (x: x[x]) => (((x[x](x) == x[x](x) ++ x[x](x) && x[x](x) == x[x](x) + x[x](x)) && (x != x[x]() || x == x))): @ghost 
  }
}

@synthetic
def x(x: BigInt): BigInt = if (x >= BigInt("0")) {
  x
} else {
  -x
}

@opaque
def x[x](x: x[x], x: x, x: x[x], x: x[x]): Unit = {
  require(x[x](x[x](x, x[x](x, x[x]())), x) == x)
  decreases(x[x](x))
  assert(!forall((x: Unit) => (x[x](x, x[x](x[x](x, x[x]()), x)) != x)), "Choose satisfiability")
  x[x](x, x, x, x)
} ensuring {
  (x: Unit) => x[x](x, x[x](x[x](x, x[x]()), x)) == x
}

@library
def x[x](x: x[x]): { x: x[x] | (x[x](x) < x[x](x)) } = {
  require(((x != x[x]())): @ghost )
  x match {
    case x(_, x) =>
      x
  }
}

@synthetic
def x[x](x: x[x]): BigInt = {
  x match {
    case x() =>
      BigInt("0")
    case x(x, x) =>
      (BigInt("1") + BigInt("0")) + x[x](x)
  }
} ensuring {
  (x: BigInt) => x >= BigInt("0")
}

@library
def x[x](x: x[x]): Set[x] = {
  decreases(x[x](x))
  x match {
    case x() =>
      Set[x]()
    case x(x, x) =>
      Set(x) ++ x[x](x)
  }
}
x[x](x[x](x, x[x](x, x[x]())), x) != x || !x.isInstanceOf[x] || {
  val x: x[x] = x[x](x)
  x[x](x[x](x.x, x[x](x, x[x]())), x) != x || {
    val x: Unit = x[x](x.x, x, x, x)
    val x: Unit = {
      assume(x[x](x.x, x[x](x[x](x, x[x]()), x)) == x)
      x
    }
    x[x](x, x[x](x[x](x, x[x]()), x)) == x
  }
}
---------------------------------------------------------------------------------------------------------------------------------
[[1mInternal[0m] Error: / by zero. Trace:
[[1mInternal[0m] - stainless.verification.VerificationCache.$anonfun$1(VerificationCache.scala:69)
[[1mInternal[0m] - scala.util.Try$.apply(Try.scala:210)
[[1mInternal[0m] - inox.utils.TimerStorage.runAndGetTime(Timer.scala:84)
[[1mInternal[0m] - stainless.verification.VerificationCache.checkVC(VerificationCache.scala:108)
[[1mInternal[0m] - stainless.verification.VerificationCache.checkVC$(VerificationCache.scala:26)
[[1mInternal[0m] - stainless.verification.VerificationChecker$$anon$3.checkVC(VerificationChecker.scala:445)
[[1mInternal[0m] - stainless.verification.VerificationChecker.processVC$1(VerificationChecker.scala:155)
[[1mInternal[0m] - stainless.verification.VerificationChecker.$anonfun$4(VerificationChecker.scala:183)
[[1mInternal[0m] - scala.concurrent.Future$.$anonfun$traverse$1(Future.scala:861)
[[1mInternal[0m] - scala.collection.IterableOnceOps.foldLeft(IterableOnce.scala:675)
[[1mInternal[0m] - scala.collection.IterableOnceOps.foldLeft$(IterableOnce.scala:669)
[[1mInternal[0m] - scala.collection.AbstractIterator.foldLeft(Iterator.scala:1300)
[[1mInternal[0m] - scala.concurrent.Future$.traverse(Future.scala:861)
[[1mInternal[0m] - stainless.verification.VerificationChecker.checkVCs(VerificationChecker.scala:184)
[[1mInternal[0m] - stainless.verification.VerificationChecker.checkVCs$(VerificationChecker.scala:53)
[[1mInternal[0m] - stainless.verification.VerificationChecker$Checker$1.checkVCs(VerificationChecker.scala:436)
[[1mInternal[0m] - stainless.verification.VerificationChecker.verify(VerificationChecker.scala:113)
[[1mInternal[0m] - stainless.verification.VerificationChecker.verify$(VerificationChecker.scala:53)
[[1mInternal[0m] - stainless.verification.VerificationChecker$Checker$1.verify(VerificationChecker.scala:436)
[[1mInternal[0m] - stainless.verification.VerificationChecker$.verify(VerificationChecker.scala:450)
[[1mInternal[0m] - stainless.verification.VerificationRun.execute(VerificationComponent.scala:121)
[[1mInternal[0m] - stainless.verification.VerificationRun.execute(VerificationComponent.scala:75)
[[1mInternal[0m] - stainless.ComponentRun.apply(Component.scala:88)
[[1mInternal[0m] - stainless.ComponentRun.apply$(Component.scala:35)
[[1mInternal[0m] - stainless.verification.VerificationRun.apply(VerificationComponent.scala:48)
[[1mInternal[0m] - stainless.frontend.BatchedCallBack.$anonfun$3(BatchedCallBack.scala:118)
[[1mInternal[0m] - scala.collection.immutable.List.map(List.scala:246)
[[1mInternal[0m] - scala.collection.immutable.List.map(List.scala:79)
[[1mInternal[0m] - stainless.frontend.BatchedCallBack.endExtractions(BatchedCallBack.scala:119)
[[1mInternal[0m] - stainless.frontend.ThreadedFrontend$$anon$1.run(ThreadedFrontend.scala:36)
[[1mInternal[0m] - java.base/java.lang.Thread.run(Thread.java:833)
[[1mInternal[0m] / by zero
[[1mInternal[0m] Please inform the authors of Inox about this message
[[31m Error  [0m] Stainless terminated with an error.
[[31m Error  [0m] Debug output is available in the file `stainless-stack-trace.txt`. If the crash is caused by Stainless, you may report your issue on https://github.com/epfl-lara/stainless/issues
[[31m Error  [0m] You may use --debug=stack to have the stack trace displayed in the output.
