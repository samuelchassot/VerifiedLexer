info Compiling with standard Scala 3.2.0 compiler front end...info Finished compiling                                       
info Preprocessing the symbols...                             info Preprocessing finished                                   
info Running phase ConstructsUsage                            info Running phase PartialFunctions                           info Running phase XlangLowering                              info Running phase InnerClasses                               info Running phase Laws                                       info Running phase SuperInvariants                            info Running phase SuperCalls                                 info Running phase Sealing                                    info Running phase MethodLifting                              info Running phase MergeInvariants                            info Running phase FieldAccessors                             info Running phase ValueClasses                               info Running phase MethodsLowering                            info Running phase EffectElaboration                          info Running phase AntiAliasing                               info Running phase ReturnElimination                          info Running phase ImperativeCodeElimination                  info Running phase ImperativeCleanup                          info Running phase AdtSpecialization                          info Running phase RefinementLifting                          info Running phase TypeEncoding                               info Running phase InvariantInitialization                    info Running phase FunctionClosure                            info Running phase FunctionSpecialization                     info Running phase UnfoldOpaque                               info Running phase CallSiteInline                             info Running phase ChooseInjector                             info Running phase ChooseEncoder                              info Running phase FunctionInlining                           info Running phase TraceInductElimination                     info Running phase SizedADTExtraction                         info Running phase InductElimination                          info Running phase MeasureInference                           info Inferring measure for contains...                        info Inferring measure for isPrefix...                        info Inferring measure for -...                               info Inferring measure for last...                            info Inferring measure for filter...                          info Inferring measure for noDuplicate...                     info Inferring measure for ++...                              info Running phase PartialEvaluation                          info Finished lowering the symbols                            
info Generating VCs for functions: isPrefix$0, removeLast$0, reverseList$0, getSuffix$0, getIndex$0, consecutiveSubseq$0, consecutiveSubseqAtHead$0, isSuffix$0, getPrefix$0, lemmaIsSuffixThenSubseq$0, lemmaIsSuffixThenTailIsSuffix$0, lemmaRemovingHeadOfSuffixThenGetPrefixLonger$0, subseqForall$0, lemmaConsecutiveSubseqThenSubseq$0, lemmaContainsAndNotHdThenTlContains$0, lemmaGetIndexBiggerAndHeadNotEqThenTailContains$0, lemmaSameIndexThenSameElement$0, lemmaGetIndexBiggerAndHeadEqThenTailContains$0, lemmaNotHeadSoGetIndexTailIsMinusOne$0, lemmaIsPrefixRefl$0, lemmaConcatTwoListThenFirstIsPrefix$0, lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref$0, lemmaConcatAssociativity$0, lemmaTwoListsConcatAssociativity$0, lemmaChangeCutStillConcatTotal$0, lemmaRemoveLastConcatenatedPrefixStillPrefix$0, lemmaRemoveLastPrefixStillPrefix$0, lemmaPrefixStaysPrefixWhenAddingToSuffix$0, lemmaRemoveLastPrefixDecreasesSize$0, lemmaIsPrefixSameLengthThenSameList$0, lemmaRemoveLastFromBothSidePreservesEq$0, lemmaRemoveLastFromLMakesItPrefix$0, lemmaSamePrefixThenSameSuffix$0, lemmaIsPrefixThenSmallerEqSize$0, lemmaAddHeadSuffixToPrefixStillPrefix$0, lemmaGetSuffixOnListWithItSelfIsEmpty$0, lemmaMoveElementToOtherListKeepsConcatEq$0, lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther$0, concatWithoutDuplicates$0, removeDuplicates$0, removeDuplicates$default$3$0, lemmaSubseqRefl$0, lemmaSubseqOfEmptyIsEmpty$0, lemmaTailIsSubseqOfList$0, lemmaTailIsSubseqOfListBis$0, lemmaTailIsSubseqOfBiggerList$0, lemmaSubSeqTransitive$0, lemmaSubSeqAddSameElmtPreserves$0, lemmaConcatThenFirstSubseqOfTot$0, lemmaConcatThenSecondSubseqOfTot$0, lemmaConcatTwoListsWhichNotContainThenTotNotContain$0, lemmaForallContainsThenInOtherList$0, lemmaForallThenDisjunction2$0, lemmaForallThenDisjunction1$0, lemmaForallContainsThenForEqualLists$0, lemmaForallContainsAndNoDuplicateThenSmallerList$0, lemmaForallContainsAddingInSndListPreserves$0, lemmaForallContainsAddingElmtInPreserves$0, lemmaForallContainsConcatPreserves$0, lemmaForallContainsPreservedRemoveElmt$0, lemmaForallContainsPreservedRemoveElmtInRefList$0, lemmaForallContainsPreservedIfSameContent$0, lemmaForallNotContainsForSubseq$0, lemmaForallNotContainsForConcat$0, lemmaForallNotContainsForConcat$1, lemmaForallNotContainsCannotContain$0, lemmaNoDuplicateConcatThenForallNotContains$0, lemmaForallNotContainsPreservedAddNewElmtInRefList$0, lemmaForallNotContainsNilRefList$0, lemmaForallNotContainedNoDupThenConcatNoDup$0, lemmaRemoveElmtContainedSizeSmaller$0, lemmaRemoveOneElmtNoDuplicateSizeMinusOne$0, noDuplicateConcatNotContainedPreserves$0, noDuplicateConcatListNotContainedPreserves$0, noDuplicateConcatListNotContainedPreservesBis$0, lemmaNoDuplicatePreservedSameContent$0, lemmaRemoveOneElmtNotContainedSameList$0, lemmaRemoveOneElmtPreservesNoDuplicate$0, lemmaSubsetContentThenForallContains$0, notContainsAddNotEqThenNotContains$0, notContainsAThenTailNotContains$0, lemmaListContainsThenFilterContainsNotEmpty$0, lemmaListNotContainsThenFilterContainsEmpty$0, lemmaSameContentSameSizeSmallerEqOneSameList$0...info Finished generating VCs                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
Starting verification...
info Verified: 0 / 982
debug:  - Checking cache: 'postcondition' VC for removeDuplicates$default$3 @582:24...
debug: Cache miss: 'postcondition' VC for removeDuplicates$default$3 @582:24...
info Verified: 1 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsAddingElmtInPreser... (require 1/2))' VC for lemmaForallContainsAddingElmtInPreserves @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsAddingElmtInPreser... (require 1/2))' VC for lemmaForallContainsAddingElmtInPreserves @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsAddingElmtInPreser... (require 1/2))' VC for lemmaForallContainsAddingElmtInPreserves @?:?...
debug: !forall[B](l, (e: B) => contains[B](lRef, e)) || !contains[B](lRef, b) || !l.isInstanceOf[Cons] || !forall[B](l.t, (e: B) => contains[B](lRef, e)) || forall[B](l.t, (e: B) => contains[B](lRef, e))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsAddingElmtInPreser... (require 1/2))' VC for lemmaForallContainsAddingElmtInPreserves @?:?:
debug:  => VALID
info Verified: 2 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsAddingElmtInPreser... (require 2/2))' VC for lemmaForallContainsAddingElmtInPreserves @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsAddingElmtInPreser... (require 2/2))' VC for lemmaForallContainsAddingElmtInPreserves @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsAddingElmtInPreser... (require 2/2))' VC for lemmaForallContainsAddingElmtInPreserves @?:?...
debug: !forall[B](l, (e: B) => contains[B](lRef, e)) || !contains[B](lRef, b) || !l.isInstanceOf[Cons] || !forall[B](l.t, (e: B) => contains[B](lRef, e)) || {
  val bdg: Boolean = forall[B](l.t, (e: B) => contains[B](lRef, e))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsAddingElmtInPreser... (require 2/2))' VC for lemmaForallContainsAddingElmtInPreserves @?:?:
debug:  => VALID
info Verified: 3 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallContainsAddingElmtInPreserves @875:23...
debug: Cache miss: 'non-negative measure' VC for lemmaForallContainsAddingElmtInPreserves @875:23...
debug:  - Now solving 'non-negative measure' VC for lemmaForallContainsAddingElmtInPreserves @875:23...
debug: !forall[B](l, (e: B) => contains[B](lRef, e)) || !contains[B](lRef, b) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaForallContainsAddingElmtInPreserves @875:23:
debug:  => VALID
info Verified: 4 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAddingElmtInPreserves' VC for lemmaForallContainsAddingElmtInPreserves @871:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAddingElmtInPreserves' VC for lemmaForallContainsAddingElmtInPreserves @871:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAddingElmtInPreserves' VC for lemmaForallContainsAddingElmtInPreserves @871:9...
debug: !forall[B](l, (e: B) => contains[B](lRef, e)) || !contains[B](lRef, b) || !l.isInstanceOf[Cons] || forall[B](l.t, (e: B) => contains[B](lRef, e))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAddingElmtInPreserves' VC for lemmaForallContainsAddingElmtInPreserves @871:9:
debug:  => VALID
info Verified: 5 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAddingElmtInPreserves' VC for lemmaForallContainsAddingElmtInPreserves @871:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAddingElmtInPreserves' VC for lemmaForallContainsAddingElmtInPreserves @871:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAddingElmtInPreserves' VC for lemmaForallContainsAddingElmtInPreserves @871:9...
debug: !forall[B](l, (e: B) => contains[B](lRef, e)) || !contains[B](lRef, b) || !l.isInstanceOf[Cons] || {
  val bdg: Boolean = forall[B](l.t, (e: B) => contains[B](lRef, e))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAddingElmtInPreserves' VC for lemmaForallContainsAddingElmtInPreserves @871:9:
debug:  => VALID
info Verified: 6 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallContainsAddingElmtInPreserves @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaForallContainsAddingElmtInPreserves @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaForallContainsAddingElmtInPreserves @?:?...
debug: !forall[B](l, (e: B) => contains[B](lRef, e)) || !contains[B](lRef, b) || !l.isInstanceOf[Cons] || !forall[B](l.t, (e: B) => contains[B](lRef, e)) || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallContainsAddingElmtInPreserves @?:?:
debug:  => VALID
info Verified: 7 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsAddingElmtInPreserves @871:9...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsAddingElmtInPreserves @871:9...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsAddingElmtInPreserves @871:9...
debug: !forall[B](l, (e: B) => contains[B](lRef, e)) || !contains[B](lRef, b) || !l.isInstanceOf[Cons] || !forall[B](l.t, (e: B) => contains[B](lRef, e)) || {
  val bdg: Unit = lemmaForallContainsAddingElmtInPreserves[B](l.t, lRef, b)
  assume(forall[B](Cons[B](b, l.t), (e: B) => contains[B](lRef, e)))
  forall[B](Cons[B](b, l), (e: B) => contains[B](lRef, e))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsAddingElmtInPreserves @871:9:
debug:  => VALID
info Verified: 8 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsAddingElmtInPreserves @872:21...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsAddingElmtInPreserves @872:21...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsAddingElmtInPreserves @872:21...
debug: !forall[B](l, (e: B) => contains[B](lRef, e)) || !contains[B](lRef, b) || l.isInstanceOf[Cons] || forall[B](Cons[B](b, l), (e: B) => contains[B](lRef, e))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsAddingElmtInPreserves @872:21:
debug:  => VALID
info Verified: 9 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallContainsAddingElmtInPreserves @869:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaForallContainsAddingElmtInPreserves @869:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaForallContainsAddingElmtInPreserves @869:5...
debug: !forall[B](l, (e: B) => contains[B](lRef, e)) || {
  val bdg: Boolean = contains[B](lRef, b)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaForallContainsAddingElmtInPreserves @869:5:
debug:  => VALID
info Verified: 10 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsAddingElmtInPreserves @869:5...
debug: Cache hit: 'postcondition' VC for lemmaForallContainsAddingElmtInPreserves @869:5...
info Verified: 11 / 982
debug:  - Checking cache: 'precond. (call getIndex[B](l, e1))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @195:13...
debug: Cache miss: 'precond. (call getIndex[B](l, e1))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @195:13...
debug:  - Now solving 'precond. (call getIndex[B](l, e1))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @195:13...
debug: !contains[B](l, e1) || {
  val bdg: Boolean = contains[B](l, e2)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getIndex[B](l, e1))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @195:13:
debug:  => VALID
info Verified: 12 / 982
debug:  - Checking cache: 'precond. (call getIndex[B](l, e2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @195:31...
debug: Cache hit: 'precond. (call getIndex[B](l, e2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @195:31...
info Verified: 13 / 982
debug:  - Checking cache: 'precond. (call lemmaGetIndexBiggerAndHeadEqThenTailC... (require 1/4))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: Cache miss: 'precond. (call lemmaGetIndexBiggerAndHeadEqThenTailC... (require 1/4))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug:  - Now solving 'precond. (call lemmaGetIndexBiggerAndHeadEqThenTailC... (require 1/4))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || {
  val bdg: BigInt = getIndex[B](l, e1)
  val bdg: BigInt = getIndex[B](l, e2)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaGetIndexBiggerAndHeadEqThenTailC... (require 1/4))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?:
debug:  => VALID
info Verified: 14 / 982
debug:  - Checking cache: 'precond. (call lemmaGetIndexBiggerAndHeadEqThenTailC... (require 2/4))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: Cache hit: 'precond. (call lemmaGetIndexBiggerAndHeadEqThenTailC... (require 2/4))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
info Verified: 15 / 982
debug:  - Checking cache: 'precond. (call lemmaGetIndexBiggerAndHeadEqThenTailC... (require 3/4))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: Cache hit: 'precond. (call lemmaGetIndexBiggerAndHeadEqThenTailC... (require 3/4))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
info Verified: 16 / 982
debug:  - Checking cache: 'precond. (call lemmaGetIndexBiggerAndHeadEqThenTailC... (require 4/4))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: Cache hit: 'precond. (call lemmaGetIndexBiggerAndHeadEqThenTailC... (require 4/4))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
info Verified: 17 / 982
debug:  - Checking cache: 'precond. (call lemmaContainsAndNotHdThenTlContains[B... (require 1/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: Cache hit: 'precond. (call lemmaContainsAndNotHdThenTlContains[B... (require 1/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
info Verified: 18 / 982
debug:  - Checking cache: 'precond. (call lemmaContainsAndNotHdThenTlContains[B... (require 2/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: Cache hit: 'precond. (call lemmaContainsAndNotHdThenTlContains[B... (require 2/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
info Verified: 19 / 982
debug:  - Checking cache: 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 1/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: Cache miss: 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 1/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug:  - Now solving 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 1/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || getIndex[B](l, e1) >= getIndex[B](l, e2) || l.isInstanceOf[Cons] && l.h == e1 || !l.isInstanceOf[Cons] || l.h == e1 || {
  val bdg: Unit = lemmaContainsAndNotHdThenTlContains[B](l, e1)
  assume(contains[B](tail[B](l), e1))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 1/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?:
debug:  => VALID
info Verified: 20 / 982
debug:  - Checking cache: 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 2/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: Cache hit: 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 2/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
info Verified: 21 / 982
debug:  - Checking cache: 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 1/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: Cache miss: 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 1/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug:  - Now solving 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 1/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || {
  val bdg: BigInt = getIndex[B](l, e1)
  bdg >= getIndex[B](l, e2) || l.isInstanceOf[Cons] && l.h == e1 || !l.isInstanceOf[Cons] || l.h == e1 || {
    val bdg: Unit = lemmaContainsAndNotHdThenTlContains[B](l, e1)
    val bdg: List[B] = tail[B](l)
    assume(contains[B](bdg, e1))
    val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e1)
    assume(bdg == BigInt("1") + getIndex[B](bdg, e1))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 1/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?:
debug:  => VALID
info Verified: 22 / 982
debug:  - Checking cache: 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 2/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: Cache hit: 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 2/2))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
info Verified: 23 / 982
debug:  - Checking cache: 'precond. (call lemmaGetIndexBiggerAndHeadNotEqThenTa... (require 1/3))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: Cache miss: 'precond. (call lemmaGetIndexBiggerAndHeadNotEqThenTa... (require 1/3))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug:  - Now solving 'precond. (call lemmaGetIndexBiggerAndHeadNotEqThenTa... (require 1/3))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || {
  val bdg: BigInt = getIndex[B](l, e1)
  val bdg: BigInt = getIndex[B](l, e2)
  bdg >= bdg || l.isInstanceOf[Cons] && l.h == e1 || !l.isInstanceOf[Cons] || l.h == e1 || {
    val bdg: Unit = lemmaContainsAndNotHdThenTlContains[B](l, e1)
    val bdg: List[B] = tail[B](l)
    assume(contains[B](bdg, e1))
    val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e1)
    assume(bdg == BigInt("1") + getIndex[B](bdg, e1))
    val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e2)
    assume(bdg == BigInt("1") + getIndex[B](bdg, e2))
    !contains[B](l.t, e1) || !contains[B](l.t, e2) || {
      val bdg: BigInt = getIndex[B](l.t, e1)
      val bdg: BigInt = getIndex[B](l.t, e2)
      true
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaGetIndexBiggerAndHeadNotEqThenTa... (require 1/3))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?:
debug:  => VALID
info Verified: 24 / 982
debug:  - Checking cache: 'precond. (call lemmaGetIndexBiggerAndHeadNotEqThenTa... (require 2/3))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: Cache hit: 'precond. (call lemmaGetIndexBiggerAndHeadNotEqThenTa... (require 2/3))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
info Verified: 25 / 982
debug:  - Checking cache: 'precond. (call lemmaGetIndexBiggerAndHeadNotEqThenTa... (require 3/3))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: Cache hit: 'precond. (call lemmaGetIndexBiggerAndHeadNotEqThenTa... (require 3/3))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
info Verified: 26 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @212:12...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @212:12...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @212:12...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || {
  val bdg: BigInt = getIndex[B](l, e1)
  val bdg: BigInt = getIndex[B](l, e2)
  bdg >= bdg || {
    val bdg: Unit = l match {
      case Cons(bdg0, _) if bdg0 == e1 =>
        val bdg: Unit = lemmaGetIndexBiggerAndHeadEqThenTailContains[B](l, e1, e2)
        assume(contains[B](tail[B](l), e2))
        bdg
      case Cons(bdg0, bdg1) if bdg0 != e1 =>
        val bdg: Unit = lemmaContainsAndNotHdThenTlContains[B](l, e1)
        val bdg: List[B] = tail[B](l)
        assume(contains[B](bdg, e1))
        val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e1)
        assume(bdg == BigInt("1") + getIndex[B](bdg, e1))
        val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e2)
        assume(bdg == BigInt("1") + getIndex[B](bdg, e2))
        val bdg: Unit = lemmaGetIndexBiggerAndHeadNotEqThenTailContains[B](bdg1, e1, e2)
        assume(contains[B](tail[B](bdg1), e2))
        bdg
      case Nil() =>
        assume(false)
        ()
    }
    l != Nil[B]()
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @212:12:
debug:  => VALID
info Verified: 27 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @214:15...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @214:15...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @214:15...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || {
  val bdg: BigInt = getIndex[B](l, e1)
  val bdg: BigInt = getIndex[B](l, e2)
  bdg >= bdg || {
    val bdg: Unit = l match {
      case Cons(bdg0, _) if bdg0 == e1 =>
        val bdg: Unit = lemmaGetIndexBiggerAndHeadEqThenTailContains[B](l, e1, e2)
        assume(contains[B](tail[B](l), e2))
        bdg
      case Cons(bdg0, bdg1) if bdg0 != e1 =>
        val bdg: Unit = lemmaContainsAndNotHdThenTlContains[B](l, e1)
        val bdg: List[B] = tail[B](l)
        assume(contains[B](bdg, e1))
        val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e1)
        assume(bdg == BigInt("1") + getIndex[B](bdg, e1))
        val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e2)
        assume(bdg == BigInt("1") + getIndex[B](bdg, e2))
        val bdg: Unit = lemmaGetIndexBiggerAndHeadNotEqThenTailContains[B](bdg1, e1, e2)
        assume(contains[B](tail[B](bdg1), e2))
        bdg
      case Nil() =>
        assume(false)
        ()
    }
    !contains[B](tail[B](l), e2) || l != Nil[B]()
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @214:15:
debug:  => VALID
info Verified: 28 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @202:16...
debug: Cache hit: 'body assertion' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @202:16...
info Verified: 29 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @212:12...
debug: Cache miss: 'body assertion' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @212:12...
debug:  - Now solving 'body assertion' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @212:12...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || {
  val bdg: BigInt = getIndex[B](l, e1)
  val bdg: BigInt = getIndex[B](l, e2)
  bdg >= bdg || {
    val bdg: Unit = l match {
      case Cons(bdg0, _) if bdg0 == e1 =>
        val bdg: Unit = lemmaGetIndexBiggerAndHeadEqThenTailContains[B](l, e1, e2)
        assume(contains[B](tail[B](l), e2))
        bdg
      case Cons(bdg0, bdg1) if bdg0 != e1 =>
        val bdg: Unit = lemmaContainsAndNotHdThenTlContains[B](l, e1)
        val bdg: List[B] = tail[B](l)
        assume(contains[B](bdg, e1))
        val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e1)
        assume(bdg == BigInt("1") + getIndex[B](bdg, e1))
        val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e2)
        assume(bdg == BigInt("1") + getIndex[B](bdg, e2))
        val bdg: Unit = lemmaGetIndexBiggerAndHeadNotEqThenTailContains[B](bdg1, e1, e2)
        assume(contains[B](tail[B](bdg1), e2))
        bdg
      case Nil() =>
        assume(false)
        ()
    }
    contains[B](tail[B](l), e2)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @212:12:
debug:  => VALID
info Verified: 30 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @214:15...
debug: Cache miss: 'non-negative measure' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @214:15...
debug:  - Now solving 'non-negative measure' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @214:15...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || getIndex[B](l, e1) >= getIndex[B](l, e2) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @214:15:
debug:  => VALID
info Verified: 31 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/4) of lemmaGetIndexBiggerAndHeadEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @200:9...
debug: Cache hit: 'body assertion: Inlined precondition (1/4) of lemmaGetIndexBiggerAndHeadEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @200:9...
info Verified: 32 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/4) of lemmaGetIndexBiggerAndHeadEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @200:9...
debug: Cache hit: 'body assertion: Inlined precondition (2/4) of lemmaGetIndexBiggerAndHeadEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @200:9...
info Verified: 33 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (3/4) of lemmaGetIndexBiggerAndHeadEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @200:9...
debug: Cache miss: 'body assertion: Inlined precondition (3/4) of lemmaGetIndexBiggerAndHeadEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @200:9...
debug:  - Now solving 'body assertion: Inlined precondition (3/4) of lemmaGetIndexBiggerAndHeadEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @200:9...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || getIndex[B](l, e1) >= getIndex[B](l, e2) || !l.isInstanceOf[Cons] || l.h != e1 || head[B](l) == e1
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (3/4) of lemmaGetIndexBiggerAndHeadEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @200:9:
debug:  => VALID
info Verified: 34 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (4/4) of lemmaGetIndexBiggerAndHeadEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @200:9...
debug: Cache hit: 'body assertion: Inlined precondition (4/4) of lemmaGetIndexBiggerAndHeadEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @200:9...
info Verified: 35 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaContainsAndNotHdThenTlContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @204:9...
debug: Cache hit: 'body assertion: Inlined precondition (1/2) of lemmaContainsAndNotHdThenTlContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @204:9...
info Verified: 36 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaContainsAndNotHdThenTlContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @204:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaContainsAndNotHdThenTlContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @204:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaContainsAndNotHdThenTlContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @204:9...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || getIndex[B](l, e1) >= getIndex[B](l, e2) || l.isInstanceOf[Cons] && l.h == e1 || !l.isInstanceOf[Cons] || l.h == e1 || head[B](l) != e1
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaContainsAndNotHdThenTlContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @204:9:
debug:  => VALID
info Verified: 37 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @205:9...
debug: Cache hit: 'body assertion: Inlined precondition (1/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @205:9...
info Verified: 38 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @205:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @205:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @205:9...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || getIndex[B](l, e1) >= getIndex[B](l, e2) || l.isInstanceOf[Cons] && l.h == e1 || !l.isInstanceOf[Cons] || l.h == e1 || {
  val bdg: Unit = lemmaContainsAndNotHdThenTlContains[B](l, e1)
  assume(contains[B](tail[B](l), e1))
  head[B](l) != e1
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @205:9:
debug:  => VALID
info Verified: 39 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @206:9...
debug: Cache hit: 'body assertion: Inlined precondition (1/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @206:9...
info Verified: 40 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @206:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @206:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @206:9...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || {
  val bdg: BigInt = getIndex[B](l, e1)
  bdg >= getIndex[B](l, e2) || l.isInstanceOf[Cons] && l.h == e1 || !l.isInstanceOf[Cons] || l.h == e1 || {
    val bdg: Unit = lemmaContainsAndNotHdThenTlContains[B](l, e1)
    val bdg: List[B] = tail[B](l)
    assume(contains[B](bdg, e1))
    val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e1)
    assume(bdg == BigInt("1") + getIndex[B](bdg, e1))
    head[B](l) != e2
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @206:9:
debug:  => VALID
info Verified: 41 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/3) of lemmaGetIndexBiggerAndHeadNotEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @208:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/3) of lemmaGetIndexBiggerAndHeadNotEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @208:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/3) of lemmaGetIndexBiggerAndHeadNotEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @208:9...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || {
  val bdg: BigInt = getIndex[B](l, e1)
  val bdg: BigInt = getIndex[B](l, e2)
  bdg >= bdg || l.isInstanceOf[Cons] && l.h == e1 || !l.isInstanceOf[Cons] || l.h == e1 || {
    val bdg: Unit = lemmaContainsAndNotHdThenTlContains[B](l, e1)
    val bdg: List[B] = tail[B](l)
    assume(contains[B](bdg, e1))
    val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e1)
    assume(bdg == BigInt("1") + getIndex[B](bdg, e1))
    val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e2)
    assume(bdg == BigInt("1") + getIndex[B](bdg, e2))
    contains[B](l.t, e1) && contains[B](l.t, e2)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/3) of lemmaGetIndexBiggerAndHeadNotEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @208:9:
debug:  => VALID
info Verified: 42 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/3) of lemmaGetIndexBiggerAndHeadNotEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @208:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/3) of lemmaGetIndexBiggerAndHeadNotEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @208:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/3) of lemmaGetIndexBiggerAndHeadNotEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @208:9...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || {
  val bdg: BigInt = getIndex[B](l, e1)
  val bdg: BigInt = getIndex[B](l, e2)
  bdg >= bdg || l.isInstanceOf[Cons] && l.h == e1 || !l.isInstanceOf[Cons] || l.h == e1 || {
    val bdg: Unit = lemmaContainsAndNotHdThenTlContains[B](l, e1)
    val bdg: List[B] = tail[B](l)
    assume(contains[B](bdg, e1))
    val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e1)
    assume(bdg == BigInt("1") + getIndex[B](bdg, e1))
    val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e2)
    assume(bdg == BigInt("1") + getIndex[B](bdg, e2))
    !contains[B](l.t, e1) || {
      val bdg: Boolean = contains[B](l.t, e2)
      true
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/3) of lemmaGetIndexBiggerAndHeadNotEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @208:9:
debug:  => VALID
info Verified: 43 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (3/3) of lemmaGetIndexBiggerAndHeadNotEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @208:9...
debug: Cache miss: 'body assertion: Inlined precondition (3/3) of lemmaGetIndexBiggerAndHeadNotEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @208:9...
debug:  - Now solving 'body assertion: Inlined precondition (3/3) of lemmaGetIndexBiggerAndHeadNotEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @208:9...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || {
  val bdg: BigInt = getIndex[B](l, e1)
  val bdg: BigInt = getIndex[B](l, e2)
  bdg >= bdg || l.isInstanceOf[Cons] && l.h == e1 || !l.isInstanceOf[Cons] || l.h == e1 || {
    val bdg: Unit = lemmaContainsAndNotHdThenTlContains[B](l, e1)
    val bdg: List[B] = tail[B](l)
    assume(contains[B](bdg, e1))
    val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e1)
    assume(bdg == BigInt("1") + getIndex[B](bdg, e1))
    val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e2)
    assume(bdg == BigInt("1") + getIndex[B](bdg, e2))
    !contains[B](l.t, e1) || !contains[B](l.t, e2) || getIndex[B](l.t, e1) < getIndex[B](l.t, e2)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (3/3) of lemmaGetIndexBiggerAndHeadNotEqThenTailContains' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @208:9:
debug:  => VALID
info Verified: 44 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || {
  val bdg: BigInt = getIndex[B](l, e1)
  val bdg: BigInt = getIndex[B](l, e2)
  bdg >= bdg || l.isInstanceOf[Cons] && l.h == e1 || !l.isInstanceOf[Cons] || l.h == e1 || {
    val bdg: Unit = lemmaContainsAndNotHdThenTlContains[B](l, e1)
    val bdg: List[B] = tail[B](l)
    assume(contains[B](bdg, e1))
    val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e1)
    assume(bdg == BigInt("1") + getIndex[B](bdg, e1))
    val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e2)
    assume(bdg == BigInt("1") + getIndex[B](bdg, e2))
    !contains[B](l.t, e1) || !contains[B](l.t, e2) || getIndex[B](l.t, e1) >= getIndex[B](l.t, e2) || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @?:?:
debug:  => VALID
info Verified: 45 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of check' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @210:21...
debug: Cache miss: 'body assertion: Inlined precondition of check' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @210:21...
debug:  - Now solving 'body assertion: Inlined precondition of check' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @210:21...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || getIndex[B](l, e1) >= getIndex[B](l, e2) || l.isInstanceOf[Cons] && l.h == e1 || l.isInstanceOf[Cons] && l.h != e1 || !l.isInstanceOf[Nil]
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of check' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @210:21:
debug:  => VALID
info Verified: 46 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @198:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @198:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @198:5...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || getIndex[B](l, e1) >= getIndex[B](l, e2) || l.isInstanceOf[Cons] && l.h == e1 || l.isInstanceOf[Cons] && l.h != e1 || l.isInstanceOf[Nil]
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @198:5:
debug:  => VALID
info Verified: 47 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @212:5...
debug: Cache miss: 'postcondition' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @212:5...
debug:  - Now solving 'postcondition' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @212:5...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || {
  val bdg: BigInt = getIndex[B](l, e1)
  val bdg: BigInt = getIndex[B](l, e2)
  bdg >= bdg || {
    val bdg: Unit = l match {
      case Cons(bdg0, _) if bdg0 == e1 =>
        val bdg: Unit = lemmaGetIndexBiggerAndHeadEqThenTailContains[B](l, e1, e2)
        assume(contains[B](tail[B](l), e2))
        bdg
      case Cons(bdg0, bdg1) if bdg0 != e1 =>
        val bdg: Unit = lemmaContainsAndNotHdThenTlContains[B](l, e1)
        val bdg: List[B] = tail[B](l)
        assume(contains[B](bdg, e1))
        val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e1)
        assume(bdg == BigInt("1") + getIndex[B](bdg, e1))
        val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](l, e2)
        assume(bdg == BigInt("1") + getIndex[B](bdg, e2))
        val bdg: Unit = lemmaGetIndexBiggerAndHeadNotEqThenTailContains[B](bdg1, e1, e2)
        assume(contains[B](tail[B](bdg1), e2))
        bdg
      case Nil() =>
        assume(false)
        ()
    }
    val bdg: Boolean = contains[B](tail[B](l), e2)
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaGetIndexBiggerAndHeadNotEqThenTailContains @212:5:
debug:  => VALID
info Verified: 48 / 982
debug:  - Checking cache: 'precond. (call head[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @251:13...
debug: Cache miss: 'precond. (call head[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @251:13...
debug:  - Now solving 'precond. (call head[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @251:13...
debug: !contains[B](l, e) || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @251:13:
debug:  => VALID
info Verified: 49 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @254:9...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @254:9...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @254:9...
debug: !contains[B](l, e) || head[B](l) == e || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @254:9:
debug:  => VALID
info Verified: 50 / 982
debug:  - Checking cache: 'precond. (call head[B](tail[B](l)))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @254:9...
debug: Cache miss: 'precond. (call head[B](tail[B](l)))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @254:9...
debug:  - Now solving 'precond. (call head[B](tail[B](l)))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @254:9...
debug: !contains[B](l, e) || head[B](l) == e || tail[B](l) != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](tail[B](l)))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @254:9:
debug:  => VALID
info Verified: 51 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @255:44...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @255:44...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @255:44...
debug: !contains[B](l, e) || head[B](l) == e || head[B](tail[B](l)) == e || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @255:44:
debug:  => VALID
info Verified: 52 / 982
debug:  - Checking cache: 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 1/2))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @?:?...
debug: Cache miss: 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 1/2))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @?:?...
debug:  - Now solving 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 1/2))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @?:?...
debug: !contains[B](l, e) || head[B](l) == e || {
  val bdg: List[B] = tail[B](l)
  head[B](bdg) == e || {
    val bdg: Boolean = contains[B](bdg, e)
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 1/2))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @?:?:
debug:  => VALID
info Verified: 53 / 982
debug:  - Checking cache: 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 2/2))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @?:?...
debug: Cache hit: 'precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 2/2))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @?:?...
info Verified: 54 / 982
debug:  - Checking cache: 'precond. (call getIndex[B](l, e))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:15...
debug: Cache miss: 'precond. (call getIndex[B](l, e))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:15...
debug:  - Now solving 'precond. (call getIndex[B](l, e))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:15...
debug: !contains[B](l, e) || head[B](l) == e || {
  val bdg: List[B] = tail[B](l)
  head[B](bdg) == e || !contains[B](bdg, e) || {
    val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](bdg, e)
    assume(getIndex[B](bdg, e) == BigInt("1") + getIndex[B](tail[B](bdg), e))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getIndex[B](l, e))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:15:
debug:  => VALID
info Verified: 55 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:42...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:42...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:42...
debug: !contains[B](l, e) || head[B](l) == e || {
  val bdg: List[B] = tail[B](l)
  head[B](bdg) == e || !contains[B](bdg, e) || {
    val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](bdg, e)
    assume(getIndex[B](bdg, e) == BigInt("1") + getIndex[B](tail[B](bdg), e))
    l != Nil[B]()
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:42:
debug:  => VALID
info Verified: 56 / 982
debug:  - Checking cache: 'precond. (call getIndex[B](tail[B](l), e))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:33...
debug: Cache hit: 'precond. (call getIndex[B](tail[B](l), e))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:33...
info Verified: 57 / 982
debug:  - Checking cache: 'precond. (call getIndex[B](l, e))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:15...
debug: Cache miss: 'precond. (call getIndex[B](l, e))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:15...
debug:  - Now solving 'precond. (call getIndex[B](l, e))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:15...
debug: val bdg: Boolean = contains[B](l, e)
true
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getIndex[B](l, e))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:15:
debug:  => VALID
info Verified: 58 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:42...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:42...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:42...
debug: !contains[B](l, e) || head[B](l) == e || head[B](tail[B](l)) != e || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:42:
debug:  => VALID
info Verified: 59 / 982
debug:  - Checking cache: 'precond. (call getIndex[B](tail[B](l), e))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:33...
debug: Cache miss: 'precond. (call getIndex[B](tail[B](l), e))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:33...
debug:  - Now solving 'precond. (call getIndex[B](tail[B](l), e))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:33...
debug: !contains[B](l, e) || head[B](l) == e || {
  val bdg: List[B] = tail[B](l)
  head[B](bdg) != e || contains[B](bdg, e)
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getIndex[B](tail[B](l), e))' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:33:
debug:  => VALID
info Verified: 60 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:42...
debug: Cache miss: 'non-negative measure' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:42...
debug:  - Now solving 'non-negative measure' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:42...
debug: !contains[B](l, e) || head[B](l) == e || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @257:42:
debug:  => VALID
info Verified: 61 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @255:7...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @255:7...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @255:7...
debug: !contains[B](l, e) || head[B](l) == e || {
  val bdg: List[B] = tail[B](l)
  head[B](bdg) == e || contains[B](bdg, e)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @255:7:
debug:  => VALID
info Verified: 62 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @255:7...
debug: Cache hit: 'body assertion: Inlined precondition (2/2) of lemmaNotHeadSoGetIndexTailIsMinusOne' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @255:7...
info Verified: 63 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @?:?...
debug: !contains[B](l, e) || head[B](l) == e || {
  val bdg: List[B] = tail[B](l)
  head[B](bdg) == e || !contains[B](bdg, e) || ListPrimitiveSize[B](bdg) < ListPrimitiveSize[B](l)
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @?:?:
debug:  => VALID
info Verified: 64 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @255:7...
debug: Cache miss: 'postcondition' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @255:7...
debug:  - Now solving 'postcondition' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @255:7...
debug: !contains[B](l, e) || head[B](l) == e || {
  val bdg: List[B] = tail[B](l)
  head[B](bdg) == e || !contains[B](bdg, e) || {
    val bdg: Unit = lemmaNotHeadSoGetIndexTailIsMinusOne[B](bdg, e)
    val bdg: BigInt = getIndex[B](tail[B](bdg), e)
    val bdg: BigInt = getIndex[B](bdg, e)
    assume(bdg == BigInt("1") + bdg)
    getIndex[B](l, e) == BigInt("1") + bdg
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @255:7:
debug:  => VALID
info Verified: 65 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @256:6...
debug: Cache miss: 'postcondition' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @256:6...
debug:  - Now solving 'postcondition' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @256:6...
debug: !contains[B](l, e) || head[B](l) == e || {
  val bdg: List[B] = tail[B](l)
  head[B](bdg) != e || getIndex[B](l, e) == BigInt("1") + getIndex[B](bdg, e)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaNotHeadSoGetIndexTailIsMinusOne @256:6:
debug:  => VALID
info Verified: 66 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsAddingInSndListPre...)' VC for lemmaForallContainsAddingInSndListPreserves @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsAddingInSndListPre...)' VC for lemmaForallContainsAddingInSndListPreserves @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsAddingInSndListPre...)' VC for lemmaForallContainsAddingInSndListPreserves @?:?...
debug: !forall[B](l, (e: B) => contains[B](lRef, e)) || !l.isInstanceOf[Cons] || !forall[B](l.t, (e: B) => contains[B](lRef, e)) || forall[B](l.t, (e: B) => contains[B](lRef, e))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsAddingInSndListPre...)' VC for lemmaForallContainsAddingInSndListPreserves @?:?:
debug:  => VALID
info Verified: 67 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallContainsAddingInSndListPreserves @856:15...
debug: Cache miss: 'non-negative measure' VC for lemmaForallContainsAddingInSndListPreserves @856:15...
debug:  - Now solving 'non-negative measure' VC for lemmaForallContainsAddingInSndListPreserves @856:15...
debug: !forall[B](l, (e: B) => contains[B](lRef, e)) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaForallContainsAddingInSndListPreserves @856:15:
debug:  => VALID
info Verified: 68 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaForallContainsAddingInSndListPreserves' VC for lemmaForallContainsAddingInSndListPreserves @852:9...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaForallContainsAddingInSndListPreserves' VC for lemmaForallContainsAddingInSndListPreserves @852:9...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaForallContainsAddingInSndListPreserves' VC for lemmaForallContainsAddingInSndListPreserves @852:9...
debug: !forall[B](l, (e: B) => contains[B](lRef, e)) || !l.isInstanceOf[Cons] || forall[B](l.t, (e: B) => contains[B](lRef, e))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaForallContainsAddingInSndListPreserves' VC for lemmaForallContainsAddingInSndListPreserves @852:9:
debug:  => VALID
info Verified: 69 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallContainsAddingInSndListPreserves @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaForallContainsAddingInSndListPreserves @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaForallContainsAddingInSndListPreserves @?:?...
debug: !forall[B](l, (e: B) => contains[B](lRef, e)) || !l.isInstanceOf[Cons] || !forall[B](l.t, (e: B) => contains[B](lRef, e)) || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallContainsAddingInSndListPreserves @?:?:
debug:  => VALID
info Verified: 70 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsAddingInSndListPreserves @852:9...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsAddingInSndListPreserves @852:9...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsAddingInSndListPreserves @852:9...
debug: !forall[B](l, (e: B) => contains[B](lRef, e)) || !l.isInstanceOf[Cons] || !forall[B](l.t, (e: B) => contains[B](lRef, e)) || {
  val bdg: Unit = lemmaForallContainsAddingInSndListPreserves[B](l.t, lRef, b)
  assume(forall[B](l.t, (e: B) => contains[B](Cons[B](b, lRef), e)))
  forall[B](l, (e: B) => contains[B](Cons[B](b, lRef), e))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsAddingInSndListPreserves @852:9:
debug:  => VALID
info Verified: 71 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsAddingInSndListPreserves @853:21...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsAddingInSndListPreserves @853:21...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsAddingInSndListPreserves @853:21...
debug: !forall[B](l, (e: B) => contains[B](lRef, e)) || l.isInstanceOf[Cons] || forall[B](l, (e: B) => contains[B](Cons[B](b, lRef), e))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsAddingInSndListPreserves @853:21:
debug:  => VALID
info Verified: 72 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallContainsAddingInSndListPreserves @850:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaForallContainsAddingInSndListPreserves @850:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaForallContainsAddingInSndListPreserves @850:5...
debug: val bdg: Boolean = forall[B](l, (e: B) => contains[B](lRef, e))
true
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaForallContainsAddingInSndListPreserves @850:5:
debug:  => VALID
info Verified: 73 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsAddingInSndListPreserves @850:5...
debug: Cache hit: 'postcondition' VC for lemmaForallContainsAddingInSndListPreserves @850:5...
info Verified: 74 / 982
debug:  - Checking cache: 'precond. (call lemmaTailIsSubseqOfBiggerList[B](l, l...)' VC for subseqForall @?:?...
debug: Cache miss: 'precond. (call lemmaTailIsSubseqOfBiggerList[B](l, l...)' VC for subseqForall @?:?...
debug:  - Now solving 'precond. (call lemmaTailIsSubseqOfBiggerList[B](l, l...)' VC for subseqForall @?:?...
debug: !subseq[B](lSub, l) || {
  val bdg: Boolean = forall[B](l, p)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaTailIsSubseqOfBiggerList[B](l, l...)' VC for subseqForall @?:?:
debug:  => VALID
info Verified: 75 / 982
debug:  - Checking cache: 'precond. (call subseqContains[B](lSub, l, (scrut.h):...)' VC for subseqForall @156:9...
debug: Cache miss: 'precond. (call subseqContains[B](lSub, l, (scrut.h):...)' VC for subseqForall @156:9...
debug:  - Now solving 'precond. (call subseqContains[B](lSub, l, (scrut.h):...)' VC for subseqForall @156:9...
debug: !subseq[B](lSub, l) || !forall[B](l, p) || !lSub.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaTailIsSubseqOfBiggerList[B](lSub, l)
  assume(isEmpty[B](lSub) || subseq[B](tail[B](lSub), l))
  contains[B](lSub, lSub.h)
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call subseqContains[B](lSub, l, (scrut.h):...)' VC for subseqForall @156:9:
debug:  => VALID
info Verified: 76 / 982
debug:  - Checking cache: 'precond. (call forallContained[B](l, p, (scrut.h): @...)' VC for subseqForall @157:9...
debug: Cache miss: 'precond. (call forallContained[B](l, p, (scrut.h): @...)' VC for subseqForall @157:9...
debug:  - Now solving 'precond. (call forallContained[B](l, p, (scrut.h): @...)' VC for subseqForall @157:9...
debug: !subseq[B](lSub, l) || !forall[B](l, p) || !lSub.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaTailIsSubseqOfBiggerList[B](lSub, l)
  assume(isEmpty[B](lSub) || subseq[B](tail[B](lSub), l))
  val bdg: Unit = subseqContains[B](lSub, l, lSub.h)
  contains[B](l, lSub.h)
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call forallContained[B](l, p, (scrut.h): @...)' VC for subseqForall @157:9:
debug:  => VALID
info Verified: 77 / 982
debug:  - Checking cache: 'precond. (call subseqForall[B](l, lSub, p) (require 1/2))' VC for subseqForall @?:?...
debug: Cache miss: 'precond. (call subseqForall[B](l, lSub, p) (require 1/2))' VC for subseqForall @?:?...
debug:  - Now solving 'precond. (call subseqForall[B](l, lSub, p) (require 1/2))' VC for subseqForall @?:?...
debug: !subseq[B](lSub, l) || !forall[B](l, p) || !lSub.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaTailIsSubseqOfBiggerList[B](lSub, l)
  assume(isEmpty[B](lSub) || subseq[B](tail[B](lSub), l))
  val bdg: Unit = subseqContains[B](lSub, l, lSub.h)
  val bdg: Unit = forallContained[B](l, p, lSub.h)
  val bdg: Boolean = subseq[B](lSub.t, l)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call subseqForall[B](l, lSub, p) (require 1/2))' VC for subseqForall @?:?:
debug:  => VALID
info Verified: 78 / 982
debug:  - Checking cache: 'precond. (call subseqForall[B](l, lSub, p) (require 2/2))' VC for subseqForall @?:?...
debug: Cache hit: 'precond. (call subseqForall[B](l, lSub, p) (require 2/2))' VC for subseqForall @?:?...
info Verified: 79 / 982
debug:  - Checking cache: 'non-negative measure' VC for subseqForall @152:15...
debug: Cache miss: 'non-negative measure' VC for subseqForall @152:15...
debug:  - Now solving 'non-negative measure' VC for subseqForall @152:15...
debug: !subseq[B](lSub, l) || !forall[B](l, p) || size[B](lSub) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for subseqForall @152:15:
debug:  => VALID
info Verified: 80 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaTailIsSubseqOfBiggerList' VC for subseqForall @155:9...
debug: Cache hit: 'body assertion: Inlined precondition of lemmaTailIsSubseqOfBiggerList' VC for subseqForall @155:9...
info Verified: 81 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of subseqForall' VC for subseqForall @158:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of subseqForall' VC for subseqForall @158:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of subseqForall' VC for subseqForall @158:9...
debug: !subseq[B](lSub, l) || !forall[B](l, p) || !lSub.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaTailIsSubseqOfBiggerList[B](lSub, l)
  assume(isEmpty[B](lSub) || subseq[B](tail[B](lSub), l))
  val bdg: Unit = subseqContains[B](lSub, l, lSub.h)
  val bdg: Unit = forallContained[B](l, p, lSub.h)
  subseq[B](lSub.t, l)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of subseqForall' VC for subseqForall @158:9:
debug:  => VALID
info Verified: 82 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of subseqForall' VC for subseqForall @158:9...
debug: Cache hit: 'body assertion: Inlined precondition (2/2) of subseqForall' VC for subseqForall @158:9...
info Verified: 83 / 982
debug:  - Checking cache: 'measure decreases' VC for subseqForall @?:?...
debug: Cache miss: 'measure decreases' VC for subseqForall @?:?...
debug:  - Now solving 'measure decreases' VC for subseqForall @?:?...
debug: !subseq[B](lSub, l) || !forall[B](l, p) || !lSub.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaTailIsSubseqOfBiggerList[B](lSub, l)
  assume(isEmpty[B](lSub) || subseq[B](tail[B](lSub), l))
  val bdg: Unit = subseqContains[B](lSub, l, lSub.h)
  val bdg: Unit = forallContained[B](l, p, lSub.h)
  !subseq[B](lSub.t, l) || size[B](lSub.t) < size[B](lSub)
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for subseqForall @?:?:
debug:  => VALID
info Verified: 84 / 982
debug:  - Checking cache: 'postcondition' VC for subseqForall @158:9...
debug: Cache miss: 'postcondition' VC for subseqForall @158:9...
debug:  - Now solving 'postcondition' VC for subseqForall @158:9...
debug: !subseq[B](lSub, l) || !forall[B](l, p) || !lSub.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaTailIsSubseqOfBiggerList[B](lSub, l)
  assume(isEmpty[B](lSub) || subseq[B](tail[B](lSub), l))
  val bdg: Unit = subseqContains[B](lSub, l, lSub.h)
  val bdg: Unit = forallContained[B](l, p, lSub.h)
  !subseq[B](lSub.t, l) || {
    val bdg: Unit = subseqForall[B](l, lSub.t, p)
    assume(forall[B](lSub.t, p))
    forall[B](lSub, p)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for subseqForall @158:9:
debug:  => VALID
info Verified: 85 / 982
debug:  - Checking cache: 'postcondition' VC for subseqForall @160:21...
debug: Cache miss: 'postcondition' VC for subseqForall @160:21...
debug:  - Now solving 'postcondition' VC for subseqForall @160:21...
debug: !subseq[B](lSub, l) || !forall[B](l, p) || lSub.isInstanceOf[Cons] || forall[B](lSub, p)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for subseqForall @160:21:
debug:  => VALID
info Verified: 86 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for subseqForall @153:5...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for subseqForall @153:5...
info Verified: 87 / 982
debug:  - Checking cache: 'postcondition' VC for subseqForall @153:5...
debug: Cache hit: 'postcondition' VC for subseqForall @153:5...
info Verified: 88 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfBiggerList @662:29...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfBiggerList @662:29...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfBiggerList @662:29...
debug: !subseq[B](l, lRef) || {
  val bdg: Unit = lemmaTailIsSubseqOfListBis[B](l)
  val bdg: Boolean = isEmpty[B](l)
  assume(bdg || subseq[B](tail[B](l), l))
  bdg || l != Nil[B]()
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfBiggerList @662:29:
debug:  => VALID
info Verified: 89 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaTailIsSubseqOfBiggerList @?:?...
debug: Cache miss: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaTailIsSubseqOfBiggerList @?:?...
debug:  - Now solving 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaTailIsSubseqOfBiggerList @?:?...
debug: !subseq[B](l, lRef) || {
  val bdg: Unit = lemmaTailIsSubseqOfListBis[B](l)
  val bdg: Boolean = isEmpty[B](l)
  assume(bdg || subseq[B](tail[B](l), l))
  bdg || {
    val bdg: Boolean = subseq[B](tail[B](l), l)
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaTailIsSubseqOfBiggerList @?:?:
debug:  => VALID
info Verified: 90 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaTailIsSubseqOfBiggerList @?:?...
debug: Cache hit: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaTailIsSubseqOfBiggerList @?:?...
info Verified: 91 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfBiggerList @665:45...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfBiggerList @665:45...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfBiggerList @665:45...
debug: !subseq[B](l, lRef) || {
  val bdg: Unit = lemmaTailIsSubseqOfListBis[B](l)
  val bdg: Boolean = isEmpty[B](l)
  assume(bdg || subseq[B](tail[B](l), l))
  bdg || {
    val bdg: List[B] = tail[B](l)
    !subseq[B](bdg, l) || {
      val bdg: Unit = lemmaSubSeqTransitive[B](bdg, l, lRef)
      assume(subseq[B](bdg, lRef))
      l != Nil[B]()
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfBiggerList @665:45:
debug:  => VALID
info Verified: 92 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfBiggerList @665:45...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfBiggerList @665:45...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfBiggerList @665:45...
debug: !subseq[B](l, lRef) || {
  val bdg: Unit = lemmaTailIsSubseqOfListBis[B](l)
  assume(isEmpty[B](l) || subseq[B](tail[B](l), l))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfBiggerList @665:45:
debug:  => VALID
info Verified: 93 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaTailIsSubseqOfBiggerList @662:7...
debug: Cache hit: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaTailIsSubseqOfBiggerList @662:7...
info Verified: 94 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaTailIsSubseqOfBiggerList @662:7...
debug: Cache hit: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaTailIsSubseqOfBiggerList @662:7...
info Verified: 95 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaTailIsSubseqOfBiggerList @662:7...
debug: Cache miss: 'postcondition' VC for lemmaTailIsSubseqOfBiggerList @662:7...
debug:  - Now solving 'postcondition' VC for lemmaTailIsSubseqOfBiggerList @662:7...
debug: !subseq[B](l, lRef) || {
  val bdg: Unit = lemmaTailIsSubseqOfListBis[B](l)
  val bdg: Boolean = isEmpty[B](l)
  assume(bdg || subseq[B](tail[B](l), l))
  bdg || {
    val bdg: List[B] = tail[B](l)
    !subseq[B](bdg, l) || {
      val bdg: Unit = lemmaSubSeqTransitive[B](bdg, l, lRef)
      assume(subseq[B](bdg, lRef))
      true
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaTailIsSubseqOfBiggerList @662:7:
debug:  => VALID
info Verified: 96 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaTailIsSubseqOfBiggerList @664:6...
debug: Cache hit: 'postcondition' VC for lemmaTailIsSubseqOfBiggerList @664:6...
info Verified: 97 / 982
debug:  - Checking cache: 'precond. (call concatWithoutDuplicates[B](baseList, ...)' VC for concatWithoutDuplicates @?:?...
debug: Cache miss: 'precond. (call concatWithoutDuplicates[B](baseList, ...)' VC for concatWithoutDuplicates @?:?...
debug:  - Now solving 'precond. (call concatWithoutDuplicates[B](baseList, ...)' VC for concatWithoutDuplicates @?:?...
debug: !noDuplicate[B](baseList) || !newList.isInstanceOf[Cons] || {
  val bdg: Boolean = contains[B](baseList, newList.h)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call concatWithoutDuplicates[B](baseList, ...)' VC for concatWithoutDuplicates @?:?:
debug:  => VALID
info Verified: 98 / 982
debug:  - Checking cache: 'precond. (call concatWithoutDuplicates[B](baseList, ...)' VC for concatWithoutDuplicates @?:?...
debug: Cache miss: 'precond. (call concatWithoutDuplicates[B](baseList, ...)' VC for concatWithoutDuplicates @?:?...
debug:  - Now solving 'precond. (call concatWithoutDuplicates[B](baseList, ...)' VC for concatWithoutDuplicates @?:?...
debug: !noDuplicate[B](baseList) || newList.isInstanceOf[Cons] && contains[B](baseList, newList.h) || !newList.isInstanceOf[Cons] || contains[B](baseList, newList.h) || {
  val bdg: Boolean = noDuplicate[B](Cons[B](newList.h, baseList))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call concatWithoutDuplicates[B](baseList, ...)' VC for concatWithoutDuplicates @?:?:
debug:  => VALID
info Verified: 99 / 982
debug:  - Checking cache: 'non-negative measure' VC for concatWithoutDuplicates @571:15...
debug: Cache miss: 'non-negative measure' VC for concatWithoutDuplicates @571:15...
debug:  - Now solving 'non-negative measure' VC for concatWithoutDuplicates @571:15...
debug: !noDuplicate[B](baseList) || size[B](newList) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for concatWithoutDuplicates @571:15:
debug:  => VALID
info Verified: 100 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of concatWithoutDuplicates' VC for concatWithoutDuplicates @575:9...
debug: Cache hit: 'body assertion: Inlined precondition of concatWithoutDuplicates' VC for concatWithoutDuplicates @575:9...
info Verified: 101 / 982
debug:  - Checking cache: 'measure decreases' VC for concatWithoutDuplicates @?:?...
debug: Cache miss: 'measure decreases' VC for concatWithoutDuplicates @?:?...
debug:  - Now solving 'measure decreases' VC for concatWithoutDuplicates @?:?...
debug: !noDuplicate[B](baseList) || !newList.isInstanceOf[Cons] || !contains[B](baseList, newList.h) || size[B](newList.t) < size[B](newList)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for concatWithoutDuplicates @?:?:
debug:  => VALID
info Verified: 102 / 982
debug:  - Checking cache: 'postcondition' VC for concatWithoutDuplicates @575:9...
debug: Cache miss: 'postcondition' VC for concatWithoutDuplicates @575:9...
debug:  - Now solving 'postcondition' VC for concatWithoutDuplicates @575:9...
debug: !noDuplicate[B](baseList) || !newList.isInstanceOf[Cons] || !contains[B](baseList, newList.h) || {
  val bdg: List[B] = concatWithoutDuplicates[B](baseList, newList.t)
  assume(noDuplicate[B](bdg) && content[B](++[B](baseList, newList.t)) == content[B](bdg))
  content[B](++[B](baseList, newList)) == content[B](bdg)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for concatWithoutDuplicates @575:9:
debug:  => VALID
info Verified: 103 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of concatWithoutDuplicates' VC for concatWithoutDuplicates @577:9...
debug: Cache miss: 'body assertion: Inlined precondition of concatWithoutDuplicates' VC for concatWithoutDuplicates @577:9...
debug:  - Now solving 'body assertion: Inlined precondition of concatWithoutDuplicates' VC for concatWithoutDuplicates @577:9...
debug: !noDuplicate[B](baseList) || newList.isInstanceOf[Cons] && contains[B](baseList, newList.h) || !newList.isInstanceOf[Cons] || contains[B](baseList, newList.h) || noDuplicate[B](Cons[B](newList.h, baseList))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of concatWithoutDuplicates' VC for concatWithoutDuplicates @577:9:
debug:  => VALID
info Verified: 104 / 982
debug:  - Checking cache: 'measure decreases' VC for concatWithoutDuplicates @?:?...
debug: Cache miss: 'measure decreases' VC for concatWithoutDuplicates @?:?...
debug:  - Now solving 'measure decreases' VC for concatWithoutDuplicates @?:?...
debug: !noDuplicate[B](baseList) || newList.isInstanceOf[Cons] && contains[B](baseList, newList.h) || !newList.isInstanceOf[Cons] || contains[B](baseList, newList.h) || !noDuplicate[B](Cons[B](newList.h, baseList)) || size[B](newList.t) < size[B](newList)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for concatWithoutDuplicates @?:?:
debug:  => VALID
info Verified: 105 / 982
debug:  - Checking cache: 'postcondition' VC for concatWithoutDuplicates @577:9...
debug: Cache miss: 'postcondition' VC for concatWithoutDuplicates @577:9...
debug:  - Now solving 'postcondition' VC for concatWithoutDuplicates @577:9...
debug: !noDuplicate[B](baseList) || newList.isInstanceOf[Cons] && contains[B](baseList, newList.h) || !newList.isInstanceOf[Cons] || contains[B](baseList, newList.h) || {
  val bdg: List[B] = Cons[B](newList.h, baseList)
  !noDuplicate[B](bdg) || {
    val bdg: List[B] = concatWithoutDuplicates[B](bdg, newList.t)
    assume(noDuplicate[B](bdg) && content[B](++[B](bdg, newList.t)) == content[B](bdg))
    content[B](++[B](baseList, newList)) == content[B](bdg)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for concatWithoutDuplicates @577:9:
debug:  => VALID
info Verified: 106 / 982
debug:  - Checking cache: 'postcondition' VC for concatWithoutDuplicates @580:51...
debug: Cache miss: 'postcondition' VC for concatWithoutDuplicates @580:51...
debug:  - Now solving 'postcondition' VC for concatWithoutDuplicates @580:51...
debug: !noDuplicate[B](baseList) || newList.isInstanceOf[Cons] && contains[B](baseList, newList.h) || newList.isInstanceOf[Cons] && !contains[B](baseList, newList.h) || !newList.isInstanceOf[Nil] || content[B](++[B](baseList, newList)) == content[B](baseList)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for concatWithoutDuplicates @580:51:
debug:  => VALID
info Verified: 107 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for concatWithoutDuplicates @573:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for concatWithoutDuplicates @573:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for concatWithoutDuplicates @573:5...
debug: !noDuplicate[B](baseList) || newList.isInstanceOf[Cons] && contains[B](baseList, newList.h) || newList.isInstanceOf[Cons] && !contains[B](baseList, newList.h) || newList.isInstanceOf[Nil]
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for concatWithoutDuplicates @573:5:
debug:  => VALID
info Verified: 108 / 982
debug:  - Checking cache: 'postcondition' VC for concatWithoutDuplicates @573:5...
debug: Cache miss: 'postcondition' VC for concatWithoutDuplicates @573:5...
debug:  - Now solving 'postcondition' VC for concatWithoutDuplicates @573:5...
debug: !noDuplicate[B](baseList) || newList.isInstanceOf[Cons] && contains[B](baseList, newList.h) || newList.isInstanceOf[Cons] && !contains[B](baseList, newList.h) || newList.isInstanceOf[Nil] || {
  val bdg: List[B] = stainless.lang.error[List[B]]("match exhaustiveness")
  noDuplicate[B](bdg) && content[B](++[B](baseList, newList)) == content[B](bdg)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for concatWithoutDuplicates @573:5:
debug:  => VALID
info Verified: 109 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:70...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:70...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:70...
debug: !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:70:
debug:  => VALID
info Verified: 110 / 982
debug:  - Checking cache: 'precond. (call lemmaAddHeadSuffixToPrefixStillPrefix... (require 1/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @?:?...
debug: Cache miss: 'precond. (call lemmaAddHeadSuffixToPrefixStillPrefix... (require 1/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @?:?...
debug:  - Now solving 'precond. (call lemmaAddHeadSuffixToPrefixStillPrefix... (require 1/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @?:?...
debug: !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p.t, bdg) || {
    val bdg: BigInt = size[B](p.t)
    val bdg: BigInt = size[B](bdg)
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaAddHeadSuffixToPrefixStillPrefix... (require 1/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @?:?:
debug:  => VALID
info Verified: 111 / 982
debug:  - Checking cache: 'precond. (call lemmaAddHeadSuffixToPrefixStillPrefix... (require 2/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @?:?...
debug: Cache hit: 'precond. (call lemmaAddHeadSuffixToPrefixStillPrefix... (require 2/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @?:?...
info Verified: 112 / 982
debug:  - Checking cache: 'precond. (call getSuffix[B](l, p) (require 1/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug: Cache miss: 'precond. (call getSuffix[B](l, p) (require 1/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug:  - Now solving 'precond. (call getSuffix[B](l, p) (require 1/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug: !isPrefix[B](p, l) || {
  val bdg: BigInt = size[B](p)
  val bdg: BigInt = size[B](l)
  bdg >= bdg || !p.isInstanceOf[Cons] || {
    val bdg: List[B] = tail[B](l)
    !isPrefix[B](p.t, bdg) || size[B](p.t) >= size[B](bdg) || {
      val bdg: Unit = lemmaAddHeadSuffixToPrefixStillPrefix[B](p.t, bdg)
      assume(isPrefix[B](++[B](p.t, Cons[B](head[B](getSuffix[B](bdg, p.t)), Nil[B]())), bdg))
      bdg >= bdg
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getSuffix[B](l, p) (require 1/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34:
debug:  => VALID
info Verified: 113 / 982
debug:  - Checking cache: 'precond. (call getSuffix[B](l, p) (require 2/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug: Cache miss: 'precond. (call getSuffix[B](l, p) (require 2/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug:  - Now solving 'precond. (call getSuffix[B](l, p) (require 2/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug: !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p.t, bdg) || size[B](p.t) >= size[B](bdg) || {
    val bdg: Unit = lemmaAddHeadSuffixToPrefixStillPrefix[B](p.t, bdg)
    assume(isPrefix[B](++[B](p.t, Cons[B](head[B](getSuffix[B](bdg, p.t)), Nil[B]())), bdg))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getSuffix[B](l, p) (require 2/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34:
debug:  => VALID
info Verified: 114 / 982
debug:  - Checking cache: 'precond. (call head[B](getSuffix[B](l, p)))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug: Cache miss: 'precond. (call head[B](getSuffix[B](l, p)))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug:  - Now solving 'precond. (call head[B](getSuffix[B](l, p)))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug: !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p.t, bdg) || size[B](p.t) >= size[B](bdg) || {
    val bdg: Unit = lemmaAddHeadSuffixToPrefixStillPrefix[B](p.t, bdg)
    assume(isPrefix[B](++[B](p.t, Cons[B](head[B](getSuffix[B](bdg, p.t)), Nil[B]())), bdg))
    getSuffix[B](l, p) != Nil[B]()
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](getSuffix[B](l, p)))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34:
debug:  => VALID
info Verified: 115 / 982
debug:  - Checking cache: 'precond. (call getSuffix[B](l, p) (require 1/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug: Cache miss: 'precond. (call getSuffix[B](l, p) (require 1/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug:  - Now solving 'precond. (call getSuffix[B](l, p) (require 1/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug: !isPrefix[B](p, l) || {
  val bdg: BigInt = size[B](p)
  val bdg: BigInt = size[B](l)
  bdg >= bdg || p.isInstanceOf[Cons] || bdg >= bdg
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getSuffix[B](l, p) (require 1/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34:
debug:  => VALID
info Verified: 116 / 982
debug:  - Checking cache: 'precond. (call getSuffix[B](l, p) (require 2/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug: Cache miss: 'precond. (call getSuffix[B](l, p) (require 2/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug:  - Now solving 'precond. (call getSuffix[B](l, p) (require 2/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug: !isPrefix[B](p, l) || {
  val bdg: BigInt = size[B](p)
  val bdg: BigInt = size[B](l)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getSuffix[B](l, p) (require 2/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34:
debug:  => VALID
info Verified: 117 / 982
debug:  - Checking cache: 'precond. (call head[B](getSuffix[B](l, p)))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug: Cache miss: 'precond. (call head[B](getSuffix[B](l, p)))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug:  - Now solving 'precond. (call head[B](getSuffix[B](l, p)))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug: !isPrefix[B](p, l) || size[B](p) >= size[B](l) || p.isInstanceOf[Cons] || getSuffix[B](l, p) != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](getSuffix[B](l, p)))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34:
debug:  => VALID
info Verified: 118 / 982
debug:  - Checking cache: 'precond. (call getSuffix[B](l, p) (require 1/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug: Cache hit: 'precond. (call getSuffix[B](l, p) (require 1/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
info Verified: 119 / 982
debug:  - Checking cache: 'precond. (call getSuffix[B](l, p) (require 2/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug: Cache hit: 'precond. (call getSuffix[B](l, p) (require 2/2))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
info Verified: 120 / 982
debug:  - Checking cache: 'precond. (call head[B](getSuffix[B](l, p)))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
debug: Cache hit: 'precond. (call head[B](getSuffix[B](l, p)))' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:34...
info Verified: 121 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:57...
debug: Cache miss: 'non-negative measure' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:57...
debug:  - Now solving 'non-negative measure' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:57...
debug: !isPrefix[B](p, l) || size[B](p) >= size[B](l) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaAddHeadSuffixToPrefixStillPrefix @508:57:
debug:  => VALID
info Verified: 122 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaAddHeadSuffixToPrefixStillPrefix' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:28...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaAddHeadSuffixToPrefixStillPrefix' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:28...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaAddHeadSuffixToPrefixStillPrefix' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:28...
debug: !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || isPrefix[B](p.t, tail[B](l))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaAddHeadSuffixToPrefixStillPrefix' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:28:
debug:  => VALID
info Verified: 123 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaAddHeadSuffixToPrefixStillPrefix' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:28...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaAddHeadSuffixToPrefixStillPrefix' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:28...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaAddHeadSuffixToPrefixStillPrefix' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:28...
debug: !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p.t, bdg) || size[B](p.t) < size[B](bdg)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaAddHeadSuffixToPrefixStillPrefix' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:28:
debug:  => VALID
info Verified: 124 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaAddHeadSuffixToPrefixStillPrefix @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaAddHeadSuffixToPrefixStillPrefix @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaAddHeadSuffixToPrefixStillPrefix @?:?...
debug: !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p.t, bdg) || size[B](p.t) >= size[B](bdg) || ListPrimitiveSize[B](bdg) < ListPrimitiveSize[B](l)
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaAddHeadSuffixToPrefixStillPrefix @?:?:
debug:  => VALID
info Verified: 125 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:28...
debug: Cache miss: 'postcondition' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:28...
debug:  - Now solving 'postcondition' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:28...
debug: !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p.t, bdg) || size[B](p.t) >= size[B](bdg) || {
    val bdg: Unit = lemmaAddHeadSuffixToPrefixStillPrefix[B](p.t, bdg)
    assume(isPrefix[B](++[B](p.t, Cons[B](head[B](getSuffix[B](bdg, p.t)), Nil[B]())), bdg))
    isPrefix[B](++[B](p, Cons[B](head[B](getSuffix[B](l, p)), Nil[B]())), l)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaAddHeadSuffixToPrefixStillPrefix @505:28:
debug:  => VALID
info Verified: 126 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaAddHeadSuffixToPrefixStillPrefix @506:28...
debug: Cache miss: 'postcondition' VC for lemmaAddHeadSuffixToPrefixStillPrefix @506:28...
debug:  - Now solving 'postcondition' VC for lemmaAddHeadSuffixToPrefixStillPrefix @506:28...
debug: !isPrefix[B](p, l) || size[B](p) >= size[B](l) || p.isInstanceOf[Cons] || isPrefix[B](++[B](p, Cons[B](head[B](getSuffix[B](l, p)), Nil[B]())), l)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaAddHeadSuffixToPrefixStillPrefix @506:28:
debug:  => VALID
info Verified: 127 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaAddHeadSuffixToPrefixStillPrefix @504:5...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for lemmaAddHeadSuffixToPrefixStillPrefix @504:5...
info Verified: 128 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaAddHeadSuffixToPrefixStillPrefix @504:5...
debug: Cache hit: 'postcondition' VC for lemmaAddHeadSuffixToPrefixStillPrefix @504:5...
info Verified: 129 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsConcatPreserves[B]... (require 1/2))' VC for lemmaForallContainsConcatPreserves @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsConcatPreserves[B]... (require 1/2))' VC for lemmaForallContainsConcatPreserves @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsConcatPreserves[B]... (require 1/2))' VC for lemmaForallContainsConcatPreserves @?:?...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || !forall[B](l2, (b: B) => contains[B](lRef, b)) || l1.isInstanceOf[Nil] || !forall[B](l1.t, (b: B) => contains[B](lRef, b)) || !forall[B](l2, (b: B) => contains[B](lRef, b)) || forall[B](l1.t, (b: B) => contains[B](lRef, b))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsConcatPreserves[B]... (require 1/2))' VC for lemmaForallContainsConcatPreserves @?:?:
debug:  => VALID
info Verified: 130 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsConcatPreserves[B]... (require 2/2))' VC for lemmaForallContainsConcatPreserves @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsConcatPreserves[B]... (require 2/2))' VC for lemmaForallContainsConcatPreserves @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsConcatPreserves[B]... (require 2/2))' VC for lemmaForallContainsConcatPreserves @?:?...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || !forall[B](l2, (b: B) => contains[B](lRef, b)) || l1.isInstanceOf[Nil] || !forall[B](l1.t, (b: B) => contains[B](lRef, b)) || !forall[B](l2, (b: B) => contains[B](lRef, b)) || !forall[B](l1.t, (b: B) => contains[B](lRef, b)) || forall[B](l2, (b: B) => contains[B](lRef, b))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsConcatPreserves[B]... (require 2/2))' VC for lemmaForallContainsConcatPreserves @?:?:
debug:  => VALID
info Verified: 131 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallContainsConcatPreserves @890:16...
debug: Cache miss: 'non-negative measure' VC for lemmaForallContainsConcatPreserves @890:16...
debug:  - Now solving 'non-negative measure' VC for lemmaForallContainsConcatPreserves @890:16...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || !forall[B](l2, (b: B) => contains[B](lRef, b)) || ListPrimitiveSize[B](l1) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaForallContainsConcatPreserves @890:16:
debug:  => VALID
info Verified: 132 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsConcatPreserves @885:21...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsConcatPreserves @885:21...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsConcatPreserves @885:21...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || !forall[B](l2, (b: B) => contains[B](lRef, b)) || !l1.isInstanceOf[Nil] || forall[B](++[B](l1, l2), (b: B) => contains[B](lRef, b))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsConcatPreserves @885:21:
debug:  => VALID
info Verified: 133 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaForallContainsConcatPreserves' VC for lemmaForallContainsConcatPreserves @887:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaForallContainsConcatPreserves' VC for lemmaForallContainsConcatPreserves @887:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaForallContainsConcatPreserves' VC for lemmaForallContainsConcatPreserves @887:9...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || !forall[B](l2, (b: B) => contains[B](lRef, b)) || l1.isInstanceOf[Nil] || forall[B](l1.t, (b: B) => contains[B](lRef, b))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaForallContainsConcatPreserves' VC for lemmaForallContainsConcatPreserves @887:9:
debug:  => VALID
info Verified: 134 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaForallContainsConcatPreserves' VC for lemmaForallContainsConcatPreserves @887:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaForallContainsConcatPreserves' VC for lemmaForallContainsConcatPreserves @887:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaForallContainsConcatPreserves' VC for lemmaForallContainsConcatPreserves @887:9...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || !forall[B](l2, (b: B) => contains[B](lRef, b)) || l1.isInstanceOf[Nil] || !forall[B](l1.t, (b: B) => contains[B](lRef, b)) || forall[B](l2, (b: B) => contains[B](lRef, b))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaForallContainsConcatPreserves' VC for lemmaForallContainsConcatPreserves @887:9:
debug:  => VALID
info Verified: 135 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallContainsConcatPreserves @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaForallContainsConcatPreserves @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaForallContainsConcatPreserves @?:?...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || !forall[B](l2, (b: B) => contains[B](lRef, b)) || l1.isInstanceOf[Nil] || !forall[B](l1.t, (b: B) => contains[B](lRef, b)) || !forall[B](l2, (b: B) => contains[B](lRef, b)) || ListPrimitiveSize[B](l1.t) < ListPrimitiveSize[B](l1)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallContainsConcatPreserves @?:?:
debug:  => VALID
info Verified: 136 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsConcatPreserves @887:9...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsConcatPreserves @887:9...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsConcatPreserves @887:9...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || !forall[B](l2, (b: B) => contains[B](lRef, b)) || l1.isInstanceOf[Nil] || !forall[B](l1.t, (b: B) => contains[B](lRef, b)) || !forall[B](l2, (b: B) => contains[B](lRef, b)) || {
  val bdg: Unit = lemmaForallContainsConcatPreserves[B](l1.t, l2, lRef)
  assume(forall[B](++[B](l1.t, l2), (b: B) => contains[B](lRef, b)))
  forall[B](++[B](l1, l2), (b: B) => contains[B](lRef, b))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsConcatPreserves @887:9:
debug:  => VALID
info Verified: 137 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallContainsConcatPreserves @884:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaForallContainsConcatPreserves @884:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaForallContainsConcatPreserves @884:5...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || {
  val bdg: Boolean = forall[B](l2, (b: B) => contains[B](lRef, b))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaForallContainsConcatPreserves @884:5:
debug:  => VALID
info Verified: 138 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsConcatPreserves @884:5...
debug: Cache hit: 'postcondition' VC for lemmaForallContainsConcatPreserves @884:5...
info Verified: 139 / 982
debug:  - Checking cache: 'postcondition' VC for noDuplicateConcatNotContainedPreserves @1018:7...
debug: Cache miss: 'postcondition' VC for noDuplicateConcatNotContainedPreserves @1018:7...
debug:  - Now solving 'postcondition' VC for noDuplicateConcatNotContainedPreserves @1018:7...
debug: !noDuplicate[B](l) || contains[B](l, b) || noDuplicate[B](Cons[B](b, l))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for noDuplicateConcatNotContainedPreserves @1018:7:
debug:  => VALID
info Verified: 140 / 982
debug:  - Checking cache: 'precond. (call lemmaListNotContainsThenFilterContain... (require 1/2))' VC for lemmaListNotContainsThenFilterContainsEmpty @?:?...
debug: Cache miss: 'precond. (call lemmaListNotContainsThenFilterContain... (require 1/2))' VC for lemmaListNotContainsThenFilterContainsEmpty @?:?...
debug:  - Now solving 'precond. (call lemmaListNotContainsThenFilterContain... (require 1/2))' VC for lemmaListNotContainsThenFilterContainsEmpty @?:?...
debug: contains[B](l1, b) || l2 != Cons[B](b, Nil[B]()) || !l1.isInstanceOf[Cons] || {
  val bdg: Boolean = contains[B](l1.t, b)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaListNotContainsThenFilterContain... (require 1/2))' VC for lemmaListNotContainsThenFilterContainsEmpty @?:?:
debug:  => VALID
info Verified: 141 / 982
debug:  - Checking cache: 'precond. (call lemmaListNotContainsThenFilterContain... (require 2/2))' VC for lemmaListNotContainsThenFilterContainsEmpty @?:?...
debug: Cache hit: 'precond. (call lemmaListNotContainsThenFilterContain... (require 2/2))' VC for lemmaListNotContainsThenFilterContainsEmpty @?:?...
info Verified: 142 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaListNotContainsThenFilterContainsEmpty @1167:15...
debug: Cache miss: 'non-negative measure' VC for lemmaListNotContainsThenFilterContainsEmpty @1167:15...
debug:  - Now solving 'non-negative measure' VC for lemmaListNotContainsThenFilterContainsEmpty @1167:15...
debug: contains[B](l1, b) || l2 != Cons[B](b, Nil[B]()) || size[B](l1) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaListNotContainsThenFilterContainsEmpty @1167:15:
debug:  => VALID
info Verified: 143 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaListNotContainsThenFilterContainsEmpty' VC for lemmaListNotContainsThenFilterContainsEmpty @1170:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaListNotContainsThenFilterContainsEmpty' VC for lemmaListNotContainsThenFilterContainsEmpty @1170:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaListNotContainsThenFilterContainsEmpty' VC for lemmaListNotContainsThenFilterContainsEmpty @1170:9...
debug: contains[B](l1, b) || l2 != Cons[B](b, Nil[B]()) || !l1.isInstanceOf[Cons] || !contains[B](l1.t, b)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaListNotContainsThenFilterContainsEmpty' VC for lemmaListNotContainsThenFilterContainsEmpty @1170:9:
debug:  => VALID
info Verified: 144 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaListNotContainsThenFilterContainsEmpty' VC for lemmaListNotContainsThenFilterContainsEmpty @1170:9...
debug: Cache hit: 'body assertion: Inlined precondition (2/2) of lemmaListNotContainsThenFilterContainsEmpty' VC for lemmaListNotContainsThenFilterContainsEmpty @1170:9...
info Verified: 145 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaListNotContainsThenFilterContainsEmpty @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaListNotContainsThenFilterContainsEmpty @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaListNotContainsThenFilterContainsEmpty @?:?...
debug: contains[B](l1, b) || l2 != Cons[B](b, Nil[B]()) || !l1.isInstanceOf[Cons] || contains[B](l1.t, b) || size[B](l1.t) < size[B](l1)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaListNotContainsThenFilterContainsEmpty @?:?:
debug:  => VALID
info Verified: 146 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaListNotContainsThenFilterContainsEmpty @1170:9...
debug: Cache miss: 'postcondition' VC for lemmaListNotContainsThenFilterContainsEmpty @1170:9...
debug:  - Now solving 'postcondition' VC for lemmaListNotContainsThenFilterContainsEmpty @1170:9...
debug: contains[B](l1, b) || l2 != Cons[B](b, Nil[B]()) || !l1.isInstanceOf[Cons] || contains[B](l1.t, b) || {
  val bdg: Unit = lemmaListNotContainsThenFilterContainsEmpty[B](l1.t, l2, b)
  assume(isEmpty[B](filter[B](l1.t, (e: B) => contains[B](l2, e))))
  isEmpty[B](filter[B](l1, (e: B) => contains[B](l2, e)))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaListNotContainsThenFilterContainsEmpty @1170:9:
debug:  => VALID
info Verified: 147 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaListNotContainsThenFilterContainsEmpty @1172:21...
debug: Cache miss: 'postcondition' VC for lemmaListNotContainsThenFilterContainsEmpty @1172:21...
debug:  - Now solving 'postcondition' VC for lemmaListNotContainsThenFilterContainsEmpty @1172:21...
debug: contains[B](l1, b) || l2 != Cons[B](b, Nil[B]()) || l1.isInstanceOf[Cons] || isEmpty[B](filter[B](l1, (e: B) => contains[B](l2, e)))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaListNotContainsThenFilterContainsEmpty @1172:21:
debug:  => VALID
info Verified: 148 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaListNotContainsThenFilterContainsEmpty @1168:5...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for lemmaListNotContainsThenFilterContainsEmpty @1168:5...
info Verified: 149 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaListNotContainsThenFilterContainsEmpty @1168:5...
debug: Cache hit: 'postcondition' VC for lemmaListNotContainsThenFilterContainsEmpty @1168:5...
info Verified: 150 / 982
debug:  - Checking cache: 'precond. (call tail[B](tot))' VC for lemmaConcatAssociativity @321:67...
debug: Cache miss: 'precond. (call tail[B](tot))' VC for lemmaConcatAssociativity @321:67...
debug:  - Now solving 'precond. (call tail[B](tot))' VC for lemmaConcatAssociativity @321:67...
debug: ++[B](++[B](l1, Cons[B](elmt, Nil[B]())), l2) != tot || !l1.isInstanceOf[Cons] || tot != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](tot))' VC for lemmaConcatAssociativity @321:67:
debug:  => VALID
info Verified: 151 / 982
debug:  - Checking cache: 'precond. (call lemmaConcatAssociativity[B](l1, elmt,...)' VC for lemmaConcatAssociativity @?:?...
debug: Cache miss: 'precond. (call lemmaConcatAssociativity[B](l1, elmt,...)' VC for lemmaConcatAssociativity @?:?...
debug:  - Now solving 'precond. (call lemmaConcatAssociativity[B](l1, elmt,...)' VC for lemmaConcatAssociativity @?:?...
debug: val bdg: List[B] = Cons[B](elmt, Nil[B]())
++[B](++[B](l1, bdg), l2) != tot || !l1.isInstanceOf[Cons] || {
  val bdg: List[B] = ++[B](++[B](l1.t, bdg), l2)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaConcatAssociativity[B](l1, elmt,...)' VC for lemmaConcatAssociativity @?:?:
debug:  => VALID
info Verified: 152 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaConcatAssociativity @319:12...
debug: Cache miss: 'body assertion' VC for lemmaConcatAssociativity @319:12...
debug:  - Now solving 'body assertion' VC for lemmaConcatAssociativity @319:12...
debug: val bdg: List[B] = ++[B](++[B](l1, Cons[B](elmt, Nil[B]())), l2)
true
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaConcatAssociativity @319:12:
debug:  => VALID
info Verified: 153 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaConcatAssociativity @324:15...
debug: Cache miss: 'non-negative measure' VC for lemmaConcatAssociativity @324:15...
debug:  - Now solving 'non-negative measure' VC for lemmaConcatAssociativity @324:15...
debug: ++[B](++[B](l1, Cons[B](elmt, Nil[B]())), l2) != tot || ListPrimitiveSize[B](l1) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaConcatAssociativity @324:15:
debug:  => VALID
info Verified: 154 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaConcatAssociativity' VC for lemmaConcatAssociativity @321:28...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaConcatAssociativity' VC for lemmaConcatAssociativity @321:28...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaConcatAssociativity' VC for lemmaConcatAssociativity @321:28...
debug: val bdg: List[B] = Cons[B](elmt, Nil[B]())
++[B](++[B](l1, bdg), l2) != tot || !l1.isInstanceOf[Cons] || ++[B](++[B](l1.t, bdg), l2) == tail[B](tot)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaConcatAssociativity' VC for lemmaConcatAssociativity @321:28:
debug:  => VALID
info Verified: 155 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaConcatAssociativity @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaConcatAssociativity @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaConcatAssociativity @?:?...
debug: val bdg: List[B] = Cons[B](elmt, Nil[B]())
++[B](++[B](l1, bdg), l2) != tot || !l1.isInstanceOf[Cons] || ++[B](++[B](l1.t, bdg), l2) != tail[B](tot) || ListPrimitiveSize[B](l1.t) < ListPrimitiveSize[B](l1)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaConcatAssociativity @?:?:
debug:  => VALID
info Verified: 156 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatAssociativity @321:28...
debug: Cache miss: 'postcondition' VC for lemmaConcatAssociativity @321:28...
debug:  - Now solving 'postcondition' VC for lemmaConcatAssociativity @321:28...
debug: val bdg: List[B] = Cons[B](elmt, Nil[B]())
++[B](++[B](l1, bdg), l2) != tot || !l1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](tot)
  ++[B](++[B](l1.t, bdg), l2) != bdg || {
    val bdg: Unit = lemmaConcatAssociativity[B](l1.t, elmt, l2, bdg)
    val bdg: List[B] = ++[B](bdg, l2)
    assume(++[B](l1.t, bdg) == bdg)
    ++[B](l1, bdg) == tot
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaConcatAssociativity @321:28:
debug:  => VALID
info Verified: 157 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatAssociativity @322:28...
debug: Cache miss: 'postcondition' VC for lemmaConcatAssociativity @322:28...
debug:  - Now solving 'postcondition' VC for lemmaConcatAssociativity @322:28...
debug: val bdg: List[B] = Cons[B](elmt, Nil[B]())
++[B](++[B](l1, bdg), l2) != tot || l1.isInstanceOf[Cons] || ++[B](l1, ++[B](bdg, l2)) == tot
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaConcatAssociativity @322:28:
debug:  => VALID
info Verified: 158 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaConcatAssociativity @320:5...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for lemmaConcatAssociativity @320:5...
info Verified: 159 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatAssociativity @320:5...
debug: Cache hit: 'postcondition' VC for lemmaConcatAssociativity @320:5...
info Verified: 160 / 982
debug:  - Checking cache: 'precond. (call lemmaConsecutiveSubseqThenSubseq[B](l...)' VC for lemmaConsecutiveSubseqThenSubseq @?:?...
debug: Cache miss: 'precond. (call lemmaConsecutiveSubseqThenSubseq[B](l...)' VC for lemmaConsecutiveSubseqThenSubseq @?:?...
debug:  - Now solving 'precond. (call lemmaConsecutiveSubseqThenSubseq[B](l...)' VC for lemmaConsecutiveSubseqThenSubseq @?:?...
debug: !consecutiveSubseq[B](l1, l2) || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !consecutiveSubseqAtHead[B](l1, l2) || {
  val bdg: Boolean = consecutiveSubseq[B](l1.t, l2.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaConsecutiveSubseqThenSubseq[B](l...)' VC for lemmaConsecutiveSubseqThenSubseq @?:?:
debug:  => VALID
info Verified: 161 / 982
debug:  - Checking cache: 'precond. (call lemmaConsecutiveSubseqThenSubseq[B](l...)' VC for lemmaConsecutiveSubseqThenSubseq @?:?...
debug: Cache miss: 'precond. (call lemmaConsecutiveSubseqThenSubseq[B](l...)' VC for lemmaConsecutiveSubseqThenSubseq @?:?...
debug:  - Now solving 'precond. (call lemmaConsecutiveSubseqThenSubseq[B](l...)' VC for lemmaConsecutiveSubseqThenSubseq @?:?...
debug: !consecutiveSubseq[B](l1, l2) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && consecutiveSubseqAtHead[B](l1, l2) || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || {
  val bdg: Boolean = consecutiveSubseq[B](l1, l2.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaConsecutiveSubseqThenSubseq[B](l...)' VC for lemmaConsecutiveSubseqThenSubseq @?:?:
debug:  => VALID
info Verified: 162 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaConsecutiveSubseqThenSubseq @167:15...
debug: Cache miss: 'non-negative measure' VC for lemmaConsecutiveSubseqThenSubseq @167:15...
debug:  - Now solving 'non-negative measure' VC for lemmaConsecutiveSubseqThenSubseq @167:15...
debug: !consecutiveSubseq[B](l1, l2) || size[B](l1) + size[B](l2) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaConsecutiveSubseqThenSubseq @167:15:
debug:  => VALID
info Verified: 163 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaConsecutiveSubseqThenSubseq' VC for lemmaConsecutiveSubseqThenSubseq @170:9...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaConsecutiveSubseqThenSubseq' VC for lemmaConsecutiveSubseqThenSubseq @170:9...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaConsecutiveSubseqThenSubseq' VC for lemmaConsecutiveSubseqThenSubseq @170:9...
debug: !consecutiveSubseq[B](l1, l2) || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !consecutiveSubseqAtHead[B](l1, l2) || consecutiveSubseq[B](l1.t, l2.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaConsecutiveSubseqThenSubseq' VC for lemmaConsecutiveSubseqThenSubseq @170:9:
debug:  => VALID
info Verified: 164 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaConsecutiveSubseqThenSubseq @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaConsecutiveSubseqThenSubseq @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaConsecutiveSubseqThenSubseq @?:?...
debug: !consecutiveSubseq[B](l1, l2) || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !consecutiveSubseqAtHead[B](l1, l2) || !consecutiveSubseq[B](l1.t, l2.t) || size[B](l1.t) + size[B](l2.t) < size[B](l1) + size[B](l2)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaConsecutiveSubseqThenSubseq @?:?:
debug:  => VALID
info Verified: 165 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConsecutiveSubseqThenSubseq @170:9...
debug: Cache miss: 'postcondition' VC for lemmaConsecutiveSubseqThenSubseq @170:9...
debug:  - Now solving 'postcondition' VC for lemmaConsecutiveSubseqThenSubseq @170:9...
debug: !consecutiveSubseq[B](l1, l2) || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !consecutiveSubseqAtHead[B](l1, l2) || !consecutiveSubseq[B](l1.t, l2.t) || {
  val bdg: Unit = lemmaConsecutiveSubseqThenSubseq[B](l1.t, l2.t)
  assume(subseq[B](l1.t, l2.t))
  subseq[B](l1, l2)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaConsecutiveSubseqThenSubseq @170:9:
debug:  => VALID
info Verified: 166 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaConsecutiveSubseqThenSubseq' VC for lemmaConsecutiveSubseqThenSubseq @172:9...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaConsecutiveSubseqThenSubseq' VC for lemmaConsecutiveSubseqThenSubseq @172:9...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaConsecutiveSubseqThenSubseq' VC for lemmaConsecutiveSubseqThenSubseq @172:9...
debug: !consecutiveSubseq[B](l1, l2) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && consecutiveSubseqAtHead[B](l1, l2) || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || consecutiveSubseq[B](l1, l2.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaConsecutiveSubseqThenSubseq' VC for lemmaConsecutiveSubseqThenSubseq @172:9:
debug:  => VALID
info Verified: 167 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaConsecutiveSubseqThenSubseq @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaConsecutiveSubseqThenSubseq @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaConsecutiveSubseqThenSubseq @?:?...
debug: !consecutiveSubseq[B](l1, l2) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && consecutiveSubseqAtHead[B](l1, l2) || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !consecutiveSubseq[B](l1, l2.t) || {
  val bdg: BigInt = size[B](l1)
  bdg + size[B](l2.t) < bdg + size[B](l2)
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaConsecutiveSubseqThenSubseq @?:?:
debug:  => VALID
info Verified: 168 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConsecutiveSubseqThenSubseq @172:9...
debug: Cache miss: 'postcondition' VC for lemmaConsecutiveSubseqThenSubseq @172:9...
debug:  - Now solving 'postcondition' VC for lemmaConsecutiveSubseqThenSubseq @172:9...
debug: !consecutiveSubseq[B](l1, l2) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && consecutiveSubseqAtHead[B](l1, l2) || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !consecutiveSubseq[B](l1, l2.t) || {
  val bdg: Unit = lemmaConsecutiveSubseqThenSubseq[B](l1, l2.t)
  assume(subseq[B](l1, l2.t))
  subseq[B](l1, l2)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaConsecutiveSubseqThenSubseq @172:9:
debug:  => VALID
info Verified: 169 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConsecutiveSubseqThenSubseq @173:17...
debug: Cache miss: 'postcondition' VC for lemmaConsecutiveSubseqThenSubseq @173:17...
debug:  - Now solving 'postcondition' VC for lemmaConsecutiveSubseqThenSubseq @173:17...
debug: !consecutiveSubseq[B](l1, l2) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && consecutiveSubseqAtHead[B](l1, l2) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] || subseq[B](l1, l2)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaConsecutiveSubseqThenSubseq @173:17:
debug:  => VALID
info Verified: 170 / 982
debug:  - Checking cache: 'precond. (call notContainsAddNotEqThenNotContains[B]... (require 1/2))' VC for notContainsAddNotEqThenNotContains @?:?...
debug: Cache miss: 'precond. (call notContainsAddNotEqThenNotContains[B]... (require 1/2))' VC for notContainsAddNotEqThenNotContains @?:?...
debug:  - Now solving 'precond. (call notContainsAddNotEqThenNotContains[B]... (require 1/2))' VC for notContainsAddNotEqThenNotContains @?:?...
debug: contains[B](l, b) || b == diffB || !l.isInstanceOf[Cons] || !contains[B](l.t, b)
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call notContainsAddNotEqThenNotContains[B]... (require 1/2))' VC for notContainsAddNotEqThenNotContains @?:?:
debug:  => VALID
info Verified: 171 / 982
debug:  - Checking cache: 'precond. (call notContainsAddNotEqThenNotContains[B]... (require 2/2))' VC for notContainsAddNotEqThenNotContains @?:?...
debug: Cache miss: 'precond. (call notContainsAddNotEqThenNotContains[B]... (require 2/2))' VC for notContainsAddNotEqThenNotContains @?:?...
debug:  - Now solving 'precond. (call notContainsAddNotEqThenNotContains[B]... (require 2/2))' VC for notContainsAddNotEqThenNotContains @?:?...
debug: contains[B](l, b) || b == diffB || !l.isInstanceOf[Cons] || {
  val bdg: Boolean = contains[B](l.t, b)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call notContainsAddNotEqThenNotContains[B]... (require 2/2))' VC for notContainsAddNotEqThenNotContains @?:?:
debug:  => VALID
info Verified: 172 / 982
debug:  - Checking cache: 'non-negative measure' VC for notContainsAddNotEqThenNotContains @1127:15...
debug: Cache miss: 'non-negative measure' VC for notContainsAddNotEqThenNotContains @1127:15...
debug:  - Now solving 'non-negative measure' VC for notContainsAddNotEqThenNotContains @1127:15...
debug: contains[B](l, b) || b == diffB || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for notContainsAddNotEqThenNotContains @1127:15:
debug:  => VALID
info Verified: 173 / 982
debug:  - Checking cache: 'measure decreases' VC for notContainsAddNotEqThenNotContains @?:?...
debug: Cache miss: 'measure decreases' VC for notContainsAddNotEqThenNotContains @?:?...
debug:  - Now solving 'measure decreases' VC for notContainsAddNotEqThenNotContains @?:?...
debug: contains[B](l, b) || b == diffB || !l.isInstanceOf[Cons] || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for notContainsAddNotEqThenNotContains @?:?:
debug:  => VALID
info Verified: 174 / 982
debug:  - Checking cache: 'postcondition' VC for notContainsAddNotEqThenNotContains @?:?...
debug: Cache miss: 'postcondition' VC for notContainsAddNotEqThenNotContains @?:?...
debug:  - Now solving 'postcondition' VC for notContainsAddNotEqThenNotContains @?:?...
debug: contains[B](l, b) || b == diffB || !l.isInstanceOf[Cons] || {
  val bdg: Unit = notContainsAddNotEqThenNotContains[B](l.t, b, diffB)
  !contains[B](Cons[B](diffB, l), b)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for notContainsAddNotEqThenNotContains @?:?:
debug:  => VALID
info Verified: 175 / 982
debug:  - Checking cache: 'postcondition' VC for notContainsAddNotEqThenNotContains @?:?...
debug: Cache miss: 'postcondition' VC for notContainsAddNotEqThenNotContains @?:?...
debug:  - Now solving 'postcondition' VC for notContainsAddNotEqThenNotContains @?:?...
debug: contains[B](l, b) || b == diffB || l.isInstanceOf[Cons] || !contains[B](Cons[B](diffB, l), b)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for notContainsAddNotEqThenNotContains @?:?:
debug:  => VALID
info Verified: 176 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for notContainsAddNotEqThenNotContains @?:?...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for notContainsAddNotEqThenNotContains @?:?...
info Verified: 177 / 982
debug:  - Checking cache: 'postcondition' VC for notContainsAddNotEqThenNotContains @?:?...
debug: Cache hit: 'postcondition' VC for notContainsAddNotEqThenNotContains @?:?...
info Verified: 178 / 982
debug:  - Checking cache: 'precond. (call tail[B](p2))' VC for lemmaSamePrefixThenSameSuffix @479:47...
debug: Cache miss: 'precond. (call tail[B](p2))' VC for lemmaSamePrefixThenSameSuffix @479:47...
debug:  - Now solving 'precond. (call tail[B](p2))' VC for lemmaSamePrefixThenSameSuffix @479:47...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || ++[B](p1, s1) != l || ++[B](p2, s2) != l || p1 != p2 || !p1.isInstanceOf[Cons] || p2 != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](p2))' VC for lemmaSamePrefixThenSameSuffix @479:47:
debug:  => VALID
info Verified: 179 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaSamePrefixThenSameSuffix @479:60...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaSamePrefixThenSameSuffix @479:60...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaSamePrefixThenSameSuffix @479:60...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || ++[B](p1, s1) != l || ++[B](p2, s2) != l || p1 != p2 || !p1.isInstanceOf[Cons] || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaSamePrefixThenSameSuffix @479:60:
debug:  => VALID
info Verified: 180 / 982
debug:  - Checking cache: 'precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 1/5))' VC for lemmaSamePrefixThenSameSuffix @?:?...
debug: Cache miss: 'precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 1/5))' VC for lemmaSamePrefixThenSameSuffix @?:?...
debug:  - Now solving 'precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 1/5))' VC for lemmaSamePrefixThenSameSuffix @?:?...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || ++[B](p1, s1) != l || ++[B](p2, s2) != l || p1 != p2 || !p1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](p2)
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p1.t, bdg) || !isPrefix[B](bdg, bdg) || ++[B](p1.t, s1) != bdg || {
    val bdg: List[B] = ++[B](bdg, s2)
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 1/5))' VC for lemmaSamePrefixThenSameSuffix @?:?:
debug:  => VALID
info Verified: 181 / 982
debug:  - Checking cache: 'precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 2/5))' VC for lemmaSamePrefixThenSameSuffix @?:?...
debug: Cache hit: 'precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 2/5))' VC for lemmaSamePrefixThenSameSuffix @?:?...
info Verified: 182 / 982
debug:  - Checking cache: 'precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 3/5))' VC for lemmaSamePrefixThenSameSuffix @?:?...
debug: Cache hit: 'precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 3/5))' VC for lemmaSamePrefixThenSameSuffix @?:?...
info Verified: 183 / 982
debug:  - Checking cache: 'precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 4/5))' VC for lemmaSamePrefixThenSameSuffix @?:?...
debug: Cache hit: 'precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 4/5))' VC for lemmaSamePrefixThenSameSuffix @?:?...
info Verified: 184 / 982
debug:  - Checking cache: 'precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 5/5))' VC for lemmaSamePrefixThenSameSuffix @?:?...
debug: Cache hit: 'precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 5/5))' VC for lemmaSamePrefixThenSameSuffix @?:?...
info Verified: 185 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaSamePrefixThenSameSuffix @479:60...
debug: Cache miss: 'non-negative measure' VC for lemmaSamePrefixThenSameSuffix @479:60...
debug:  - Now solving 'non-negative measure' VC for lemmaSamePrefixThenSameSuffix @479:60...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || ++[B](p1, s1) != l || ++[B](p2, s2) != l || p1 != p2 || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaSamePrefixThenSameSuffix @479:60:
debug:  => VALID
info Verified: 186 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || ++[B](p1, s1) != l || ++[B](p2, s2) != l || p1 != p2 || !p1.isInstanceOf[Cons] || isPrefix[B](p1.t, tail[B](l))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9:
debug:  => VALID
info Verified: 187 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || ++[B](p1, s1) != l || ++[B](p2, s2) != l || p1 != p2 || !p1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p1.t, bdg) || isPrefix[B](tail[B](p2), bdg)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9:
debug:  => VALID
info Verified: 188 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (3/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug: Cache miss: 'body assertion: Inlined precondition (3/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug:  - Now solving 'body assertion: Inlined precondition (3/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || ++[B](p1, s1) != l || ++[B](p2, s2) != l || p1 != p2 || !p1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p1.t, bdg) || !isPrefix[B](tail[B](p2), bdg) || ++[B](p1.t, s1) == bdg
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (3/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9:
debug:  => VALID
info Verified: 189 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (4/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug: Cache miss: 'body assertion: Inlined precondition (4/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug:  - Now solving 'body assertion: Inlined precondition (4/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || ++[B](p1, s1) != l || ++[B](p2, s2) != l || p1 != p2 || !p1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](p2)
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p1.t, bdg) || !isPrefix[B](bdg, bdg) || ++[B](p1.t, s1) != bdg || ++[B](bdg, s2) == bdg
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (4/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9:
debug:  => VALID
info Verified: 190 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (5/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug: Cache miss: 'body assertion: Inlined precondition (5/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug:  - Now solving 'body assertion: Inlined precondition (5/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || ++[B](p1, s1) != l || ++[B](p2, s2) != l || p1 != p2 || !p1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](p2)
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p1.t, bdg) || !isPrefix[B](bdg, bdg) || ++[B](p1.t, s1) != bdg || ++[B](bdg, s2) != bdg || p1.t == bdg
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (5/5) of lemmaSamePrefixThenSameSuffix' VC for lemmaSamePrefixThenSameSuffix @479:9:
debug:  => VALID
info Verified: 191 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSamePrefixThenSameSuffix @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSamePrefixThenSameSuffix @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSamePrefixThenSameSuffix @?:?...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || ++[B](p1, s1) != l || ++[B](p2, s2) != l || p1 != p2 || !p1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](p2)
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p1.t, bdg) || !isPrefix[B](bdg, bdg) || ++[B](p1.t, s1) != bdg || ++[B](bdg, s2) != bdg || p1.t != bdg || ListPrimitiveSize[B](bdg) < ListPrimitiveSize[B](l)
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSamePrefixThenSameSuffix @?:?:
debug:  => VALID
info Verified: 192 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug: Cache miss: 'postcondition' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug:  - Now solving 'postcondition' VC for lemmaSamePrefixThenSameSuffix @479:9...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || ++[B](p1, s1) != l || ++[B](p2, s2) != l || p1 != p2 || !p1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](p2)
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p1.t, bdg) || !isPrefix[B](bdg, bdg) || ++[B](p1.t, s1) != bdg || ++[B](bdg, s2) != bdg || p1.t != bdg || {
    val bdg: Unit = lemmaSamePrefixThenSameSuffix[B](p1.t, s1, bdg, s2, bdg)
    assume(s1 == s2)
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSamePrefixThenSameSuffix @479:9:
debug:  => VALID
info Verified: 193 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSamePrefixThenSameSuffix @480:21...
debug: Cache miss: 'postcondition' VC for lemmaSamePrefixThenSameSuffix @480:21...
debug:  - Now solving 'postcondition' VC for lemmaSamePrefixThenSameSuffix @480:21...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || ++[B](p1, s1) != l || ++[B](p2, s2) != l || p1 != p2 || p1.isInstanceOf[Cons] || s1 == s2
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSamePrefixThenSameSuffix @480:21:
debug:  => VALID
info Verified: 194 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaSamePrefixThenSameSuffix @477:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaSamePrefixThenSameSuffix @477:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaSamePrefixThenSameSuffix @477:5...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || ++[B](p1, s1) != l || {
  val bdg: List[B] = ++[B](p2, s2)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaSamePrefixThenSameSuffix @477:5:
debug:  => VALID
info Verified: 195 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSamePrefixThenSameSuffix @477:5...
debug: Cache hit: 'postcondition' VC for lemmaSamePrefixThenSameSuffix @477:5...
info Verified: 196 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainedNoDupThenConca... (require 1/3))' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainedNoDupThenConca... (require 1/3))' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainedNoDupThenConca... (require 1/3))' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?...
debug: !forall[B](l1, (b: B) => !contains[B](l2, b)) || !noDuplicate[B](l1) || !noDuplicate[B](l2) || !l1.isInstanceOf[Cons] || forall[B](l1.t, (b: B) => !contains[B](l2, b))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainedNoDupThenConca... (require 1/3))' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?:
debug:  => VALID
info Verified: 197 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainedNoDupThenConca... (require 2/3))' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainedNoDupThenConca... (require 2/3))' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainedNoDupThenConca... (require 2/3))' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?...
debug: !forall[B](l1, (b: B) => !contains[B](l2, b)) || !noDuplicate[B](l1) || !noDuplicate[B](l2) || !l1.isInstanceOf[Cons] || !forall[B](l1.t, (b: B) => !contains[B](l2, b)) || noDuplicate[B](l1.t)
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainedNoDupThenConca... (require 2/3))' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?:
debug:  => VALID
info Verified: 198 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainedNoDupThenConca... (require 3/3))' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainedNoDupThenConca... (require 3/3))' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainedNoDupThenConca... (require 3/3))' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?...
debug: !forall[B](l1, (b: B) => !contains[B](l2, b)) || !noDuplicate[B](l1) || !noDuplicate[B](l2) || !l1.isInstanceOf[Cons] || !forall[B](l1.t, (b: B) => !contains[B](l2, b)) || {
  val bdg: Boolean = noDuplicate[B](l1.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainedNoDupThenConca... (require 3/3))' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?:
debug:  => VALID
info Verified: 199 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallNotContainedNoDupThenConcatNoDup @976:62...
debug: Cache miss: 'non-negative measure' VC for lemmaForallNotContainedNoDupThenConcatNoDup @976:62...
debug:  - Now solving 'non-negative measure' VC for lemmaForallNotContainedNoDupThenConcatNoDup @976:62...
debug: !forall[B](l1, (b: B) => !contains[B](l2, b)) || !noDuplicate[B](l1) || !noDuplicate[B](l2) || ListPrimitiveSize[B](l1) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaForallNotContainedNoDupThenConcatNoDup @976:62:
debug:  => VALID
info Verified: 200 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?...
debug: !forall[B](l1, (b: B) => !contains[B](l2, b)) || !noDuplicate[B](l1) || !noDuplicate[B](l2) || !l1.isInstanceOf[Cons] || ListPrimitiveSize[B](l1.t) < ListPrimitiveSize[B](l1)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?:
debug:  => VALID
info Verified: 201 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainedNoDupThenConcatNoDup @981:15...
debug: Cache miss: 'postcondition' VC for lemmaForallNotContainedNoDupThenConcatNoDup @981:15...
debug:  - Now solving 'postcondition' VC for lemmaForallNotContainedNoDupThenConcatNoDup @981:15...
debug: !forall[B](l1, (b: B) => !contains[B](l2, b)) || !noDuplicate[B](l1) || !noDuplicate[B](l2) || !l1.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaForallNotContainedNoDupThenConcatNoDup[B](l1.t, l2)
  noDuplicate[B](++[B](l1, l2))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallNotContainedNoDupThenConcatNoDup @981:15:
debug:  => VALID
info Verified: 202 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainedNoDupThenConcatNoDup @981:15...
debug: Cache miss: 'postcondition' VC for lemmaForallNotContainedNoDupThenConcatNoDup @981:15...
debug:  - Now solving 'postcondition' VC for lemmaForallNotContainedNoDupThenConcatNoDup @981:15...
debug: !forall[B](l1, (b: B) => !contains[B](l2, b)) || !noDuplicate[B](l1) || !noDuplicate[B](l2) || l1.isInstanceOf[Cons] || noDuplicate[B](++[B](l1, l2))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallNotContainedNoDupThenConcatNoDup @981:15:
debug:  => VALID
info Verified: 203 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?...
debug: !forall[B](l1, (b: B) => !contains[B](l2, b)) || !noDuplicate[B](l1) || {
  val bdg: Boolean = noDuplicate[B](l2)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaForallNotContainedNoDupThenConcatNoDup @?:?:
debug:  => VALID
info Verified: 204 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainedNoDupThenConcatNoDup @981:15...
debug: Cache hit: 'postcondition' VC for lemmaForallNotContainedNoDupThenConcatNoDup @981:15...
info Verified: 205 / 982
debug:  - Checking cache: 'precond. (call getIndex[B](l, e1))' VC for lemmaSameIndexThenSameElement @221:13...
debug: Cache hit: 'precond. (call getIndex[B](l, e1))' VC for lemmaSameIndexThenSameElement @221:13...
info Verified: 206 / 982
debug:  - Checking cache: 'precond. (call getIndex[B](l, e2))' VC for lemmaSameIndexThenSameElement @221:32...
debug: Cache hit: 'precond. (call getIndex[B](l, e2))' VC for lemmaSameIndexThenSameElement @221:32...
info Verified: 207 / 982
debug:  - Checking cache: 'precond. (call getIndex[B](l, e1))' VC for lemmaSameIndexThenSameElement @224:9...
debug: Cache miss: 'precond. (call getIndex[B](l, e1))' VC for lemmaSameIndexThenSameElement @224:9...
debug:  - Now solving 'precond. (call getIndex[B](l, e1))' VC for lemmaSameIndexThenSameElement @224:9...
debug: !contains[B](l, e1) || !contains[B](l, e2) || {
  val bdg: BigInt = getIndex[B](l, e1)
  val bdg: BigInt = getIndex[B](l, e2)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getIndex[B](l, e1))' VC for lemmaSameIndexThenSameElement @224:9:
debug:  => VALID
info Verified: 208 / 982
debug:  - Checking cache: 'precond. (call head[B](l))' VC for lemmaSameIndexThenSameElement @225:14...
debug: Cache miss: 'precond. (call head[B](l))' VC for lemmaSameIndexThenSameElement @225:14...
debug:  - Now solving 'precond. (call head[B](l))' VC for lemmaSameIndexThenSameElement @225:14...
debug: !contains[B](l, e1) || !contains[B](l, e2) || {
  val bdg: BigInt = getIndex[B](l, e1)
  bdg != getIndex[B](l, e2) || bdg != BigInt("0") || l != Nil[B]()
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](l))' VC for lemmaSameIndexThenSameElement @225:14:
debug:  => VALID
info Verified: 209 / 982
debug:  - Checking cache: 'precond. (call head[B](l))' VC for lemmaSameIndexThenSameElement @226:14...
debug: Cache miss: 'precond. (call head[B](l))' VC for lemmaSameIndexThenSameElement @226:14...
debug:  - Now solving 'precond. (call head[B](l))' VC for lemmaSameIndexThenSameElement @226:14...
debug: !contains[B](l, e1) || !contains[B](l, e2) || {
  val bdg: BigInt = getIndex[B](l, e1)
  bdg != getIndex[B](l, e2) || bdg != BigInt("0") || head[B](l) != e1 || l != Nil[B]()
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](l))' VC for lemmaSameIndexThenSameElement @226:14:
debug:  => VALID
info Verified: 210 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaSameIndexThenSameElement @229:37...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaSameIndexThenSameElement @229:37...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaSameIndexThenSameElement @229:37...
debug: !contains[B](l, e1) || !contains[B](l, e2) || {
  val bdg: BigInt = getIndex[B](l, e1)
  bdg != getIndex[B](l, e2) || bdg == BigInt("0") || l != Nil[B]()
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaSameIndexThenSameElement @229:37:
debug:  => VALID
info Verified: 211 / 982
debug:  - Checking cache: 'precond. (call lemmaSameIndexThenSameElement[B](l, e... (require 1/3))' VC for lemmaSameIndexThenSameElement @?:?...
debug: Cache miss: 'precond. (call lemmaSameIndexThenSameElement[B](l, e... (require 1/3))' VC for lemmaSameIndexThenSameElement @?:?...
debug:  - Now solving 'precond. (call lemmaSameIndexThenSameElement[B](l, e... (require 1/3))' VC for lemmaSameIndexThenSameElement @?:?...
debug: !contains[B](l, e1) || !contains[B](l, e2) || {
  val bdg: BigInt = getIndex[B](l, e1)
  bdg != getIndex[B](l, e2) || bdg == BigInt("0") || {
    val bdg: List[B] = tail[B](l)
    !contains[B](bdg, e1) || !contains[B](bdg, e2) || {
      val bdg: BigInt = getIndex[B](bdg, e1)
      val bdg: BigInt = getIndex[B](bdg, e2)
      true
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSameIndexThenSameElement[B](l, e... (require 1/3))' VC for lemmaSameIndexThenSameElement @?:?:
debug:  => VALID
info Verified: 212 / 982
debug:  - Checking cache: 'precond. (call lemmaSameIndexThenSameElement[B](l, e... (require 2/3))' VC for lemmaSameIndexThenSameElement @?:?...
debug: Cache hit: 'precond. (call lemmaSameIndexThenSameElement[B](l, e... (require 2/3))' VC for lemmaSameIndexThenSameElement @?:?...
info Verified: 213 / 982
debug:  - Checking cache: 'precond. (call lemmaSameIndexThenSameElement[B](l, e... (require 3/3))' VC for lemmaSameIndexThenSameElement @?:?...
debug: Cache hit: 'precond. (call lemmaSameIndexThenSameElement[B](l, e... (require 3/3))' VC for lemmaSameIndexThenSameElement @?:?...
info Verified: 214 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaSameIndexThenSameElement @225:14...
debug: Cache miss: 'body assertion' VC for lemmaSameIndexThenSameElement @225:14...
debug:  - Now solving 'body assertion' VC for lemmaSameIndexThenSameElement @225:14...
debug: !contains[B](l, e1) || !contains[B](l, e2) || {
  val bdg: BigInt = getIndex[B](l, e1)
  bdg != getIndex[B](l, e2) || bdg != BigInt("0") || head[B](l) == e1
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaSameIndexThenSameElement @225:14:
debug:  => VALID
info Verified: 215 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaSameIndexThenSameElement @226:14...
debug: Cache miss: 'body assertion' VC for lemmaSameIndexThenSameElement @226:14...
debug:  - Now solving 'body assertion' VC for lemmaSameIndexThenSameElement @226:14...
debug: !contains[B](l, e1) || !contains[B](l, e2) || {
  val bdg: BigInt = getIndex[B](l, e1)
  bdg != getIndex[B](l, e2) || bdg != BigInt("0") || {
    val bdg: B = head[B](l)
    bdg != e1 || bdg == e2
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaSameIndexThenSameElement @226:14:
debug:  => VALID
info Verified: 216 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaSameIndexThenSameElement @227:14...
debug: Cache miss: 'body assertion' VC for lemmaSameIndexThenSameElement @227:14...
debug:  - Now solving 'body assertion' VC for lemmaSameIndexThenSameElement @227:14...
debug: !contains[B](l, e1) || !contains[B](l, e2) || {
  val bdg: BigInt = getIndex[B](l, e1)
  bdg != getIndex[B](l, e2) || bdg != BigInt("0") || {
    val bdg: B = head[B](l)
    bdg != e1 || bdg != e2 || e1 == e2
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaSameIndexThenSameElement @227:14:
debug:  => VALID
info Verified: 217 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaSameIndexThenSameElement @229:37...
debug: Cache miss: 'non-negative measure' VC for lemmaSameIndexThenSameElement @229:37...
debug:  - Now solving 'non-negative measure' VC for lemmaSameIndexThenSameElement @229:37...
debug: !contains[B](l, e1) || !contains[B](l, e2) || getIndex[B](l, e1) != getIndex[B](l, e2) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaSameIndexThenSameElement @229:37:
debug:  => VALID
info Verified: 218 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSameIndexThenSameElement @225:7...
debug: Cache hit: 'postcondition' VC for lemmaSameIndexThenSameElement @225:7...
info Verified: 219 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/3) of lemmaSameIndexThenSameElement' VC for lemmaSameIndexThenSameElement @229:7...
debug: Cache miss: 'body assertion: Inlined precondition (1/3) of lemmaSameIndexThenSameElement' VC for lemmaSameIndexThenSameElement @229:7...
debug:  - Now solving 'body assertion: Inlined precondition (1/3) of lemmaSameIndexThenSameElement' VC for lemmaSameIndexThenSameElement @229:7...
debug: !contains[B](l, e1) || !contains[B](l, e2) || {
  val bdg: BigInt = getIndex[B](l, e1)
  bdg != getIndex[B](l, e2) || bdg == BigInt("0") || contains[B](tail[B](l), e1)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/3) of lemmaSameIndexThenSameElement' VC for lemmaSameIndexThenSameElement @229:7:
debug:  => VALID
info Verified: 220 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/3) of lemmaSameIndexThenSameElement' VC for lemmaSameIndexThenSameElement @229:7...
debug: Cache miss: 'body assertion: Inlined precondition (2/3) of lemmaSameIndexThenSameElement' VC for lemmaSameIndexThenSameElement @229:7...
debug:  - Now solving 'body assertion: Inlined precondition (2/3) of lemmaSameIndexThenSameElement' VC for lemmaSameIndexThenSameElement @229:7...
debug: !contains[B](l, e1) || !contains[B](l, e2) || {
  val bdg: BigInt = getIndex[B](l, e1)
  bdg != getIndex[B](l, e2) || bdg == BigInt("0") || {
    val bdg: List[B] = tail[B](l)
    !contains[B](bdg, e1) || contains[B](bdg, e2)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/3) of lemmaSameIndexThenSameElement' VC for lemmaSameIndexThenSameElement @229:7:
debug:  => VALID
info Verified: 221 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (3/3) of lemmaSameIndexThenSameElement' VC for lemmaSameIndexThenSameElement @229:7...
debug: Cache miss: 'body assertion: Inlined precondition (3/3) of lemmaSameIndexThenSameElement' VC for lemmaSameIndexThenSameElement @229:7...
debug:  - Now solving 'body assertion: Inlined precondition (3/3) of lemmaSameIndexThenSameElement' VC for lemmaSameIndexThenSameElement @229:7...
debug: !contains[B](l, e1) || !contains[B](l, e2) || {
  val bdg: BigInt = getIndex[B](l, e1)
  bdg != getIndex[B](l, e2) || bdg == BigInt("0") || {
    val bdg: List[B] = tail[B](l)
    !contains[B](bdg, e1) || !contains[B](bdg, e2) || getIndex[B](bdg, e1) == getIndex[B](bdg, e2)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (3/3) of lemmaSameIndexThenSameElement' VC for lemmaSameIndexThenSameElement @229:7:
debug:  => VALID
info Verified: 222 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSameIndexThenSameElement @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSameIndexThenSameElement @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSameIndexThenSameElement @?:?...
debug: !contains[B](l, e1) || !contains[B](l, e2) || {
  val bdg: BigInt = getIndex[B](l, e1)
  bdg != getIndex[B](l, e2) || bdg == BigInt("0") || {
    val bdg: List[B] = tail[B](l)
    !contains[B](bdg, e1) || !contains[B](bdg, e2) || getIndex[B](bdg, e1) != getIndex[B](bdg, e2) || ListPrimitiveSize[B](bdg) < ListPrimitiveSize[B](l)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSameIndexThenSameElement @?:?:
debug:  => VALID
info Verified: 223 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSameIndexThenSameElement @229:7...
debug: Cache miss: 'postcondition' VC for lemmaSameIndexThenSameElement @229:7...
debug:  - Now solving 'postcondition' VC for lemmaSameIndexThenSameElement @229:7...
debug: !contains[B](l, e1) || !contains[B](l, e2) || {
  val bdg: BigInt = getIndex[B](l, e1)
  bdg != getIndex[B](l, e2) || bdg == BigInt("0") || {
    val bdg: List[B] = tail[B](l)
    !contains[B](bdg, e1) || !contains[B](bdg, e2) || getIndex[B](bdg, e1) != getIndex[B](bdg, e2) || {
      val bdg: Unit = lemmaSameIndexThenSameElement[B](bdg, e1, e2)
      assume(e1 == e2)
      true
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSameIndexThenSameElement @229:7:
debug:  => VALID
info Verified: 224 / 982
debug:  - Checking cache: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastPrefixDecreasesSize @409:15...
debug: Cache miss: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastPrefixDecreasesSize @409:15...
debug:  - Now solving 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastPrefixDecreasesSize @409:15...
debug: size[B](l) <= BigInt("0") || !isEmpty[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastPrefixDecreasesSize @409:15:
debug:  => VALID
info Verified: 225 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveLastPrefixDecreasesSize @407:7...
debug: Cache miss: 'postcondition' VC for lemmaRemoveLastPrefixDecreasesSize @407:7...
debug:  - Now solving 'postcondition' VC for lemmaRemoveLastPrefixDecreasesSize @407:7...
debug: val bdg: BigInt = size[B](l)
bdg <= BigInt("0") || size[B](removeLast[B](l)) < bdg
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveLastPrefixDecreasesSize @407:7:
debug:  => VALID
info Verified: 226 / 982
debug:  - Checking cache: 'precond. (call tail[B](tot))' VC for lemmaMoveElementToOtherListKeepsConcatEq @535:65...
debug: Cache miss: 'precond. (call tail[B](tot))' VC for lemmaMoveElementToOtherListKeepsConcatEq @535:65...
debug:  - Now solving 'precond. (call tail[B](tot))' VC for lemmaMoveElementToOtherListKeepsConcatEq @535:65...
debug: ++[B](s1, Cons[B](hd2, tl2)) != tot || !s1.isInstanceOf[Cons] || tot != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](tot))' VC for lemmaMoveElementToOtherListKeepsConcatEq @535:65:
debug:  => VALID
info Verified: 227 / 982
debug:  - Checking cache: 'precond. (call lemmaMoveElementToOtherListKeepsConca...)' VC for lemmaMoveElementToOtherListKeepsConcatEq @?:?...
debug: Cache miss: 'precond. (call lemmaMoveElementToOtherListKeepsConca...)' VC for lemmaMoveElementToOtherListKeepsConcatEq @?:?...
debug:  - Now solving 'precond. (call lemmaMoveElementToOtherListKeepsConca...)' VC for lemmaMoveElementToOtherListKeepsConcatEq @?:?...
debug: val bdg: List[B] = Cons[B](hd2, tl2)
++[B](s1, bdg) != tot || !s1.isInstanceOf[Cons] || {
  val bdg: List[B] = ++[B](s1.t, bdg)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaMoveElementToOtherListKeepsConca...)' VC for lemmaMoveElementToOtherListKeepsConcatEq @?:?:
debug:  => VALID
info Verified: 228 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaMoveElementToOtherListKeepsConcatEq @539:43...
debug: Cache miss: 'non-negative measure' VC for lemmaMoveElementToOtherListKeepsConcatEq @539:43...
debug:  - Now solving 'non-negative measure' VC for lemmaMoveElementToOtherListKeepsConcatEq @539:43...
debug: ++[B](s1, Cons[B](hd2, tl2)) != tot || ListPrimitiveSize[B](tot) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaMoveElementToOtherListKeepsConcatEq @539:43:
debug:  => VALID
info Verified: 229 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaMoveElementToOtherListKeepsConcatEq' VC for lemmaMoveElementToOtherListKeepsConcatEq @535:9...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaMoveElementToOtherListKeepsConcatEq' VC for lemmaMoveElementToOtherListKeepsConcatEq @535:9...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaMoveElementToOtherListKeepsConcatEq' VC for lemmaMoveElementToOtherListKeepsConcatEq @535:9...
debug: val bdg: List[B] = Cons[B](hd2, tl2)
++[B](s1, bdg) != tot || !s1.isInstanceOf[Cons] || ++[B](s1.t, bdg) == tail[B](tot)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaMoveElementToOtherListKeepsConcatEq' VC for lemmaMoveElementToOtherListKeepsConcatEq @535:9:
debug:  => VALID
info Verified: 230 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaMoveElementToOtherListKeepsConcatEq @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaMoveElementToOtherListKeepsConcatEq @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaMoveElementToOtherListKeepsConcatEq @?:?...
debug: val bdg: List[B] = Cons[B](hd2, tl2)
++[B](s1, bdg) != tot || !s1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](tot)
  ++[B](s1.t, bdg) != bdg || ListPrimitiveSize[B](bdg) < ListPrimitiveSize[B](tot)
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaMoveElementToOtherListKeepsConcatEq @?:?:
debug:  => VALID
info Verified: 231 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaMoveElementToOtherListKeepsConcatEq @535:9...
debug: Cache miss: 'postcondition' VC for lemmaMoveElementToOtherListKeepsConcatEq @535:9...
debug:  - Now solving 'postcondition' VC for lemmaMoveElementToOtherListKeepsConcatEq @535:9...
debug: val bdg: List[B] = Cons[B](hd2, tl2)
++[B](s1, bdg) != tot || !s1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](tot)
  ++[B](s1.t, bdg) != bdg || {
    val bdg: Unit = lemmaMoveElementToOtherListKeepsConcatEq[B](s1.t, hd2, tl2, bdg)
    val bdg: List[B] = Cons[B](hd2, Nil[B]())
    assume(++[B](++[B](s1.t, bdg), tl2) == bdg)
    ++[B](++[B](s1, bdg), tl2) == tot
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaMoveElementToOtherListKeepsConcatEq @535:9:
debug:  => VALID
info Verified: 232 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaMoveElementToOtherListKeepsConcatEq @536:21...
debug: Cache miss: 'postcondition' VC for lemmaMoveElementToOtherListKeepsConcatEq @536:21...
debug:  - Now solving 'postcondition' VC for lemmaMoveElementToOtherListKeepsConcatEq @536:21...
debug: ++[B](s1, Cons[B](hd2, tl2)) != tot || s1.isInstanceOf[Cons] || ++[B](++[B](s1, Cons[B](hd2, Nil[B]())), tl2) == tot
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaMoveElementToOtherListKeepsConcatEq @536:21:
debug:  => VALID
info Verified: 233 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaMoveElementToOtherListKeepsConcatEq @533:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaMoveElementToOtherListKeepsConcatEq @533:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaMoveElementToOtherListKeepsConcatEq @533:5...
debug: val bdg: List[B] = ++[B](s1, Cons[B](hd2, tl2))
true
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaMoveElementToOtherListKeepsConcatEq @533:5:
debug:  => VALID
info Verified: 234 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaMoveElementToOtherListKeepsConcatEq @533:5...
debug: Cache hit: 'postcondition' VC for lemmaMoveElementToOtherListKeepsConcatEq @533:5...
info Verified: 235 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @585:35...
debug: Cache miss: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @585:35...
debug:  - Now solving 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @585:35...
debug: !noDuplicate[B](acc) || {
  val bdg: Boolean = isSuffix[B](list, totList)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @585:35:
debug:  => VALID
info Verified: 236 / 982
debug:  - Checking cache: 'precond. (call lemmaIsSuffixThenTailIsSuffix[B](l, s...)' VC for removeDuplicates @?:?...
debug: Cache miss: 'precond. (call lemmaIsSuffixThenTailIsSuffix[B](l, s...)' VC for removeDuplicates @?:?...
debug:  - Now solving 'precond. (call lemmaIsSuffixThenTailIsSuffix[B](l, s...)' VC for removeDuplicates @?:?...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || !subseq[B](acc, getPrefix[B](totList, list)) || content[B](++[B](acc, list)) != content[B](totList) || !list.isInstanceOf[Cons] || {
  val bdg: Boolean = contains[B](acc, list.h)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaIsSuffixThenTailIsSuffix[B](l, s...)' VC for removeDuplicates @?:?:
debug:  => VALID
info Verified: 237 / 982
debug:  - Checking cache: 'precond. (call lemmaRemovingHeadOfSuffixThenGetPrefi...)' VC for removeDuplicates @?:?...
debug: Cache miss: 'precond. (call lemmaRemovingHeadOfSuffixThenGetPrefi...)' VC for removeDuplicates @?:?...
debug:  - Now solving 'precond. (call lemmaRemovingHeadOfSuffixThenGetPrefi...)' VC for removeDuplicates @?:?...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || !subseq[B](acc, getPrefix[B](totList, list)) || content[B](++[B](acc, list)) != content[B](totList) || !list.isInstanceOf[Cons] || !contains[B](acc, list.h) || {
  val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
  assume(isEmpty[B](list) || isSuffix[B](tail[B](list), totList))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaRemovingHeadOfSuffixThenGetPrefi...)' VC for removeDuplicates @?:?:
debug:  => VALID
info Verified: 238 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @593:41...
debug: Cache miss: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @593:41...
debug:  - Now solving 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @593:41...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || !list.isInstanceOf[Cons] || !contains[B](acc, list.h) || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @593:41:
debug:  => VALID
info Verified: 239 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @594:36...
debug: Cache miss: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @594:36...
debug:  - Now solving 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @594:36...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || !list.isInstanceOf[Cons] || !contains[B](acc, list.h) || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    assume(subseq[B](bdg, ++[B](bdg, bdg)))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @594:36:
debug:  => VALID
info Verified: 240 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @594:62...
debug: Cache hit: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @594:62...
info Verified: 241 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for removeDuplicates @?:?...
debug: Cache hit: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for removeDuplicates @?:?...
info Verified: 242 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for removeDuplicates @?:?...
debug: Cache hit: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for removeDuplicates @?:?...
info Verified: 243 / 982
debug:  - Checking cache: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 1/4))' VC for removeDuplicates @596:9...
debug: Cache miss: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 1/4))' VC for removeDuplicates @596:9...
debug:  - Now solving 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 1/4))' VC for removeDuplicates @596:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || !list.isInstanceOf[Cons] || !contains[B](acc, list.h) || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 1/4))' VC for removeDuplicates @596:9:
debug:  => VALID
info Verified: 244 / 982
debug:  - Checking cache: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 2/4))' VC for removeDuplicates @596:9...
debug: Cache miss: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 2/4))' VC for removeDuplicates @596:9...
debug:  - Now solving 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 2/4))' VC for removeDuplicates @596:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || !list.isInstanceOf[Cons] || !contains[B](acc, list.h) || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    isSuffix[B](list.t, totList)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 2/4))' VC for removeDuplicates @596:9:
debug:  => VALID
info Verified: 245 / 982
debug:  - Checking cache: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 3/4))' VC for removeDuplicates @596:9...
debug: Cache miss: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 3/4))' VC for removeDuplicates @596:9...
debug:  - Now solving 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 3/4))' VC for removeDuplicates @596:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || !list.isInstanceOf[Cons] || !contains[B](acc, list.h) || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    !isSuffix[B](list.t, totList) || subseq[B](acc, getPrefix[B](totList, list.t))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 3/4))' VC for removeDuplicates @596:9:
debug:  => VALID
info Verified: 246 / 982
debug:  - Checking cache: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 4/4))' VC for removeDuplicates @596:9...
debug: Cache miss: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 4/4))' VC for removeDuplicates @596:9...
debug:  - Now solving 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 4/4))' VC for removeDuplicates @596:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || {
    val bdg: Set[B] = content[B](++[B](acc, list))
    val bdg: Set[B] = content[B](totList)
    bdg != bdg || !list.isInstanceOf[Cons] || !contains[B](acc, list.h) || {
      val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
      val bdg: Boolean = isEmpty[B](list)
      assume(bdg || isSuffix[B](tail[B](list), totList))
      val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
      assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
      val bdg: List[B] = Cons[B](list.h, Nil[B]())
      val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
      val bdg: List[B] = ++[B](bdg, bdg)
      assume(subseq[B](bdg, bdg))
      val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
      assume(subseq[B](acc, bdg))
      !isSuffix[B](list.t, totList) || !subseq[B](acc, getPrefix[B](totList, list.t)) || content[B](++[B](acc, list.t)) == bdg
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 4/4))' VC for removeDuplicates @596:9:
debug:  => VALID
info Verified: 247 / 982
debug:  - Checking cache: 'precond. (call lemmaIsSuffixThenTailIsSuffix[B](l, s...)' VC for removeDuplicates @?:?...
debug: Cache miss: 'precond. (call lemmaIsSuffixThenTailIsSuffix[B](l, s...)' VC for removeDuplicates @?:?...
debug:  - Now solving 'precond. (call lemmaIsSuffixThenTailIsSuffix[B](l, s...)' VC for removeDuplicates @?:?...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || !subseq[B](acc, getPrefix[B](totList, list)) || content[B](++[B](acc, list)) != content[B](totList) || {
  val bdg: Boolean = !list.isInstanceOf[Cons] || !contains[B](acc, list.h)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaIsSuffixThenTailIsSuffix[B](l, s...)' VC for removeDuplicates @?:?:
debug:  => VALID
info Verified: 248 / 982
debug:  - Checking cache: 'precond. (call lemmaRemovingHeadOfSuffixThenGetPrefi...)' VC for removeDuplicates @?:?...
debug: Cache miss: 'precond. (call lemmaRemovingHeadOfSuffixThenGetPrefi...)' VC for removeDuplicates @?:?...
debug:  - Now solving 'precond. (call lemmaRemovingHeadOfSuffixThenGetPrefi...)' VC for removeDuplicates @?:?...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || !subseq[B](acc, getPrefix[B](totList, list)) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
  assume(isEmpty[B](list) || isSuffix[B](tail[B](list), totList))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaRemovingHeadOfSuffixThenGetPrefi...)' VC for removeDuplicates @?:?:
debug:  => VALID
info Verified: 249 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @601:41...
debug: Cache miss: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @601:41...
debug:  - Now solving 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @601:41...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @601:41:
debug:  => VALID
info Verified: 250 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @602:36...
debug: Cache miss: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @602:36...
debug:  - Now solving 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @602:36...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    assume(subseq[B](bdg, ++[B](bdg, bdg)))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @602:36:
debug:  => VALID
info Verified: 251 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @602:62...
debug: Cache hit: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @602:62...
info Verified: 252 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for removeDuplicates @?:?...
debug: Cache hit: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for removeDuplicates @?:?...
info Verified: 253 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for removeDuplicates @?:?...
debug: Cache hit: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for removeDuplicates @?:?...
info Verified: 254 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @604:46...
debug: Cache miss: 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @604:46...
debug:  - Now solving 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @604:46...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getPrefix[B](totList, list))' VC for removeDuplicates @604:46:
debug:  => VALID
info Verified: 255 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)' VC for removeDuplicates @?:?...
debug: Cache hit: 'precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)' VC for removeDuplicates @?:?...
info Verified: 256 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 1/2))' VC for removeDuplicates @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 1/2))' VC for removeDuplicates @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 1/2))' VC for removeDuplicates @?:?...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
    assume(subseq[B](++[B](acc, bdg), bdg))
    val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
    assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
    !forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)) || contains[B](acc, list.h) || forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 1/2))' VC for removeDuplicates @?:?:
debug:  => VALID
info Verified: 257 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 2/2))' VC for removeDuplicates @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 2/2))' VC for removeDuplicates @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 2/2))' VC for removeDuplicates @?:?...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
    assume(subseq[B](++[B](acc, bdg), bdg))
    val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
    assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
    !forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)) || contains[B](acc, list.h) || {
      val bdg: Boolean = forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb))
      true
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 2/2))' VC for removeDuplicates @?:?:
debug:  => VALID
info Verified: 258 / 982
debug:  - Checking cache: 'precond. (call noDuplicateConcatListNotContainedPres... (require 1/4))' VC for removeDuplicates @?:?...
debug: Cache miss: 'precond. (call noDuplicateConcatListNotContainedPres... (require 1/4))' VC for removeDuplicates @?:?...
debug:  - Now solving 'precond. (call noDuplicateConcatListNotContainedPres... (require 1/4))' VC for removeDuplicates @?:?...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
    assume(subseq[B](++[B](acc, bdg), bdg))
    val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
    assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
    val bdg: Unit = lemmaForallNotContainsPreservedAddNewElmtInRefList[B](acc, Nil[B](), list.h)
    assume(forall[B](acc, (bb: B) => !contains[B](bdg, bb)))
    !noDuplicate[B](bdg) || !forall[B](bdg, (b: B) => !contains[B](acc, b)) || {
      val bdg: Boolean = forall[B](acc, (b: B) => !contains[B](bdg, b))
      true
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call noDuplicateConcatListNotContainedPres... (require 1/4))' VC for removeDuplicates @?:?:
debug:  => VALID
info Verified: 259 / 982
debug:  - Checking cache: 'precond. (call noDuplicateConcatListNotContainedPres... (require 2/4))' VC for removeDuplicates @?:?...
debug: Cache hit: 'precond. (call noDuplicateConcatListNotContainedPres... (require 2/4))' VC for removeDuplicates @?:?...
info Verified: 260 / 982
debug:  - Checking cache: 'precond. (call noDuplicateConcatListNotContainedPres... (require 3/4))' VC for removeDuplicates @?:?...
debug: Cache miss: 'precond. (call noDuplicateConcatListNotContainedPres... (require 3/4))' VC for removeDuplicates @?:?...
debug:  - Now solving 'precond. (call noDuplicateConcatListNotContainedPres... (require 3/4))' VC for removeDuplicates @?:?...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
    assume(subseq[B](++[B](acc, bdg), bdg))
    val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
    assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
    val bdg: Unit = lemmaForallNotContainsPreservedAddNewElmtInRefList[B](acc, Nil[B](), list.h)
    assume(forall[B](acc, (bb: B) => !contains[B](bdg, bb)))
    !noDuplicate[B](bdg) || !forall[B](bdg, (b: B) => !contains[B](acc, b)) || !forall[B](acc, (b: B) => !contains[B](bdg, b)) || forall[B](bdg, (b: B) => !contains[B](acc, b))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call noDuplicateConcatListNotContainedPres... (require 3/4))' VC for removeDuplicates @?:?:
debug:  => VALID
info Verified: 261 / 982
debug:  - Checking cache: 'precond. (call noDuplicateConcatListNotContainedPres... (require 4/4))' VC for removeDuplicates @?:?...
debug: Cache miss: 'precond. (call noDuplicateConcatListNotContainedPres... (require 4/4))' VC for removeDuplicates @?:?...
debug:  - Now solving 'precond. (call noDuplicateConcatListNotContainedPres... (require 4/4))' VC for removeDuplicates @?:?...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
    assume(subseq[B](++[B](acc, bdg), bdg))
    val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
    assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
    val bdg: Unit = lemmaForallNotContainsPreservedAddNewElmtInRefList[B](acc, Nil[B](), list.h)
    assume(forall[B](acc, (bb: B) => !contains[B](bdg, bb)))
    !noDuplicate[B](bdg) || !forall[B](bdg, (b: B) => !contains[B](acc, b)) || !forall[B](acc, (b: B) => !contains[B](bdg, b)) || !forall[B](bdg, (b: B) => !contains[B](acc, b)) || forall[B](acc, (b: B) => !contains[B](bdg, b))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call noDuplicateConcatListNotContainedPres... (require 4/4))' VC for removeDuplicates @?:?:
debug:  => VALID
info Verified: 262 / 982
debug:  - Checking cache: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 1/4))' VC for removeDuplicates @610:9...
debug: Cache miss: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 1/4))' VC for removeDuplicates @610:9...
debug:  - Now solving 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 1/4))' VC for removeDuplicates @610:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
    val bdg: List[B] = ++[B](acc, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
    assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
    val bdg: Unit = lemmaForallNotContainsPreservedAddNewElmtInRefList[B](acc, Nil[B](), list.h)
    assume(forall[B](acc, (bb: B) => !contains[B](bdg, bb)))
    val bdg: Unit = noDuplicateConcatListNotContainedPreservesBis[B](acc, bdg)
    assume(noDuplicate[B](bdg))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 1/4))' VC for removeDuplicates @610:9:
debug:  => VALID
info Verified: 263 / 982
debug:  - Checking cache: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 2/4))' VC for removeDuplicates @610:9...
debug: Cache miss: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 2/4))' VC for removeDuplicates @610:9...
debug:  - Now solving 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 2/4))' VC for removeDuplicates @610:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
    val bdg: List[B] = ++[B](acc, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
    assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
    val bdg: Unit = lemmaForallNotContainsPreservedAddNewElmtInRefList[B](acc, Nil[B](), list.h)
    assume(forall[B](acc, (bb: B) => !contains[B](bdg, bb)))
    val bdg: Unit = noDuplicateConcatListNotContainedPreservesBis[B](acc, bdg)
    assume(noDuplicate[B](bdg))
    isSuffix[B](list.t, totList)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 2/4))' VC for removeDuplicates @610:9:
debug:  => VALID
info Verified: 264 / 982
debug:  - Checking cache: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 3/4))' VC for removeDuplicates @610:9...
debug: Cache miss: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 3/4))' VC for removeDuplicates @610:9...
debug:  - Now solving 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 3/4))' VC for removeDuplicates @610:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
    val bdg: List[B] = ++[B](acc, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
    assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
    val bdg: Unit = lemmaForallNotContainsPreservedAddNewElmtInRefList[B](acc, Nil[B](), list.h)
    assume(forall[B](acc, (bb: B) => !contains[B](bdg, bb)))
    val bdg: Unit = noDuplicateConcatListNotContainedPreservesBis[B](acc, bdg)
    assume(noDuplicate[B](bdg))
    !isSuffix[B](list.t, totList) || subseq[B](bdg, getPrefix[B](totList, list.t))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 3/4))' VC for removeDuplicates @610:9:
debug:  => VALID
info Verified: 265 / 982
debug:  - Checking cache: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 4/4))' VC for removeDuplicates @610:9...
debug: Cache miss: 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 4/4))' VC for removeDuplicates @610:9...
debug:  - Now solving 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 4/4))' VC for removeDuplicates @610:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || {
    val bdg: Set[B] = content[B](++[B](acc, list))
    val bdg: Set[B] = content[B](totList)
    bdg != bdg || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
      val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
      val bdg: Boolean = isEmpty[B](list)
      assume(bdg || isSuffix[B](tail[B](list), totList))
      val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
      assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
      val bdg: List[B] = Cons[B](list.h, Nil[B]())
      val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
      val bdg: List[B] = ++[B](bdg, bdg)
      assume(subseq[B](bdg, bdg))
      val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
      assume(subseq[B](acc, bdg))
      val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
      val bdg: List[B] = ++[B](acc, bdg)
      assume(subseq[B](bdg, bdg))
      val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
      assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
      val bdg: Unit = lemmaForallNotContainsPreservedAddNewElmtInRefList[B](acc, Nil[B](), list.h)
      assume(forall[B](acc, (bb: B) => !contains[B](bdg, bb)))
      val bdg: Unit = noDuplicateConcatListNotContainedPreservesBis[B](acc, bdg)
      assume(noDuplicate[B](bdg))
      !isSuffix[B](list.t, totList) || !subseq[B](bdg, getPrefix[B](totList, list.t)) || content[B](++[B](bdg, list.t)) == bdg
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeDuplicates[B](totList, (scrut.t... (require 4/4))' VC for removeDuplicates @610:9:
debug:  => VALID
info Verified: 266 / 982
debug:  - Checking cache: 'non-negative measure' VC for removeDuplicates @614:100...
debug: Cache miss: 'non-negative measure' VC for removeDuplicates @614:100...
debug:  - Now solving 'non-negative measure' VC for removeDuplicates @614:100...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || !subseq[B](acc, getPrefix[B](totList, list)) || content[B](++[B](acc, list)) != content[B](totList) || ListPrimitiveSize[B](list) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for removeDuplicates @614:100:
debug:  => VALID
info Verified: 267 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaIsSuffixThenTailIsSuffix' VC for removeDuplicates @591:9...
debug: Cache hit: 'body assertion: Inlined precondition of lemmaIsSuffixThenTailIsSuffix' VC for removeDuplicates @591:9...
info Verified: 268 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger' VC for removeDuplicates @592:9...
debug: Cache hit: 'body assertion: Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger' VC for removeDuplicates @592:9...
info Verified: 269 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for removeDuplicates @594:9...
debug: Cache hit: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for removeDuplicates @594:9...
info Verified: 270 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for removeDuplicates @594:9...
debug: Cache hit: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for removeDuplicates @594:9...
info Verified: 271 / 982
debug:  - Checking cache: 'measure decreases' VC for removeDuplicates @596:9...
debug: Cache miss: 'measure decreases' VC for removeDuplicates @596:9...
debug:  - Now solving 'measure decreases' VC for removeDuplicates @596:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || !list.isInstanceOf[Cons] || !contains[B](acc, list.h) || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    ListPrimitiveSize[B](list.t) < ListPrimitiveSize[B](list)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for removeDuplicates @596:9:
debug:  => VALID
info Verified: 272 / 982
debug:  - Checking cache: 'postcondition' VC for removeDuplicates @596:9...
debug: Cache miss: 'postcondition' VC for removeDuplicates @596:9...
debug:  - Now solving 'postcondition' VC for removeDuplicates @596:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || {
    val bdg: Set[B] = content[B](++[B](acc, list))
    val bdg: Set[B] = content[B](totList)
    bdg != bdg || !list.isInstanceOf[Cons] || !contains[B](acc, list.h) || {
      val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
      val bdg: Boolean = isEmpty[B](list)
      assume(bdg || isSuffix[B](tail[B](list), totList))
      val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
      assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
      val bdg: List[B] = Cons[B](list.h, Nil[B]())
      val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
      val bdg: List[B] = ++[B](bdg, bdg)
      assume(subseq[B](bdg, bdg))
      val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
      assume(subseq[B](acc, bdg))
      val bdg: List[B] = removeDuplicates[B](totList, list.t, acc)
      noDuplicate[B](bdg) && subseq[B](bdg, totList) && {
        val bdg: List[B] = ++[B](list, acc)
        val bdg: Set[B] = content[B](bdg)
        bdg == content[B](bdg) && bdg == bdg
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for removeDuplicates @596:9:
debug:  => VALID
info Verified: 273 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaIsSuffixThenTailIsSuffix' VC for removeDuplicates @599:9...
debug: Cache hit: 'body assertion: Inlined precondition of lemmaIsSuffixThenTailIsSuffix' VC for removeDuplicates @599:9...
info Verified: 274 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger' VC for removeDuplicates @600:9...
debug: Cache hit: 'body assertion: Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger' VC for removeDuplicates @600:9...
info Verified: 275 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for removeDuplicates @602:9...
debug: Cache hit: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for removeDuplicates @602:9...
info Verified: 276 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for removeDuplicates @602:9...
debug: Cache hit: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for removeDuplicates @602:9...
info Verified: 277 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaSubSeqAddSameElmtPreserves' VC for removeDuplicates @604:9...
debug: Cache hit: 'body assertion: Inlined precondition of lemmaSubSeqAddSameElmtPreserves' VC for removeDuplicates @604:9...
info Verified: 278 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList' VC for removeDuplicates @607:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList' VC for removeDuplicates @607:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList' VC for removeDuplicates @607:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
    assume(subseq[B](++[B](acc, bdg), bdg))
    val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
    assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
    forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList' VC for removeDuplicates @607:9:
debug:  => VALID
info Verified: 279 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList' VC for removeDuplicates @607:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList' VC for removeDuplicates @607:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList' VC for removeDuplicates @607:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
    assume(subseq[B](++[B](acc, bdg), bdg))
    val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
    assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
    !forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)) || !contains[B](acc, list.h)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList' VC for removeDuplicates @607:9:
debug:  => VALID
info Verified: 280 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
    assume(subseq[B](++[B](acc, bdg), bdg))
    val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
    assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
    val bdg: Unit = lemmaForallNotContainsPreservedAddNewElmtInRefList[B](acc, Nil[B](), list.h)
    assume(forall[B](acc, (bb: B) => !contains[B](bdg, bb)))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9:
debug:  => VALID
info Verified: 281 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
    assume(subseq[B](++[B](acc, bdg), bdg))
    val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
    assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
    val bdg: Unit = lemmaForallNotContainsPreservedAddNewElmtInRefList[B](acc, Nil[B](), list.h)
    assume(forall[B](acc, (bb: B) => !contains[B](bdg, bb)))
    noDuplicate[B](bdg)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9:
debug:  => VALID
info Verified: 282 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9...
debug: Cache miss: 'body assertion: Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9...
debug:  - Now solving 'body assertion: Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
    assume(subseq[B](++[B](acc, bdg), bdg))
    val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
    assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
    val bdg: Unit = lemmaForallNotContainsPreservedAddNewElmtInRefList[B](acc, Nil[B](), list.h)
    assume(forall[B](acc, (bb: B) => !contains[B](bdg, bb)))
    !noDuplicate[B](bdg) || forall[B](bdg, (b: B) => !contains[B](acc, b))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9:
debug:  => VALID
info Verified: 283 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9...
debug: Cache miss: 'body assertion: Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9...
debug:  - Now solving 'body assertion: Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
    assume(subseq[B](++[B](acc, bdg), bdg))
    val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
    assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
    val bdg: Unit = lemmaForallNotContainsPreservedAddNewElmtInRefList[B](acc, Nil[B](), list.h)
    assume(forall[B](acc, (bb: B) => !contains[B](bdg, bb)))
    !noDuplicate[B](bdg) || !forall[B](bdg, (b: B) => !contains[B](acc, b)) || forall[B](acc, (b: B) => !contains[B](bdg, b))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis' VC for removeDuplicates @608:9:
debug:  => VALID
info Verified: 284 / 982
debug:  - Checking cache: 'measure decreases' VC for removeDuplicates @610:9...
debug: Cache miss: 'measure decreases' VC for removeDuplicates @610:9...
debug:  - Now solving 'measure decreases' VC for removeDuplicates @610:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || content[B](++[B](acc, list)) != content[B](totList) || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
    val bdg: Boolean = isEmpty[B](list)
    assume(bdg || isSuffix[B](tail[B](list), totList))
    val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
    assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
    val bdg: List[B] = Cons[B](list.h, Nil[B]())
    val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
    val bdg: List[B] = ++[B](bdg, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
    assume(subseq[B](acc, bdg))
    val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
    val bdg: List[B] = ++[B](acc, bdg)
    assume(subseq[B](bdg, bdg))
    val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
    assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
    val bdg: Unit = lemmaForallNotContainsPreservedAddNewElmtInRefList[B](acc, Nil[B](), list.h)
    assume(forall[B](acc, (bb: B) => !contains[B](bdg, bb)))
    val bdg: Unit = noDuplicateConcatListNotContainedPreservesBis[B](acc, bdg)
    assume(noDuplicate[B](bdg))
    ListPrimitiveSize[B](list.t) < ListPrimitiveSize[B](list)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for removeDuplicates @610:9:
debug:  => VALID
info Verified: 285 / 982
debug:  - Checking cache: 'postcondition' VC for removeDuplicates @610:9...
debug: Cache miss: 'postcondition' VC for removeDuplicates @610:9...
debug:  - Now solving 'postcondition' VC for removeDuplicates @610:9...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || {
  val bdg: List[B] = getPrefix[B](totList, list)
  !subseq[B](acc, bdg) || {
    val bdg: Set[B] = content[B](++[B](acc, list))
    val bdg: Set[B] = content[B](totList)
    bdg != bdg || list.isInstanceOf[Cons] && contains[B](acc, list.h) || !list.isInstanceOf[Cons] || {
      val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](totList, list)
      val bdg: Boolean = isEmpty[B](list)
      assume(bdg || isSuffix[B](tail[B](list), totList))
      val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](totList, list)
      assume(bdg || ++[B](bdg, Cons[B](head[B](list), Nil[B]())) == getPrefix[B](totList, tail[B](list)))
      val bdg: List[B] = Cons[B](list.h, Nil[B]())
      val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](bdg, bdg)
      val bdg: List[B] = ++[B](bdg, bdg)
      assume(subseq[B](bdg, bdg))
      val bdg: Unit = lemmaSubSeqTransitive[B](acc, bdg, bdg)
      assume(subseq[B](acc, bdg))
      val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](acc, bdg, list.h)
      val bdg: List[B] = ++[B](acc, bdg)
      assume(subseq[B](bdg, bdg))
      val bdg: Unit = lemmaForallNotContainsNilRefList[B](acc)
      assume(forall[B](acc, (bb: B) => !contains[B](Nil[B](), bb)))
      val bdg: Unit = lemmaForallNotContainsPreservedAddNewElmtInRefList[B](acc, Nil[B](), list.h)
      assume(forall[B](acc, (bb: B) => !contains[B](bdg, bb)))
      val bdg: Unit = noDuplicateConcatListNotContainedPreservesBis[B](acc, bdg)
      assume(noDuplicate[B](bdg))
      val bdg: List[B] = removeDuplicates[B](totList, list.t, bdg)
      noDuplicate[B](bdg) && subseq[B](bdg, totList) && {
        val bdg: List[B] = ++[B](list, acc)
        val bdg: Set[B] = content[B](bdg)
        bdg == content[B](bdg) && bdg == bdg
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for removeDuplicates @610:9:
debug:  => VALID
info Verified: 286 / 982
debug:  - Checking cache: 'postcondition' VC for removeDuplicates @614:108...
debug: Cache miss: 'postcondition' VC for removeDuplicates @614:108...
debug:  - Now solving 'postcondition' VC for removeDuplicates @614:108...
debug: !noDuplicate[B](acc) || !isSuffix[B](list, totList) || !subseq[B](acc, getPrefix[B](totList, list)) || {
  val bdg: Set[B] = content[B](++[B](acc, list))
  val bdg: Set[B] = content[B](totList)
  bdg != bdg || list.isInstanceOf[Cons] && contains[B](acc, list.h) || list.isInstanceOf[Cons] || subseq[B](acc, totList) && {
    val bdg: List[B] = ++[B](list, acc)
    val bdg: Set[B] = content[B](acc)
    bdg == content[B](bdg) && bdg == bdg
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for removeDuplicates @614:108:
debug:  => VALID
info Verified: 287 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for removeDuplicates @589:5...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for removeDuplicates @589:5...
info Verified: 288 / 982
debug:  - Checking cache: 'postcondition' VC for removeDuplicates @589:5...
debug: Cache hit: 'postcondition' VC for removeDuplicates @589:5...
info Verified: 289 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallNotContainsNilRefList @972:51...
debug: Cache miss: 'non-negative measure' VC for lemmaForallNotContainsNilRefList @972:51...
debug:  - Now solving 'non-negative measure' VC for lemmaForallNotContainsNilRefList @972:51...
debug: ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaForallNotContainsNilRefList @972:51:
debug:  => VALID
info Verified: 290 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallNotContainsNilRefList @972:71...
debug: Cache miss: 'measure decreases' VC for lemmaForallNotContainsNilRefList @972:71...
debug:  - Now solving 'measure decreases' VC for lemmaForallNotContainsNilRefList @972:71...
debug: !l.isInstanceOf[Cons] || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallNotContainsNilRefList @972:71:
debug:  => VALID
info Verified: 291 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsNilRefList @972:71...
debug: Cache miss: 'postcondition' VC for lemmaForallNotContainsNilRefList @972:71...
debug:  - Now solving 'postcondition' VC for lemmaForallNotContainsNilRefList @972:71...
debug: !l.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaForallNotContainsNilRefList[B](l.t)
  forall[B](l, (bb: B) => !contains[B](Nil[B](), bb))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallNotContainsNilRefList @972:71:
debug:  => VALID
info Verified: 292 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsNilRefList @972:71...
debug: Cache miss: 'postcondition' VC for lemmaForallNotContainsNilRefList @972:71...
debug:  - Now solving 'postcondition' VC for lemmaForallNotContainsNilRefList @972:71...
debug: l.isInstanceOf[Cons] || forall[B](l, (bb: B) => !contains[B](Nil[B](), bb))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallNotContainsNilRefList @972:71:
debug:  => VALID
info Verified: 293 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsNilRefList @972:71...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsNilRefList @972:71...
info Verified: 294 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsNilRefList @972:71...
debug: Cache miss: 'postcondition' VC for lemmaForallNotContainsNilRefList @972:71...
info Verified: 295 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug: Cache miss: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug:  - Now solving 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h == l3.h || {
  val bdg: Boolean = subseq[B](l2, l3.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?:
debug:  => VALID
info Verified: 296 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaSubSeqTransitive @?:?...
debug: Cache hit: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaSubSeqTransitive @?:?...
info Verified: 297 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug: Cache miss: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug:  - Now solving 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || !subseq[B](l2.t, l3.t) || l1.h != l2.h || {
  val bdg: Boolean = subseq[B](l1.t, l2.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?:
debug:  => VALID
info Verified: 298 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaSubSeqTransitive @?:?...
debug: Cache hit: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaSubSeqTransitive @?:?...
info Verified: 299 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug: Cache miss: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug:  - Now solving 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || !subseq[B](l2.t, l3.t) || l1.h != l2.h || subseq[B](l1.t, l2.t) || {
  val bdg: Boolean = subseq[B](l1, l2.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?:
debug:  => VALID
info Verified: 300 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaSubSeqTransitive @?:?...
debug: Cache hit: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaSubSeqTransitive @?:?...
info Verified: 301 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug: Cache miss: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug:  - Now solving 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || !subseq[B](l2.t, l3.t) || l1.h == l2.h || {
  val bdg: Boolean = subseq[B](l1, l2.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?:
debug:  => VALID
info Verified: 302 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaSubSeqTransitive @?:?...
debug: Cache hit: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaSubSeqTransitive @?:?...
info Verified: 303 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug: Cache miss: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug:  - Now solving 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || subseq[B](l2.t, l3.t) || l1.h != l2.h || !subseq[B](l1.t, l2) || {
  val bdg: Boolean = subseq[B](l2, l3.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?:
debug:  => VALID
info Verified: 304 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaSubSeqTransitive @?:?...
debug: Cache hit: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaSubSeqTransitive @?:?...
info Verified: 305 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug: Cache miss: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug:  - Now solving 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || subseq[B](l2.t, l3.t) || l1.h != l2.h || subseq[B](l1.t, l2) || {
  val bdg: Boolean = subseq[B](l2, l3.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?:
debug:  => VALID
info Verified: 306 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaSubSeqTransitive @?:?...
debug: Cache hit: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaSubSeqTransitive @?:?...
info Verified: 307 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug: Cache miss: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug:  - Now solving 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || subseq[B](l2.t, l3.t) || l1.h == l2.h || {
  val bdg: Boolean = subseq[B](l2, l3.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))' VC for lemmaSubSeqTransitive @?:?:
debug:  => VALID
info Verified: 308 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaSubSeqTransitive @?:?...
debug: Cache hit: 'precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))' VC for lemmaSubSeqTransitive @?:?...
info Verified: 309 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaSubSeqTransitive @?:?...
debug: Cache miss: 'non-negative measure' VC for lemmaSubSeqTransitive @?:?...
debug:  - Now solving 'non-negative measure' VC for lemmaSubSeqTransitive @?:?...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  val bdg: BigInt = size[B](l3)
  bdg >= BigInt("0") && bdg >= BigInt("0") && bdg >= BigInt("0")
}
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaSubSeqTransitive @?:?:
debug:  => VALID
info Verified: 310 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @676:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @676:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @676:9...
debug: !subseq[B](l1, l2) || {
  val bdg: Boolean = subseq[B](l2, l3)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @676:9:
debug:  => VALID
info Verified: 311 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @676:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @676:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @676:9...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h == l3.h || subseq[B](l2, l3.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @676:9:
debug:  => VALID
info Verified: 312 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h == l3.h || !subseq[B](l2, l3.t) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  size[B](l3.t) < size[B](l3)
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSubSeqTransitive @?:?:
debug:  => VALID
info Verified: 313 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubSeqTransitive @676:9...
debug: Cache miss: 'postcondition' VC for lemmaSubSeqTransitive @676:9...
debug:  - Now solving 'postcondition' VC for lemmaSubSeqTransitive @676:9...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h == l3.h || !subseq[B](l2, l3.t) || {
  val bdg: Unit = lemmaSubSeqTransitive[B](l1, l2, l3.t)
  assume(subseq[B](l1, l3.t))
  subseq[B](l1, l3)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubSeqTransitive @676:9:
debug:  => VALID
info Verified: 314 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @682:15...
debug: Cache hit: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @682:15...
info Verified: 315 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @682:15...
debug: Cache hit: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @682:15...
info Verified: 316 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || !subseq[B](l2.t, l3.t) || l1.h != l2.h || !subseq[B](l1.t, l2.t) || {
  val bdg: BigInt = size[B](l1.t)
  val bdg: BigInt = size[B](l2.t)
  val bdg: BigInt = size[B](l3.t)
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  val bdg: BigInt = size[B](l3)
  bdg < bdg || {
    val bdg: Boolean = bdg != bdg
    !bdg && bdg < bdg || !bdg && bdg == bdg && bdg < bdg
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSubSeqTransitive @?:?:
debug:  => VALID
info Verified: 317 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubSeqTransitive @682:15...
debug: Cache miss: 'postcondition' VC for lemmaSubSeqTransitive @682:15...
debug:  - Now solving 'postcondition' VC for lemmaSubSeqTransitive @682:15...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || !subseq[B](l2.t, l3.t) || l1.h != l2.h || !subseq[B](l1.t, l2.t) || {
  val bdg: Unit = lemmaSubSeqTransitive[B](l1.t, l2.t, l3.t)
  assume(subseq[B](l1.t, l3.t))
  subseq[B](l1, l3)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubSeqTransitive @682:15:
debug:  => VALID
info Verified: 318 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @684:15...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @684:15...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @684:15...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || !subseq[B](l2.t, l3.t) || l1.h != l2.h || subseq[B](l1.t, l2.t) || subseq[B](l1, l2.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @684:15:
debug:  => VALID
info Verified: 319 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @684:15...
debug: Cache hit: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @684:15...
info Verified: 320 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || !subseq[B](l2.t, l3.t) || l1.h != l2.h || subseq[B](l1.t, l2.t) || !subseq[B](l1, l2.t) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2.t)
  val bdg: BigInt = size[B](l3.t)
  val bdg: BigInt = size[B](l2)
  val bdg: BigInt = size[B](l3)
  bdg < bdg || bdg == bdg && bdg < bdg
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSubSeqTransitive @?:?:
debug:  => VALID
info Verified: 321 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubSeqTransitive @684:15...
debug: Cache miss: 'postcondition' VC for lemmaSubSeqTransitive @684:15...
debug:  - Now solving 'postcondition' VC for lemmaSubSeqTransitive @684:15...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || !subseq[B](l2.t, l3.t) || l1.h != l2.h || subseq[B](l1.t, l2.t) || !subseq[B](l1, l2.t) || {
  val bdg: Unit = lemmaSubSeqTransitive[B](l1, l2.t, l3.t)
  assume(subseq[B](l1, l3.t))
  subseq[B](l1, l3)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubSeqTransitive @684:15:
debug:  => VALID
info Verified: 322 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @687:13...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @687:13...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @687:13...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || !subseq[B](l2.t, l3.t) || l1.h == l2.h || subseq[B](l1, l2.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @687:13:
debug:  => VALID
info Verified: 323 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @687:13...
debug: Cache hit: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @687:13...
info Verified: 324 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || !subseq[B](l2.t, l3.t) || l1.h == l2.h || !subseq[B](l1, l2.t) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2.t)
  val bdg: BigInt = size[B](l3.t)
  val bdg: BigInt = size[B](l2)
  val bdg: BigInt = size[B](l3)
  bdg < bdg || bdg == bdg && bdg < bdg
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSubSeqTransitive @?:?:
debug:  => VALID
info Verified: 325 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubSeqTransitive @687:13...
debug: Cache miss: 'postcondition' VC for lemmaSubSeqTransitive @687:13...
debug:  - Now solving 'postcondition' VC for lemmaSubSeqTransitive @687:13...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || !subseq[B](l2.t, l3.t) || l1.h == l2.h || !subseq[B](l1, l2.t) || {
  val bdg: Unit = lemmaSubSeqTransitive[B](l1, l2.t, l3.t)
  assume(subseq[B](l1, l3.t))
  subseq[B](l1, l3)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubSeqTransitive @687:13:
debug:  => VALID
info Verified: 326 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @692:15...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @692:15...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @692:15...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || subseq[B](l2.t, l3.t) || l1.h != l2.h || {
  val bdg: Boolean = subseq[B](l1.t, l2)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @692:15:
debug:  => VALID
info Verified: 327 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @692:15...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @692:15...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @692:15...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || subseq[B](l2.t, l3.t) || l1.h != l2.h || !subseq[B](l1.t, l2) || subseq[B](l2, l3.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @692:15:
debug:  => VALID
info Verified: 328 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || subseq[B](l2.t, l3.t) || l1.h != l2.h || !subseq[B](l1.t, l2) || !subseq[B](l2, l3.t) || {
  val bdg: BigInt = size[B](l1.t)
  val bdg: BigInt = size[B](l2)
  val bdg: BigInt = size[B](l3.t)
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l3)
  bdg < bdg || bdg == bdg && bdg < bdg
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSubSeqTransitive @?:?:
debug:  => VALID
info Verified: 329 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubSeqTransitive @692:15...
debug: Cache miss: 'postcondition' VC for lemmaSubSeqTransitive @692:15...
debug:  - Now solving 'postcondition' VC for lemmaSubSeqTransitive @692:15...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || subseq[B](l2.t, l3.t) || l1.h != l2.h || !subseq[B](l1.t, l2) || !subseq[B](l2, l3.t) || {
  val bdg: Unit = lemmaSubSeqTransitive[B](l1.t, l2, l3.t)
  assume(subseq[B](l1.t, l3.t))
  subseq[B](l1, l3)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubSeqTransitive @692:15:
debug:  => VALID
info Verified: 330 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @694:15...
debug: Cache hit: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @694:15...
info Verified: 331 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @694:15...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @694:15...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @694:15...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || subseq[B](l2.t, l3.t) || l1.h != l2.h || subseq[B](l1.t, l2) || subseq[B](l2, l3.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @694:15:
debug:  => VALID
info Verified: 332 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || subseq[B](l2.t, l3.t) || l1.h != l2.h || subseq[B](l1.t, l2) || !subseq[B](l2, l3.t) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  size[B](l3.t) < size[B](l3)
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSubSeqTransitive @?:?:
debug:  => VALID
info Verified: 333 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubSeqTransitive @694:15...
debug: Cache miss: 'postcondition' VC for lemmaSubSeqTransitive @694:15...
debug:  - Now solving 'postcondition' VC for lemmaSubSeqTransitive @694:15...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || subseq[B](l2.t, l3.t) || l1.h != l2.h || subseq[B](l1.t, l2) || !subseq[B](l2, l3.t) || {
  val bdg: Unit = lemmaSubSeqTransitive[B](l1, l2, l3.t)
  assume(subseq[B](l1, l3.t))
  subseq[B](l1, l3)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubSeqTransitive @694:15:
debug:  => VALID
info Verified: 334 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @697:13...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @697:13...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @697:13...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || {
  val bdg: Boolean = subseq[B](l2.t, l3.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @697:13:
debug:  => VALID
info Verified: 335 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @697:13...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @697:13...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @697:13...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || subseq[B](l2.t, l3.t) || l1.h == l2.h || subseq[B](l2, l3.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive' VC for lemmaSubSeqTransitive @697:13:
debug:  => VALID
info Verified: 336 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSubSeqTransitive @?:?...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || subseq[B](l2.t, l3.t) || l1.h == l2.h || !subseq[B](l2, l3.t) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  size[B](l3.t) < size[B](l3)
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSubSeqTransitive @?:?:
debug:  => VALID
info Verified: 337 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubSeqTransitive @697:13...
debug: Cache miss: 'postcondition' VC for lemmaSubSeqTransitive @697:13...
debug:  - Now solving 'postcondition' VC for lemmaSubSeqTransitive @697:13...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || !l1.isInstanceOf[Cons] || !l2.isInstanceOf[Cons] || !l3.isInstanceOf[Cons] || l2.h != l3.h || subseq[B](l2.t, l3.t) || l1.h == l2.h || !subseq[B](l2, l3.t) || {
  val bdg: Unit = lemmaSubSeqTransitive[B](l1, l2, l3.t)
  assume(subseq[B](l1, l3.t))
  subseq[B](l1, l3)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubSeqTransitive @697:13:
debug:  => VALID
info Verified: 338 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubSeqTransitive @702:17...
debug: Cache miss: 'postcondition' VC for lemmaSubSeqTransitive @702:17...
debug:  - Now solving 'postcondition' VC for lemmaSubSeqTransitive @702:17...
debug: !subseq[B](l1, l2) || !subseq[B](l2, l3) || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h != l3.h || l1.isInstanceOf[Cons] && l2.isInstanceOf[Cons] && l3.isInstanceOf[Cons] && l2.h == l3.h || subseq[B](l1, l3)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubSeqTransitive @702:17:
debug:  => VALID
info Verified: 339 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainsForConcat[B](l,... (require 1/2))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainsForConcat[B](l,... (require 1/2))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainsForConcat[B](l,... (require 1/2))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || l != ++[B](Cons[B](l.h, Nil[B]()), l.t) || !forall[B](lB, (b: B) => !contains[B](l, b)) || forall[B](lB, (b: B) => !contains[B](l, b))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainsForConcat[B](l,... (require 1/2))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?:
debug:  => VALID
info Verified: 340 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainsForConcat[B](l,... (require 2/2))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainsForConcat[B](l,... (require 2/2))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainsForConcat[B](l,... (require 2/2))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || l != ++[B](Cons[B](l.h, Nil[B]()), l.t) || !forall[B](lB, (b: B) => !contains[B](l, b)) || {
  val bdg: Boolean = forall[B](lB, (b: B) => !contains[B](l, b))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainsForConcat[B](l,... (require 2/2))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?:
debug:  => VALID
info Verified: 341 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainsForSubseq[B](l,...)' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainsForSubseq[B](l,...)' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainsForSubseq[B](l,...)' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || {
  val bdg: List[B] = Cons[B](l.h, Nil[B]())
  val bdg: List[B] = ++[B](bdg, l.t)
  l != bdg || {
    val bdg: Unit = lemmaForallNotContainsForConcat[B](lB, l, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)))
    !forall[B](lB, (b: B) => !contains[B](bdg, b)) || forall[B](lB, (b: B) => !contains[B](bdg, b))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainsForSubseq[B](l,...)' VC for noDuplicateConcatListNotContainedPreservesBis @?:?:
debug:  => VALID
info Verified: 342 / 982
debug:  - Checking cache: 'precond. (call noDuplicateConcatListNotContainedPres... (require 1/4))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug: Cache miss: 'precond. (call noDuplicateConcatListNotContainedPres... (require 1/4))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug:  - Now solving 'precond. (call noDuplicateConcatListNotContainedPres... (require 1/4))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || {
  val bdg: List[B] = Cons[B](l.h, Nil[B]())
  val bdg: List[B] = ++[B](bdg, l.t)
  l != bdg || {
    val bdg: Unit = lemmaForallNotContainsForConcat[B](lB, l, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)))
    val bdg: Unit = lemmaForallNotContainsForSubseq[B](lB, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)) && forall[B](lB, (b: B) => !contains[B](l.t, b)))
    !noDuplicate[B](l.t) || !forall[B](lB, (b: B) => !contains[B](l.t, b)) || {
      val bdg: Boolean = forall[B](l.t, (b: B) => !contains[B](lB, b))
      true
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call noDuplicateConcatListNotContainedPres... (require 1/4))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?:
debug:  => VALID
info Verified: 343 / 982
debug:  - Checking cache: 'precond. (call noDuplicateConcatListNotContainedPres... (require 2/4))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug: Cache hit: 'precond. (call noDuplicateConcatListNotContainedPres... (require 2/4))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
info Verified: 344 / 982
debug:  - Checking cache: 'precond. (call noDuplicateConcatListNotContainedPres... (require 3/4))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug: Cache miss: 'precond. (call noDuplicateConcatListNotContainedPres... (require 3/4))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug:  - Now solving 'precond. (call noDuplicateConcatListNotContainedPres... (require 3/4))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || {
  val bdg: List[B] = Cons[B](l.h, Nil[B]())
  val bdg: List[B] = ++[B](bdg, l.t)
  l != bdg || {
    val bdg: Unit = lemmaForallNotContainsForConcat[B](lB, l, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)))
    val bdg: Unit = lemmaForallNotContainsForSubseq[B](lB, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)) && forall[B](lB, (b: B) => !contains[B](l.t, b)))
    !noDuplicate[B](l.t) || !forall[B](lB, (b: B) => !contains[B](l.t, b)) || !forall[B](l.t, (b: B) => !contains[B](lB, b)) || forall[B](lB, (b: B) => !contains[B](l.t, b))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call noDuplicateConcatListNotContainedPres... (require 3/4))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?:
debug:  => VALID
info Verified: 345 / 982
debug:  - Checking cache: 'precond. (call noDuplicateConcatListNotContainedPres... (require 4/4))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug: Cache miss: 'precond. (call noDuplicateConcatListNotContainedPres... (require 4/4))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug:  - Now solving 'precond. (call noDuplicateConcatListNotContainedPres... (require 4/4))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || {
  val bdg: List[B] = Cons[B](l.h, Nil[B]())
  val bdg: List[B] = ++[B](bdg, l.t)
  l != bdg || {
    val bdg: Unit = lemmaForallNotContainsForConcat[B](lB, l, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)))
    val bdg: Unit = lemmaForallNotContainsForSubseq[B](lB, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)) && forall[B](lB, (b: B) => !contains[B](l.t, b)))
    !noDuplicate[B](l.t) || !forall[B](lB, (b: B) => !contains[B](l.t, b)) || !forall[B](l.t, (b: B) => !contains[B](lB, b)) || !forall[B](lB, (b: B) => !contains[B](l.t, b)) || forall[B](l.t, (b: B) => !contains[B](lB, b))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call noDuplicateConcatListNotContainedPres... (require 4/4))' VC for noDuplicateConcatListNotContainedPreservesBis @?:?:
debug:  => VALID
info Verified: 346 / 982
debug:  - Checking cache: 'body assertion' VC for noDuplicateConcatListNotContainedPreservesBis @1050:16...
debug: Cache miss: 'body assertion' VC for noDuplicateConcatListNotContainedPreservesBis @1050:16...
debug:  - Now solving 'body assertion' VC for noDuplicateConcatListNotContainedPreservesBis @1050:16...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || l == ++[B](Cons[B](l.h, Nil[B]()), l.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for noDuplicateConcatListNotContainedPreservesBis @1050:16:
debug:  => VALID
info Verified: 347 / 982
debug:  - Checking cache: 'non-negative measure' VC for noDuplicateConcatListNotContainedPreservesBis @1057:35...
debug: Cache miss: 'non-negative measure' VC for noDuplicateConcatListNotContainedPreservesBis @1057:35...
debug:  - Now solving 'non-negative measure' VC for noDuplicateConcatListNotContainedPreservesBis @1057:35...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for noDuplicateConcatListNotContainedPreservesBis @1057:35:
debug:  => VALID
info Verified: 348 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaForallNotContainsForConcat' VC for noDuplicateConcatListNotContainedPreservesBis @1051:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaForallNotContainsForConcat' VC for noDuplicateConcatListNotContainedPreservesBis @1051:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaForallNotContainsForConcat' VC for noDuplicateConcatListNotContainedPreservesBis @1051:9...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || l != ++[B](Cons[B](l.h, Nil[B]()), l.t) || forall[B](lB, (b: B) => !contains[B](l, b))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaForallNotContainsForConcat' VC for noDuplicateConcatListNotContainedPreservesBis @1051:9:
debug:  => VALID
info Verified: 349 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaForallNotContainsForConcat' VC for noDuplicateConcatListNotContainedPreservesBis @1051:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaForallNotContainsForConcat' VC for noDuplicateConcatListNotContainedPreservesBis @1051:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaForallNotContainsForConcat' VC for noDuplicateConcatListNotContainedPreservesBis @1051:9...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || l != ++[B](Cons[B](l.h, Nil[B]()), l.t) || {
  val bdg: Boolean = forall[B](lB, (b: B) => !contains[B](l, b))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaForallNotContainsForConcat' VC for noDuplicateConcatListNotContainedPreservesBis @1051:9:
debug:  => VALID
info Verified: 350 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaForallNotContainsForSubseq' VC for noDuplicateConcatListNotContainedPreservesBis @1052:9...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaForallNotContainsForSubseq' VC for noDuplicateConcatListNotContainedPreservesBis @1052:9...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaForallNotContainsForSubseq' VC for noDuplicateConcatListNotContainedPreservesBis @1052:9...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || {
  val bdg: List[B] = Cons[B](l.h, Nil[B]())
  val bdg: List[B] = ++[B](bdg, l.t)
  l != bdg || {
    val bdg: Unit = lemmaForallNotContainsForConcat[B](lB, l, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)))
    forall[B](lB, (b: B) => !contains[B](bdg, b))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaForallNotContainsForSubseq' VC for noDuplicateConcatListNotContainedPreservesBis @1052:9:
debug:  => VALID
info Verified: 351 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || {
  val bdg: List[B] = Cons[B](l.h, Nil[B]())
  val bdg: List[B] = ++[B](bdg, l.t)
  l != bdg || {
    val bdg: Unit = lemmaForallNotContainsForConcat[B](lB, l, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)))
    val bdg: Unit = lemmaForallNotContainsForSubseq[B](lB, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)) && forall[B](lB, (b: B) => !contains[B](l.t, b)))
    noDuplicate[B](l.t)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9:
debug:  => VALID
info Verified: 352 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || {
  val bdg: List[B] = Cons[B](l.h, Nil[B]())
  val bdg: List[B] = ++[B](bdg, l.t)
  l != bdg || {
    val bdg: Unit = lemmaForallNotContainsForConcat[B](lB, l, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)))
    val bdg: Unit = lemmaForallNotContainsForSubseq[B](lB, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)) && forall[B](lB, (b: B) => !contains[B](l.t, b)))
    val bdg: Boolean = noDuplicate[B](l.t)
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9:
debug:  => VALID
info Verified: 353 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9...
debug: Cache miss: 'body assertion: Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9...
debug:  - Now solving 'body assertion: Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || {
  val bdg: List[B] = Cons[B](l.h, Nil[B]())
  val bdg: List[B] = ++[B](bdg, l.t)
  l != bdg || {
    val bdg: Unit = lemmaForallNotContainsForConcat[B](lB, l, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)))
    val bdg: Unit = lemmaForallNotContainsForSubseq[B](lB, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)) && forall[B](lB, (b: B) => !contains[B](l.t, b)))
    !noDuplicate[B](l.t) || forall[B](lB, (b: B) => !contains[B](l.t, b))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9:
debug:  => VALID
info Verified: 354 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9...
debug: Cache miss: 'body assertion: Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9...
debug:  - Now solving 'body assertion: Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || {
  val bdg: List[B] = Cons[B](l.h, Nil[B]())
  val bdg: List[B] = ++[B](bdg, l.t)
  l != bdg || {
    val bdg: Unit = lemmaForallNotContainsForConcat[B](lB, l, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)))
    val bdg: Unit = lemmaForallNotContainsForSubseq[B](lB, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)) && forall[B](lB, (b: B) => !contains[B](l.t, b)))
    !noDuplicate[B](l.t) || !forall[B](lB, (b: B) => !contains[B](l.t, b)) || forall[B](l.t, (b: B) => !contains[B](lB, b))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9:
debug:  => VALID
info Verified: 355 / 982
debug:  - Checking cache: 'measure decreases' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug: Cache miss: 'measure decreases' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug:  - Now solving 'measure decreases' VC for noDuplicateConcatListNotContainedPreservesBis @?:?...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || {
  val bdg: List[B] = Cons[B](l.h, Nil[B]())
  val bdg: List[B] = ++[B](bdg, l.t)
  l != bdg || {
    val bdg: Unit = lemmaForallNotContainsForConcat[B](lB, l, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)))
    val bdg: Unit = lemmaForallNotContainsForSubseq[B](lB, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)) && forall[B](lB, (b: B) => !contains[B](l.t, b)))
    !noDuplicate[B](l.t) || !forall[B](lB, (b: B) => !contains[B](l.t, b)) || !forall[B](l.t, (b: B) => !contains[B](lB, b)) || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for noDuplicateConcatListNotContainedPreservesBis @?:?:
debug:  => VALID
info Verified: 356 / 982
debug:  - Checking cache: 'postcondition' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9...
debug: Cache miss: 'postcondition' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9...
debug:  - Now solving 'postcondition' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || !l.isInstanceOf[Cons] || {
  val bdg: List[B] = Cons[B](l.h, Nil[B]())
  val bdg: List[B] = ++[B](bdg, l.t)
  l != bdg || {
    val bdg: Unit = lemmaForallNotContainsForConcat[B](lB, l, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)))
    val bdg: Unit = lemmaForallNotContainsForSubseq[B](lB, bdg, l.t)
    assume(forall[B](lB, (b: B) => !contains[B](bdg, b)) && forall[B](lB, (b: B) => !contains[B](l.t, b)))
    !noDuplicate[B](l.t) || !forall[B](lB, (b: B) => !contains[B](l.t, b)) || !forall[B](l.t, (b: B) => !contains[B](lB, b)) || {
      val bdg: Unit = noDuplicateConcatListNotContainedPreservesBis[B](l.t, lB)
      assume(noDuplicate[B](++[B](l.t, lB)))
      noDuplicate[B](++[B](l, lB))
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for noDuplicateConcatListNotContainedPreservesBis @1053:9:
debug:  => VALID
info Verified: 357 / 982
debug:  - Checking cache: 'postcondition' VC for noDuplicateConcatListNotContainedPreservesBis @1055:21...
debug: Cache miss: 'postcondition' VC for noDuplicateConcatListNotContainedPreservesBis @1055:21...
debug:  - Now solving 'postcondition' VC for noDuplicateConcatListNotContainedPreservesBis @1055:21...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !forall[B](l, (b: B) => !contains[B](lB, b)) || l.isInstanceOf[Cons] || noDuplicate[B](++[B](l, lB))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for noDuplicateConcatListNotContainedPreservesBis @1055:21:
debug:  => VALID
info Verified: 358 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for noDuplicateConcatListNotContainedPreservesBis @1048:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for noDuplicateConcatListNotContainedPreservesBis @1048:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for noDuplicateConcatListNotContainedPreservesBis @1048:5...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || {
  val bdg: Boolean = forall[B](l, (b: B) => !contains[B](lB, b))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for noDuplicateConcatListNotContainedPreservesBis @1048:5:
debug:  => VALID
info Verified: 359 / 982
debug:  - Checking cache: 'postcondition' VC for noDuplicateConcatListNotContainedPreservesBis @1048:5...
debug: Cache hit: 'postcondition' VC for noDuplicateConcatListNotContainedPreservesBis @1048:5...
info Verified: 360 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainsForSubseq[B]((s...)' VC for lemmaForallNotContainsForSubseq @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainsForSubseq[B]((s...)' VC for lemmaForallNotContainsForSubseq @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainsForSubseq[B]((s...)' VC for lemmaForallNotContainsForSubseq @?:?...
debug: !forall[B](l, (b: B) => !contains[B](++[B](l1, l2), b)) || !l.isInstanceOf[Cons] || forall[B](l.t, (b: B) => !contains[B](++[B](l1, l2), b))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainsForSubseq[B]((s...)' VC for lemmaForallNotContainsForSubseq @?:?:
debug:  => VALID
info Verified: 361 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallNotContainsForSubseq @926:50...
debug: Cache miss: 'non-negative measure' VC for lemmaForallNotContainsForSubseq @926:50...
debug:  - Now solving 'non-negative measure' VC for lemmaForallNotContainsForSubseq @926:50...
debug: !forall[B](l, (b: B) => !contains[B](++[B](l1, l2), b)) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaForallNotContainsForSubseq @926:50:
debug:  => VALID
info Verified: 362 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallNotContainsForSubseq @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaForallNotContainsForSubseq @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaForallNotContainsForSubseq @?:?...
debug: !forall[B](l, (b: B) => !contains[B](++[B](l1, l2), b)) || !l.isInstanceOf[Cons] || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallNotContainsForSubseq @?:?:
debug:  => VALID
info Verified: 363 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsForSubseq @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallNotContainsForSubseq @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallNotContainsForSubseq @?:?...
debug: !forall[B](l, (b: B) => !contains[B](++[B](l1, l2), b)) || !l.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaForallNotContainsForSubseq[B](l.t, l1, l2)
  forall[B](l, (b: B) => !contains[B](l1, b)) && forall[B](l, (b: B) => !contains[B](l2, b))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallNotContainsForSubseq @?:?:
debug:  => VALID
info Verified: 364 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsForSubseq @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallNotContainsForSubseq @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallNotContainsForSubseq @?:?...
debug: !forall[B](l, (b: B) => !contains[B](++[B](l1, l2), b)) || l.isInstanceOf[Cons] || forall[B](l, (b: B) => !contains[B](l1, b)) && forall[B](l, (b: B) => !contains[B](l2, b))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallNotContainsForSubseq @?:?:
debug:  => VALID
info Verified: 365 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsForSubseq @?:?...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsForSubseq @?:?...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsForSubseq @?:?...
debug: val bdg: Boolean = forall[B](l, (b: B) => !contains[B](++[B](l1, l2), b))
true
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsForSubseq @?:?:
debug:  => VALID
info Verified: 366 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsForSubseq @?:?...
debug: Cache hit: 'postcondition' VC for lemmaForallNotContainsForSubseq @?:?...
info Verified: 367 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 1/2))' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 1/2))' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 1/2))' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug: !forall[B](l, (bb: B) => !contains[B](lRef, bb)) || contains[B](l, b) || !l.isInstanceOf[Cons] || forall[B](l.t, (bb: B) => !contains[B](lRef, bb))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 1/2))' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?:
debug:  => VALID
info Verified: 368 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 2/2))' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 2/2))' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 2/2))' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug: !forall[B](l, (bb: B) => !contains[B](lRef, bb)) || contains[B](l, b) || !l.isInstanceOf[Cons] || !forall[B](l.t, (bb: B) => !contains[B](lRef, bb)) || !contains[B](l.t, b)
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainsPreservedAddNew... (require 2/2))' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?:
debug:  => VALID
info Verified: 369 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @964:69...
debug: Cache miss: 'non-negative measure' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @964:69...
debug:  - Now solving 'non-negative measure' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @964:69...
debug: !forall[B](l, (bb: B) => !contains[B](lRef, bb)) || contains[B](l, b) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @964:69:
debug:  => VALID
info Verified: 370 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug: !forall[B](l, (bb: B) => !contains[B](lRef, bb)) || contains[B](l, b) || !l.isInstanceOf[Cons] || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?:
debug:  => VALID
info Verified: 371 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug: !forall[B](l, (bb: B) => !contains[B](lRef, bb)) || contains[B](l, b) || !l.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaForallNotContainsPreservedAddNewElmtInRefList[B](l.t, lRef, b)
  forall[B](l, (bb: B) => !contains[B](Cons[B](b, lRef), bb))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?:
debug:  => VALID
info Verified: 372 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug: !forall[B](l, (bb: B) => !contains[B](lRef, bb)) || contains[B](l, b) || l.isInstanceOf[Cons] || forall[B](l, (bb: B) => !contains[B](Cons[B](b, lRef), bb))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?:
debug:  => VALID
info Verified: 373 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug: !forall[B](l, (bb: B) => !contains[B](lRef, bb)) || {
  val bdg: Boolean = contains[B](l, b)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?:
debug:  => VALID
info Verified: 374 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
debug: Cache hit: 'postcondition' VC for lemmaForallNotContainsPreservedAddNewElmtInRefList @?:?...
info Verified: 375 / 982
debug:  - Checking cache: 'precond. (call lemmaConcatTwoListsWhichNotContainThe... (require 1/2))' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @?:?...
debug: Cache miss: 'precond. (call lemmaConcatTwoListsWhichNotContainThe... (require 1/2))' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @?:?...
debug:  - Now solving 'precond. (call lemmaConcatTwoListsWhichNotContainThe... (require 1/2))' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @?:?...
debug: contains[B](l1, b) || contains[B](l2, b) || l1.isInstanceOf[Cons] && l1.h == b || !l1.isInstanceOf[Cons] || {
  val bdg: Boolean = contains[B](l1.t, b)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaConcatTwoListsWhichNotContainThe... (require 1/2))' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @?:?:
debug:  => VALID
info Verified: 376 / 982
debug:  - Checking cache: 'precond. (call lemmaConcatTwoListsWhichNotContainThe... (require 2/2))' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @?:?...
debug: Cache hit: 'precond. (call lemmaConcatTwoListsWhichNotContainThe... (require 2/2))' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @?:?...
info Verified: 377 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @763:17...
debug: Cache miss: 'non-negative measure' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @763:17...
debug:  - Now solving 'non-negative measure' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @763:17...
debug: contains[B](l1, b) || contains[B](l2, b) || ListPrimitiveSize[B](l1) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @763:17:
debug:  => VALID
info Verified: 378 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of check' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @758:39...
debug: Cache miss: 'body assertion: Inlined precondition of check' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @758:39...
debug:  - Now solving 'body assertion: Inlined precondition of check' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @758:39...
debug: contains[B](l1, b) || contains[B](l2, b) || !l1.isInstanceOf[Cons] || l1.h != b
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of check' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @758:39:
debug:  => VALID
info Verified: 379 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @758:39...
debug: Cache miss: 'postcondition' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @758:39...
debug:  - Now solving 'postcondition' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @758:39...
debug: contains[B](l1, b) || {
  val bdg: Boolean = contains[B](l2, b)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @758:39:
debug:  => VALID
info Verified: 380 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaConcatTwoListsWhichNotContainThenTotNotContain' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @760:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaConcatTwoListsWhichNotContainThenTotNotContain' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @760:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaConcatTwoListsWhichNotContainThenTotNotContain' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @760:9...
debug: contains[B](l1, b) || contains[B](l2, b) || l1.isInstanceOf[Cons] && l1.h == b || !l1.isInstanceOf[Cons] || !contains[B](l1.t, b)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaConcatTwoListsWhichNotContainThenTotNotContain' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @760:9:
debug:  => VALID
info Verified: 381 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaConcatTwoListsWhichNotContainThenTotNotContain' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @760:9...
debug: Cache hit: 'body assertion: Inlined precondition (2/2) of lemmaConcatTwoListsWhichNotContainThenTotNotContain' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @760:9...
info Verified: 382 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @?:?...
debug: contains[B](l1, b) || contains[B](l2, b) || l1.isInstanceOf[Cons] && l1.h == b || !l1.isInstanceOf[Cons] || contains[B](l1.t, b) || ListPrimitiveSize[B](l1.t) < ListPrimitiveSize[B](l1)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @?:?:
debug:  => VALID
info Verified: 383 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @760:9...
debug: Cache miss: 'postcondition' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @760:9...
debug:  - Now solving 'postcondition' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @760:9...
debug: contains[B](l1, b) || contains[B](l2, b) || l1.isInstanceOf[Cons] && l1.h == b || !l1.isInstanceOf[Cons] || contains[B](l1.t, b) || {
  val bdg: Unit = lemmaConcatTwoListsWhichNotContainThenTotNotContain[B](l1.t, l2, b)
  assume(!contains[B](++[B](l1.t, l2), b))
  !contains[B](++[B](l1, l2), b)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @760:9:
debug:  => VALID
info Verified: 384 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @761:21...
debug: Cache miss: 'postcondition' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @761:21...
debug:  - Now solving 'postcondition' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @761:21...
debug: contains[B](l1, b) || contains[B](l2, b) || l1.isInstanceOf[Cons] && l1.h == b || l1.isInstanceOf[Cons] || !contains[B](++[B](l1, l2), b)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @761:21:
debug:  => VALID
info Verified: 385 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @757:5...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @757:5...
info Verified: 386 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @757:5...
debug: Cache hit: 'postcondition' VC for lemmaConcatTwoListsWhichNotContainThenTotNotContain @757:5...
info Verified: 387 / 982
debug:  - Checking cache: 'precond. (call notContainsAThenTailNotContains[B]((s...)' VC for notContainsAThenTailNotContains @?:?...
debug: Cache miss: 'precond. (call notContainsAThenTailNotContains[B]((s...)' VC for notContainsAThenTailNotContains @?:?...
debug:  - Now solving 'precond. (call notContainsAThenTailNotContains[B]((s...)' VC for notContainsAThenTailNotContains @?:?...
debug: contains[B](l, b) || !l.isInstanceOf[Cons] || !contains[B](l.t, b)
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call notContainsAThenTailNotContains[B]((s...)' VC for notContainsAThenTailNotContains @?:?:
debug:  => VALID
info Verified: 388 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for notContainsAThenTailNotContains @1144:29...
debug: Cache miss: 'precond. (call tail[B](l))' VC for notContainsAThenTailNotContains @1144:29...
debug:  - Now solving 'precond. (call tail[B](l))' VC for notContainsAThenTailNotContains @1144:29...
debug: contains[B](l, b) || !l.isInstanceOf[Cons] || {
  val bdg: Unit = notContainsAThenTailNotContains[B](l.t, b)
  isEmpty[B](l) || l != Nil[B]()
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for notContainsAThenTailNotContains @1144:29:
debug:  => VALID
info Verified: 389 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for notContainsAThenTailNotContains @1144:29...
debug: Cache miss: 'precond. (call tail[B](l))' VC for notContainsAThenTailNotContains @1144:29...
debug:  - Now solving 'precond. (call tail[B](l))' VC for notContainsAThenTailNotContains @1144:29...
debug: contains[B](l, b) || l.isInstanceOf[Cons] || isEmpty[B](l) || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for notContainsAThenTailNotContains @1144:29:
debug:  => VALID
info Verified: 390 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for notContainsAThenTailNotContains @1144:29...
debug: Cache hit: 'precond. (call tail[B](l))' VC for notContainsAThenTailNotContains @1144:29...
info Verified: 391 / 982
debug:  - Checking cache: 'non-negative measure' VC for notContainsAThenTailNotContains @1139:15...
debug: Cache miss: 'non-negative measure' VC for notContainsAThenTailNotContains @1139:15...
debug:  - Now solving 'non-negative measure' VC for notContainsAThenTailNotContains @1139:15...
debug: contains[B](l, b) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for notContainsAThenTailNotContains @1139:15:
debug:  => VALID
info Verified: 392 / 982
debug:  - Checking cache: 'measure decreases' VC for notContainsAThenTailNotContains @?:?...
debug: Cache miss: 'measure decreases' VC for notContainsAThenTailNotContains @?:?...
debug:  - Now solving 'measure decreases' VC for notContainsAThenTailNotContains @?:?...
debug: contains[B](l, b) || !l.isInstanceOf[Cons] || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for notContainsAThenTailNotContains @?:?:
debug:  => VALID
info Verified: 393 / 982
debug:  - Checking cache: 'postcondition' VC for notContainsAThenTailNotContains @?:?...
debug: Cache miss: 'postcondition' VC for notContainsAThenTailNotContains @?:?...
debug:  - Now solving 'postcondition' VC for notContainsAThenTailNotContains @?:?...
debug: contains[B](l, b) || !l.isInstanceOf[Cons] || {
  val bdg: Unit = notContainsAThenTailNotContains[B](l.t, b)
  isEmpty[B](l) || !contains[B](tail[B](l), b)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for notContainsAThenTailNotContains @?:?:
debug:  => VALID
info Verified: 394 / 982
debug:  - Checking cache: 'postcondition' VC for notContainsAThenTailNotContains @?:?...
debug: Cache miss: 'postcondition' VC for notContainsAThenTailNotContains @?:?...
debug:  - Now solving 'postcondition' VC for notContainsAThenTailNotContains @?:?...
debug: contains[B](l, b) || l.isInstanceOf[Cons] || isEmpty[B](l) || !contains[B](tail[B](l), b)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for notContainsAThenTailNotContains @?:?:
debug:  => VALID
info Verified: 395 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for notContainsAThenTailNotContains @?:?...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for notContainsAThenTailNotContains @?:?...
info Verified: 396 / 982
debug:  - Checking cache: 'postcondition' VC for notContainsAThenTailNotContains @?:?...
debug: Cache hit: 'postcondition' VC for notContainsAThenTailNotContains @?:?...
info Verified: 397 / 982
debug:  - Checking cache: 'precond. (call forallContained[B](l1, (b: B) => cont...)' VC for lemmaForallContainsPreservedIfSameContent @918:9...
debug: Cache miss: 'precond. (call forallContained[B](l1, (b: B) => cont...)' VC for lemmaForallContainsPreservedIfSameContent @918:9...
debug:  - Now solving 'precond. (call forallContained[B](l1, (b: B) => cont...)' VC for lemmaForallContainsPreservedIfSameContent @918:9...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || !content[B](l2).subsetOf(content[B](l1)) || l2.isInstanceOf[Nil] || forall[B](l1, (b: B) => contains[B](lRef, b)) && contains[B](l1, l2.h)
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call forallContained[B](l1, (b: B) => cont...)' VC for lemmaForallContainsPreservedIfSameContent @918:9:
debug:  => VALID
info Verified: 398 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsPreservedIfSameCon... (require 1/2))' VC for lemmaForallContainsPreservedIfSameContent @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsPreservedIfSameCon... (require 1/2))' VC for lemmaForallContainsPreservedIfSameContent @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsPreservedIfSameCon... (require 1/2))' VC for lemmaForallContainsPreservedIfSameContent @?:?...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || {
  val bdg: Set[B] = content[B](l2)
  val bdg: Set[B] = content[B](l1)
  !bdg.subsetOf(bdg) || l2.isInstanceOf[Nil] || {
    val bdg: Unit = forallContained[B](l1, (b: B) => contains[B](lRef, b), l2.h)
    !forall[B](l1, (b: B) => contains[B](lRef, b)) || !content[B](l2.t).subsetOf(bdg) || forall[B](l1, (b: B) => contains[B](lRef, b))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsPreservedIfSameCon... (require 1/2))' VC for lemmaForallContainsPreservedIfSameContent @?:?:
debug:  => VALID
info Verified: 399 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsPreservedIfSameCon... (require 2/2))' VC for lemmaForallContainsPreservedIfSameContent @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsPreservedIfSameCon... (require 2/2))' VC for lemmaForallContainsPreservedIfSameContent @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsPreservedIfSameCon... (require 2/2))' VC for lemmaForallContainsPreservedIfSameContent @?:?...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || {
  val bdg: Set[B] = content[B](l2)
  val bdg: Set[B] = content[B](l1)
  !bdg.subsetOf(bdg) || l2.isInstanceOf[Nil] || {
    val bdg: Unit = forallContained[B](l1, (b: B) => contains[B](lRef, b), l2.h)
    !forall[B](l1, (b: B) => contains[B](lRef, b)) || !content[B](l2.t).subsetOf(bdg) || {
      val bdg: Boolean = forall[B](l1, (b: B) => contains[B](lRef, b))
      true
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsPreservedIfSameCon... (require 2/2))' VC for lemmaForallContainsPreservedIfSameContent @?:?:
debug:  => VALID
info Verified: 400 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallContainsPreservedIfSameContent @922:15...
debug: Cache miss: 'non-negative measure' VC for lemmaForallContainsPreservedIfSameContent @922:15...
debug:  - Now solving 'non-negative measure' VC for lemmaForallContainsPreservedIfSameContent @922:15...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || !content[B](l2).subsetOf(content[B](l1)) || ListPrimitiveSize[B](l2) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaForallContainsPreservedIfSameContent @922:15:
debug:  => VALID
info Verified: 401 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsPreservedIfSameContent @916:21...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsPreservedIfSameContent @916:21...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsPreservedIfSameContent @916:21...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || !content[B](l2).subsetOf(content[B](l1)) || !l2.isInstanceOf[Nil] || forall[B](l2, (b: B) => contains[B](lRef, b))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsPreservedIfSameContent @916:21:
debug:  => VALID
info Verified: 402 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaForallContainsPreservedIfSameContent' VC for lemmaForallContainsPreservedIfSameContent @919:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaForallContainsPreservedIfSameContent' VC for lemmaForallContainsPreservedIfSameContent @919:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaForallContainsPreservedIfSameContent' VC for lemmaForallContainsPreservedIfSameContent @919:9...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || !content[B](l2).subsetOf(content[B](l1)) || l2.isInstanceOf[Nil] || {
  val bdg: Unit = forallContained[B](l1, (b: B) => contains[B](lRef, b), l2.h)
  forall[B](l1, (b: B) => contains[B](lRef, b))
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaForallContainsPreservedIfSameContent' VC for lemmaForallContainsPreservedIfSameContent @919:9:
debug:  => VALID
info Verified: 403 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaForallContainsPreservedIfSameContent' VC for lemmaForallContainsPreservedIfSameContent @919:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaForallContainsPreservedIfSameContent' VC for lemmaForallContainsPreservedIfSameContent @919:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaForallContainsPreservedIfSameContent' VC for lemmaForallContainsPreservedIfSameContent @919:9...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || {
  val bdg: Set[B] = content[B](l2)
  val bdg: Set[B] = content[B](l1)
  !bdg.subsetOf(bdg) || l2.isInstanceOf[Nil] || {
    val bdg: Unit = forallContained[B](l1, (b: B) => contains[B](lRef, b), l2.h)
    !forall[B](l1, (b: B) => contains[B](lRef, b)) || content[B](l2.t).subsetOf(bdg)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaForallContainsPreservedIfSameContent' VC for lemmaForallContainsPreservedIfSameContent @919:9:
debug:  => VALID
info Verified: 404 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallContainsPreservedIfSameContent @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaForallContainsPreservedIfSameContent @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaForallContainsPreservedIfSameContent @?:?...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || {
  val bdg: Set[B] = content[B](l2)
  val bdg: Set[B] = content[B](l1)
  !bdg.subsetOf(bdg) || l2.isInstanceOf[Nil] || {
    val bdg: Unit = forallContained[B](l1, (b: B) => contains[B](lRef, b), l2.h)
    !forall[B](l1, (b: B) => contains[B](lRef, b)) || !content[B](l2.t).subsetOf(bdg) || ListPrimitiveSize[B](l2.t) < ListPrimitiveSize[B](l2)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallContainsPreservedIfSameContent @?:?:
debug:  => VALID
info Verified: 405 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsPreservedIfSameContent @919:9...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsPreservedIfSameContent @919:9...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsPreservedIfSameContent @919:9...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || {
  val bdg: Set[B] = content[B](l2)
  val bdg: Set[B] = content[B](l1)
  !bdg.subsetOf(bdg) || l2.isInstanceOf[Nil] || {
    val bdg: Unit = forallContained[B](l1, (b: B) => contains[B](lRef, b), l2.h)
    !forall[B](l1, (b: B) => contains[B](lRef, b)) || !content[B](l2.t).subsetOf(bdg) || {
      val bdg: Unit = lemmaForallContainsPreservedIfSameContent[B](l1, l2.t, lRef)
      assume(forall[B](l2.t, (b: B) => contains[B](lRef, b)))
      forall[B](l2, (b: B) => contains[B](lRef, b))
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsPreservedIfSameContent @919:9:
debug:  => VALID
info Verified: 406 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallContainsPreservedIfSameContent @915:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaForallContainsPreservedIfSameContent @915:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaForallContainsPreservedIfSameContent @915:5...
debug: !forall[B](l1, (b: B) => contains[B](lRef, b)) || {
  val bdg: Set[B] = content[B](l2)
  val bdg: Set[B] = content[B](l1)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaForallContainsPreservedIfSameContent @915:5:
debug:  => VALID
info Verified: 407 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsPreservedIfSameContent @915:5...
debug: Cache hit: 'postcondition' VC for lemmaForallContainsPreservedIfSameContent @915:5...
info Verified: 408 / 982
debug:  - Checking cache: 'precond. (call tail[B](s1))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @556:11...
debug: Cache miss: 'precond. (call tail[B](s1))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @556:11...
debug:  - Now solving 'precond. (call tail[B](s1))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @556:11...
debug: !isPrefix[B](s1, l) || !isPrefix[B](s2, l) || size[B](s2) > size[B](s1) || !s2.isInstanceOf[Cons] || s1 != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](s1))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @556:11:
debug:  => VALID
info Verified: 409 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @558:11...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @558:11...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @558:11...
debug: !isPrefix[B](s1, l) || !isPrefix[B](s2, l) || size[B](s2) > size[B](s1) || !s2.isInstanceOf[Cons] || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @558:11:
debug:  => VALID
info Verified: 410 / 982
debug:  - Checking cache: 'precond. (call lemmaPrefixFromSameListAndStrictlySma... (require 1/3))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @?:?...
debug: Cache miss: 'precond. (call lemmaPrefixFromSameListAndStrictlySma... (require 1/3))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @?:?...
debug:  - Now solving 'precond. (call lemmaPrefixFromSameListAndStrictlySma... (require 1/3))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @?:?...
debug: !isPrefix[B](s1, l) || !isPrefix[B](s2, l) || size[B](s2) > size[B](s1) || !s2.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](s1)
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](bdg, bdg) || !isPrefix[B](s2.t, bdg) || {
    val bdg: BigInt = size[B](s2.t)
    val bdg: BigInt = size[B](bdg)
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaPrefixFromSameListAndStrictlySma... (require 1/3))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @?:?:
debug:  => VALID
info Verified: 411 / 982
debug:  - Checking cache: 'precond. (call lemmaPrefixFromSameListAndStrictlySma... (require 2/3))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @?:?...
debug: Cache hit: 'precond. (call lemmaPrefixFromSameListAndStrictlySma... (require 2/3))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @?:?...
info Verified: 412 / 982
debug:  - Checking cache: 'precond. (call lemmaPrefixFromSameListAndStrictlySma... (require 3/3))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @?:?...
debug: Cache hit: 'precond. (call lemmaPrefixFromSameListAndStrictlySma... (require 3/3))' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @?:?...
info Verified: 413 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @558:11...
debug: Cache miss: 'non-negative measure' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @558:11...
debug:  - Now solving 'non-negative measure' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @558:11...
debug: !isPrefix[B](s1, l) || !isPrefix[B](s2, l) || size[B](s2) > size[B](s1) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @558:11:
debug:  => VALID
info Verified: 414 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/3) of lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/3) of lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/3) of lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9...
debug: !isPrefix[B](s1, l) || !isPrefix[B](s2, l) || size[B](s2) > size[B](s1) || !s2.isInstanceOf[Cons] || isPrefix[B](tail[B](s1), tail[B](l))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/3) of lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9:
debug:  => VALID
info Verified: 415 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/3) of lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/3) of lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/3) of lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9...
debug: !isPrefix[B](s1, l) || !isPrefix[B](s2, l) || size[B](s2) > size[B](s1) || !s2.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](tail[B](s1), bdg) || isPrefix[B](s2.t, bdg)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/3) of lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9:
debug:  => VALID
info Verified: 416 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (3/3) of lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9...
debug: Cache miss: 'body assertion: Inlined precondition (3/3) of lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9...
debug:  - Now solving 'body assertion: Inlined precondition (3/3) of lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9...
debug: !isPrefix[B](s1, l) || !isPrefix[B](s2, l) || size[B](s2) > size[B](s1) || !s2.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](s1)
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](bdg, bdg) || !isPrefix[B](s2.t, bdg) || size[B](s2.t) <= size[B](bdg)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (3/3) of lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9:
debug:  => VALID
info Verified: 417 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @?:?...
debug: !isPrefix[B](s1, l) || !isPrefix[B](s2, l) || size[B](s2) > size[B](s1) || !s2.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](s1)
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](bdg, bdg) || !isPrefix[B](s2.t, bdg) || size[B](s2.t) > size[B](bdg) || ListPrimitiveSize[B](bdg) < ListPrimitiveSize[B](l)
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @?:?:
debug:  => VALID
info Verified: 418 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9...
debug: Cache miss: 'postcondition' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9...
debug:  - Now solving 'postcondition' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9...
debug: !isPrefix[B](s1, l) || !isPrefix[B](s2, l) || size[B](s2) > size[B](s1) || !s2.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](s1)
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](bdg, bdg) || !isPrefix[B](s2.t, bdg) || size[B](s2.t) > size[B](bdg) || {
    val bdg: Unit = lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther[B](bdg, s2.t, bdg)
    assume(isPrefix[B](s2.t, bdg))
    isPrefix[B](s2, s1)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @555:9:
debug:  => VALID
info Verified: 419 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @560:18...
debug: Cache miss: 'postcondition' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @560:18...
debug:  - Now solving 'postcondition' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @560:18...
debug: !isPrefix[B](s1, l) || !isPrefix[B](s2, l) || size[B](s2) > size[B](s1) || s2.isInstanceOf[Cons] || isPrefix[B](s2, s1)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @560:18:
debug:  => VALID
info Verified: 420 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @553:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @553:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @553:5...
debug: !isPrefix[B](s1, l) || !isPrefix[B](s2, l) || {
  val bdg: BigInt = size[B](s2)
  val bdg: BigInt = size[B](s1)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @553:5:
debug:  => VALID
info Verified: 421 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @553:5...
debug: Cache hit: 'postcondition' VC for lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther @553:5...
info Verified: 422 / 982
debug:  - Checking cache: 'precond. (call lemmaNoDuplicateConcatThenForallNotCo...)' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug: Cache miss: 'precond. (call lemmaNoDuplicateConcatThenForallNotCo...)' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug:  - Now solving 'precond. (call lemmaNoDuplicateConcatThenForallNotCo...)' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug: !noDuplicate[B](++[B](l1, l2)) || !l1.isInstanceOf[Cons] || noDuplicate[B](++[B](l1.t, l2))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaNoDuplicateConcatThenForallNotCo...)' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?:
debug:  => VALID
info Verified: 423 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaNoDuplicateConcatThenForallNotContains @957:62...
debug: Cache miss: 'non-negative measure' VC for lemmaNoDuplicateConcatThenForallNotContains @957:62...
debug:  - Now solving 'non-negative measure' VC for lemmaNoDuplicateConcatThenForallNotContains @957:62...
debug: !noDuplicate[B](++[B](l1, l2)) || ListPrimitiveSize[B](l1) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaNoDuplicateConcatThenForallNotContains @957:62:
debug:  => VALID
info Verified: 424 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug: !noDuplicate[B](++[B](l1, l2)) || !l1.isInstanceOf[Cons] || ListPrimitiveSize[B](l1.t) < ListPrimitiveSize[B](l1)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?:
debug:  => VALID
info Verified: 425 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug: Cache miss: 'postcondition' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug:  - Now solving 'postcondition' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug: !noDuplicate[B](++[B](l1, l2)) || !l1.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaNoDuplicateConcatThenForallNotContains[B](l1.t, l2)
  forall[B](l1, (b: B) => !contains[B](l2, b))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?:
debug:  => VALID
info Verified: 426 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug: Cache miss: 'postcondition' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug:  - Now solving 'postcondition' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug: !noDuplicate[B](++[B](l1, l2)) || l1.isInstanceOf[Cons] || forall[B](l1, (b: B) => !contains[B](l2, b))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?:
debug:  => VALID
info Verified: 427 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug: val bdg: Boolean = noDuplicate[B](++[B](l1, l2))
true
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?:
debug:  => VALID
info Verified: 428 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
debug: Cache hit: 'postcondition' VC for lemmaNoDuplicateConcatThenForallNotContains @?:?...
info Verified: 429 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaRemoveLastFromBothSidePreservesEq @443:74...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaRemoveLastFromBothSidePreservesEq @443:74...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaRemoveLastFromBothSidePreservesEq @443:74...
debug: ++[B](p, s) != l || isEmpty[B](s) || !p.isInstanceOf[Cons] || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaRemoveLastFromBothSidePreservesEq @443:74:
debug:  => VALID
info Verified: 430 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveLastFromBothSidePreservesE... (require 1/2))' VC for lemmaRemoveLastFromBothSidePreservesEq @?:?...
debug: Cache miss: 'precond. (call lemmaRemoveLastFromBothSidePreservesE... (require 1/2))' VC for lemmaRemoveLastFromBothSidePreservesEq @?:?...
debug:  - Now solving 'precond. (call lemmaRemoveLastFromBothSidePreservesE... (require 1/2))' VC for lemmaRemoveLastFromBothSidePreservesEq @?:?...
debug: ++[B](p, s) != l || isEmpty[B](s) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = ++[B](p.t, s)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaRemoveLastFromBothSidePreservesE... (require 1/2))' VC for lemmaRemoveLastFromBothSidePreservesEq @?:?:
debug:  => VALID
info Verified: 431 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveLastFromBothSidePreservesE... (require 2/2))' VC for lemmaRemoveLastFromBothSidePreservesEq @?:?...
debug: Cache hit: 'precond. (call lemmaRemoveLastFromBothSidePreservesE... (require 2/2))' VC for lemmaRemoveLastFromBothSidePreservesEq @?:?...
info Verified: 432 / 982
debug:  - Checking cache: 'precond. (call removeLast[B](s))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:20...
debug: Cache miss: 'precond. (call removeLast[B](s))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:20...
debug:  - Now solving 'precond. (call removeLast[B](s))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:20...
debug: ++[B](p, s) != l || isEmpty[B](s) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  ++[B](p.t, s) != bdg || {
    val bdg: Unit = lemmaRemoveLastFromBothSidePreservesEq[B](p.t, s, bdg)
    assume(++[B](p.t, removeLast[B](s)) == removeLast[B](bdg))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeLast[B](s))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:20:
debug:  => VALID
info Verified: 433 / 982
debug:  - Checking cache: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:37...
debug: Cache miss: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:37...
debug:  - Now solving 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:37...
debug: ++[B](p, s) != l || isEmpty[B](s) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  ++[B](p.t, s) != bdg || {
    val bdg: Unit = lemmaRemoveLastFromBothSidePreservesEq[B](p.t, s, bdg)
    assume(++[B](p.t, removeLast[B](s)) == removeLast[B](bdg))
    !isEmpty[B](l)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:37:
debug:  => VALID
info Verified: 434 / 982
debug:  - Checking cache: 'precond. (call removeLast[B](s))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:20...
debug: Cache miss: 'precond. (call removeLast[B](s))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:20...
debug:  - Now solving 'precond. (call removeLast[B](s))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:20...
debug: val bdg: List[B] = ++[B](p, s)
true
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeLast[B](s))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:20:
debug:  => VALID
info Verified: 435 / 982
debug:  - Checking cache: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:37...
debug: Cache miss: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:37...
debug:  - Now solving 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:37...
debug: ++[B](p, s) != l || isEmpty[B](s) || p.isInstanceOf[Cons] || !isEmpty[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:37:
debug:  => VALID
info Verified: 436 / 982
debug:  - Checking cache: 'precond. (call removeLast[B](s))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:20...
debug: Cache hit: 'precond. (call removeLast[B](s))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:20...
info Verified: 437 / 982
debug:  - Checking cache: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:37...
debug: Cache hit: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromBothSidePreservesEq @446:37...
info Verified: 438 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaRemoveLastFromBothSidePreservesEq @446:48...
debug: Cache miss: 'non-negative measure' VC for lemmaRemoveLastFromBothSidePreservesEq @446:48...
debug:  - Now solving 'non-negative measure' VC for lemmaRemoveLastFromBothSidePreservesEq @446:48...
debug: ++[B](p, s) != l || isEmpty[B](s) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaRemoveLastFromBothSidePreservesEq @446:48:
debug:  => VALID
info Verified: 439 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaRemoveLastFromBothSidePreservesEq' VC for lemmaRemoveLastFromBothSidePreservesEq @443:28...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaRemoveLastFromBothSidePreservesEq' VC for lemmaRemoveLastFromBothSidePreservesEq @443:28...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaRemoveLastFromBothSidePreservesEq' VC for lemmaRemoveLastFromBothSidePreservesEq @443:28...
debug: ++[B](p, s) != l || isEmpty[B](s) || !p.isInstanceOf[Cons] || ++[B](p.t, s) == tail[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaRemoveLastFromBothSidePreservesEq' VC for lemmaRemoveLastFromBothSidePreservesEq @443:28:
debug:  => VALID
info Verified: 440 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaRemoveLastFromBothSidePreservesEq' VC for lemmaRemoveLastFromBothSidePreservesEq @443:28...
debug: Cache hit: 'body assertion: Inlined precondition (2/2) of lemmaRemoveLastFromBothSidePreservesEq' VC for lemmaRemoveLastFromBothSidePreservesEq @443:28...
info Verified: 441 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaRemoveLastFromBothSidePreservesEq @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaRemoveLastFromBothSidePreservesEq @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaRemoveLastFromBothSidePreservesEq @?:?...
debug: ++[B](p, s) != l || isEmpty[B](s) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  ++[B](p.t, s) != bdg || ListPrimitiveSize[B](bdg) < ListPrimitiveSize[B](l)
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaRemoveLastFromBothSidePreservesEq @?:?:
debug:  => VALID
info Verified: 442 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveLastFromBothSidePreservesEq @443:28...
debug: Cache miss: 'postcondition' VC for lemmaRemoveLastFromBothSidePreservesEq @443:28...
debug:  - Now solving 'postcondition' VC for lemmaRemoveLastFromBothSidePreservesEq @443:28...
debug: ++[B](p, s) != l || isEmpty[B](s) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  ++[B](p.t, s) != bdg || {
    val bdg: Unit = lemmaRemoveLastFromBothSidePreservesEq[B](p.t, s, bdg)
    val bdg: List[B] = removeLast[B](s)
    assume(++[B](p.t, bdg) == removeLast[B](bdg))
    ++[B](p, bdg) == removeLast[B](l)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveLastFromBothSidePreservesEq @443:28:
debug:  => VALID
info Verified: 443 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveLastFromBothSidePreservesEq @444:28...
debug: Cache miss: 'postcondition' VC for lemmaRemoveLastFromBothSidePreservesEq @444:28...
debug:  - Now solving 'postcondition' VC for lemmaRemoveLastFromBothSidePreservesEq @444:28...
debug: ++[B](p, s) != l || isEmpty[B](s) || p.isInstanceOf[Cons] || ++[B](p, removeLast[B](s)) == removeLast[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveLastFromBothSidePreservesEq @444:28:
debug:  => VALID
info Verified: 444 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaRemoveLastFromBothSidePreservesEq @442:5...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for lemmaRemoveLastFromBothSidePreservesEq @442:5...
info Verified: 445 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveLastFromBothSidePreservesEq @442:5...
debug: Cache hit: 'postcondition' VC for lemmaRemoveLastFromBothSidePreservesEq @442:5...
info Verified: 446 / 982
debug:  - Checking cache: 'precond. (call lemmaIsSuffixThenTailIsSuffix[B](l, s...)' VC for lemmaIsSuffixThenTailIsSuffix @?:?...
debug: Cache miss: 'precond. (call lemmaIsSuffixThenTailIsSuffix[B](l, s...)' VC for lemmaIsSuffixThenTailIsSuffix @?:?...
debug:  - Now solving 'precond. (call lemmaIsSuffixThenTailIsSuffix[B](l, s...)' VC for lemmaIsSuffixThenTailIsSuffix @?:?...
debug: !isSuffix[B](suffix, l) || !l.isInstanceOf[Cons] || size[B](suffix) >= size[B](l) || {
  val bdg: Boolean = isSuffix[B](suffix, l.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaIsSuffixThenTailIsSuffix[B](l, s...)' VC for lemmaIsSuffixThenTailIsSuffix @?:?:
debug:  => VALID
info Verified: 447 / 982
debug:  - Checking cache: 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42...
debug: Cache miss: 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42...
debug:  - Now solving 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42...
debug: !isSuffix[B](suffix, l) || !l.isInstanceOf[Cons] || size[B](suffix) >= size[B](l) || !isSuffix[B](suffix, l.t) || {
  val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](l.t, suffix)
  val bdg: Boolean = isEmpty[B](suffix)
  assume(bdg || isSuffix[B](tail[B](suffix), l.t))
  bdg || suffix != Nil[B]()
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42:
debug:  => VALID
info Verified: 448 / 982
debug:  - Checking cache: 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42...
debug: Cache miss: 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42...
debug:  - Now solving 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42...
debug: !isSuffix[B](suffix, l) || {
  val bdg: Boolean = !l.isInstanceOf[Cons] || size[B](suffix) >= size[B](l)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42:
debug:  => VALID
info Verified: 449 / 982
debug:  - Checking cache: 'precond. (call head[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @122:18...
debug: Cache miss: 'precond. (call head[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @122:18...
debug:  - Now solving 'precond. (call head[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @122:18...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](suffix) < size[B](l) || suffix != l || isEmpty[B](suffix) || suffix != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @122:18:
debug:  => VALID
info Verified: 450 / 982
debug:  - Checking cache: 'precond. (call head[B](l))' VC for lemmaIsSuffixThenTailIsSuffix @122:33...
debug: Cache miss: 'precond. (call head[B](l))' VC for lemmaIsSuffixThenTailIsSuffix @122:33...
debug:  - Now solving 'precond. (call head[B](l))' VC for lemmaIsSuffixThenTailIsSuffix @122:33...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](suffix) < size[B](l) || suffix != l || isEmpty[B](suffix) || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](l))' VC for lemmaIsSuffixThenTailIsSuffix @122:33:
debug:  => VALID
info Verified: 451 / 982
debug:  - Checking cache: 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @123:18...
debug: Cache miss: 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @123:18...
debug:  - Now solving 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @123:18...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](suffix) < size[B](l) || suffix != l || isEmpty[B](suffix) || head[B](suffix) != head[B](l) || suffix != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @123:18:
debug:  => VALID
info Verified: 452 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaIsSuffixThenTailIsSuffix @123:33...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaIsSuffixThenTailIsSuffix @123:33...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaIsSuffixThenTailIsSuffix @123:33...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](suffix) < size[B](l) || suffix != l || isEmpty[B](suffix) || head[B](suffix) != head[B](l) || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaIsSuffixThenTailIsSuffix @123:33:
debug:  => VALID
info Verified: 453 / 982
debug:  - Checking cache: 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @124:27...
debug: Cache miss: 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @124:27...
debug:  - Now solving 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @124:27...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](suffix) < size[B](l) || suffix != l || isEmpty[B](suffix) || head[B](suffix) != head[B](l) || tail[B](suffix) != tail[B](l) || suffix != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @124:27:
debug:  => VALID
info Verified: 454 / 982
debug:  - Checking cache: 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42...
debug: Cache miss: 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42...
debug:  - Now solving 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](suffix) < size[B](l) || suffix != l || isEmpty[B](suffix) || head[B](suffix) != head[B](l) || {
  val bdg: List[B] = tail[B](suffix)
  bdg != tail[B](l) || !isSuffix[B](bdg, l) || suffix != Nil[B]()
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42:
debug:  => VALID
info Verified: 455 / 982
debug:  - Checking cache: 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42...
debug: Cache miss: 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42...
debug:  - Now solving 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](suffix) < size[B](l) || suffix == l || isEmpty[B](suffix) || suffix != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](suffix))' VC for lemmaIsSuffixThenTailIsSuffix @130:42:
debug:  => VALID
info Verified: 456 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @117:16...
debug: Cache hit: 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @117:16...
info Verified: 457 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @119:18...
debug: Cache miss: 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @119:18...
debug:  - Now solving 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @119:18...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](suffix) < size[B](l) || suffix != l || !isEmpty[B](suffix) || isEmpty[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @119:18:
debug:  => VALID
info Verified: 458 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @122:18...
debug: Cache miss: 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @122:18...
debug:  - Now solving 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @122:18...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](suffix) < size[B](l) || suffix != l || isEmpty[B](suffix) || head[B](suffix) == head[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @122:18:
debug:  => VALID
info Verified: 459 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @123:18...
debug: Cache miss: 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @123:18...
debug:  - Now solving 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @123:18...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](suffix) < size[B](l) || suffix != l || isEmpty[B](suffix) || head[B](suffix) != head[B](l) || tail[B](suffix) == tail[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @123:18:
debug:  => VALID
info Verified: 460 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @124:18...
debug: Cache miss: 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @124:18...
debug:  - Now solving 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @124:18...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](suffix) < size[B](l) || suffix != l || isEmpty[B](suffix) || head[B](suffix) != head[B](l) || {
  val bdg: List[B] = tail[B](suffix)
  bdg != tail[B](l) || isSuffix[B](bdg, l)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaIsSuffixThenTailIsSuffix @124:18:
debug:  => VALID
info Verified: 461 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaIsSuffixThenTailIsSuffix @113:15...
debug: Cache miss: 'non-negative measure' VC for lemmaIsSuffixThenTailIsSuffix @113:15...
debug:  - Now solving 'non-negative measure' VC for lemmaIsSuffixThenTailIsSuffix @113:15...
debug: !isSuffix[B](suffix, l) || size[B](l) + size[B](suffix) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaIsSuffixThenTailIsSuffix @113:15:
debug:  => VALID
info Verified: 462 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaIsSuffixThenTailIsSuffix' VC for lemmaIsSuffixThenTailIsSuffix @115:59...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaIsSuffixThenTailIsSuffix' VC for lemmaIsSuffixThenTailIsSuffix @115:59...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaIsSuffixThenTailIsSuffix' VC for lemmaIsSuffixThenTailIsSuffix @115:59...
debug: !isSuffix[B](suffix, l) || !l.isInstanceOf[Cons] || size[B](suffix) >= size[B](l) || isSuffix[B](suffix, l.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaIsSuffixThenTailIsSuffix' VC for lemmaIsSuffixThenTailIsSuffix @115:59:
debug:  => VALID
info Verified: 463 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaIsSuffixThenTailIsSuffix @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaIsSuffixThenTailIsSuffix @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaIsSuffixThenTailIsSuffix @?:?...
debug: !isSuffix[B](suffix, l) || !l.isInstanceOf[Cons] || {
  val bdg: BigInt = size[B](suffix)
  val bdg: BigInt = size[B](l)
  bdg >= bdg || !isSuffix[B](suffix, l.t) || size[B](l.t) + bdg < bdg + bdg
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaIsSuffixThenTailIsSuffix @?:?:
debug:  => VALID
info Verified: 464 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsSuffixThenTailIsSuffix @115:59...
debug: Cache miss: 'postcondition' VC for lemmaIsSuffixThenTailIsSuffix @115:59...
debug:  - Now solving 'postcondition' VC for lemmaIsSuffixThenTailIsSuffix @115:59...
debug: !isSuffix[B](suffix, l) || !l.isInstanceOf[Cons] || size[B](suffix) >= size[B](l) || !isSuffix[B](suffix, l.t) || {
  val bdg: Unit = lemmaIsSuffixThenTailIsSuffix[B](l.t, suffix)
  val bdg: Boolean = isEmpty[B](suffix)
  assume(bdg || isSuffix[B](tail[B](suffix), l.t))
  bdg || isSuffix[B](tail[B](suffix), l)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaIsSuffixThenTailIsSuffix @115:59:
debug:  => VALID
info Verified: 465 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsSuffixThenTailIsSuffix @119:11...
debug: Cache hit: 'postcondition' VC for lemmaIsSuffixThenTailIsSuffix @119:11...
info Verified: 466 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsSuffixThenTailIsSuffix @122:11...
debug: Cache miss: 'postcondition' VC for lemmaIsSuffixThenTailIsSuffix @122:11...
debug:  - Now solving 'postcondition' VC for lemmaIsSuffixThenTailIsSuffix @122:11...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](suffix) < size[B](l) || suffix != l || isEmpty[B](suffix) || head[B](suffix) != head[B](l) || {
  val bdg: List[B] = tail[B](suffix)
  bdg != tail[B](l) || {
    val bdg: Boolean = isSuffix[B](bdg, l)
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaIsSuffixThenTailIsSuffix @122:11:
debug:  => VALID
info Verified: 467 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaIsSuffixThenTailIsSuffix @114:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaIsSuffixThenTailIsSuffix @114:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaIsSuffixThenTailIsSuffix @114:5...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](suffix) < size[B](l) || suffix == l
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaIsSuffixThenTailIsSuffix @114:5:
debug:  => VALID
info Verified: 468 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsSuffixThenTailIsSuffix @114:5...
debug: Cache miss: 'postcondition' VC for lemmaIsSuffixThenTailIsSuffix @114:5...
debug:  - Now solving 'postcondition' VC for lemmaIsSuffixThenTailIsSuffix @114:5...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](suffix) < size[B](l) || suffix == l || isEmpty[B](suffix) || isSuffix[B](tail[B](suffix), l)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaIsSuffixThenTailIsSuffix @114:5:
debug:  => VALID
info Verified: 469 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug: Cache miss: 'precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug:  - Now solving 'precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug: !subseq[B](lSub, l) || lSub.isInstanceOf[Nil] && l.isInstanceOf[Nil] || !lSub.isInstanceOf[Nil] || !l.isInstanceOf[Cons] || {
  val bdg: Boolean = subseq[B](lSub, l.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)' VC for lemmaSubSeqAddSameElmtPreserves @?:?:
debug:  => VALID
info Verified: 470 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug: Cache miss: 'precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug:  - Now solving 'precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug: !subseq[B](lSub, l) || lSub.isInstanceOf[Nil] && l.isInstanceOf[Nil] || lSub.isInstanceOf[Nil] && l.isInstanceOf[Cons] || !lSub.isInstanceOf[Cons] || !l.isInstanceOf[Cons] || lSub.h != l.h || {
  val bdg: Boolean = subseq[B](lSub.t, l.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)' VC for lemmaSubSeqAddSameElmtPreserves @?:?:
debug:  => VALID
info Verified: 471 / 982
debug:  - Checking cache: 'precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug: Cache miss: 'precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug:  - Now solving 'precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug: !subseq[B](lSub, l) || lSub.isInstanceOf[Nil] && l.isInstanceOf[Nil] || lSub.isInstanceOf[Nil] && l.isInstanceOf[Cons] || !lSub.isInstanceOf[Cons] || !l.isInstanceOf[Cons] || lSub.h == l.h && subseq[B](lSub.t, l.t) || {
  val bdg: Boolean = subseq[B](lSub, l.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)' VC for lemmaSubSeqAddSameElmtPreserves @?:?:
debug:  => VALID
info Verified: 472 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaSubSeqAddSameElmtPreserves @719:18...
debug: Cache miss: 'body assertion' VC for lemmaSubSeqAddSameElmtPreserves @719:18...
debug:  - Now solving 'body assertion' VC for lemmaSubSeqAddSameElmtPreserves @719:18...
debug: !subseq[B](lSub, l) || lSub.isInstanceOf[Nil] && l.isInstanceOf[Nil] || lSub.isInstanceOf[Nil] && l.isInstanceOf[Cons] || !lSub.isInstanceOf[Cons] || !l.isInstanceOf[Cons] || lSub.h == l.h && subseq[B](lSub.t, l.t) || subseq[B](lSub, l.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaSubSeqAddSameElmtPreserves @719:18:
debug:  => VALID
info Verified: 473 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaSubSeqAddSameElmtPreserves @711:15...
debug: Cache miss: 'non-negative measure' VC for lemmaSubSeqAddSameElmtPreserves @711:15...
debug:  - Now solving 'non-negative measure' VC for lemmaSubSeqAddSameElmtPreserves @711:15...
debug: !subseq[B](lSub, l) || size[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaSubSeqAddSameElmtPreserves @711:15:
debug:  => VALID
info Verified: 474 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @713:39...
debug: Cache miss: 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @713:39...
debug:  - Now solving 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @713:39...
debug: !subseq[B](lSub, l) || !lSub.isInstanceOf[Nil] || !l.isInstanceOf[Nil] || {
  val bdg: List[B] = Cons[B](b, Nil[B]())
  subseq[B](++[B](lSub, bdg), ++[B](l, bdg))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @713:39:
debug:  => VALID
info Verified: 475 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaSubSeqAddSameElmtPreserves' VC for lemmaSubSeqAddSameElmtPreserves @714:39...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaSubSeqAddSameElmtPreserves' VC for lemmaSubSeqAddSameElmtPreserves @714:39...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaSubSeqAddSameElmtPreserves' VC for lemmaSubSeqAddSameElmtPreserves @714:39...
debug: !subseq[B](lSub, l) || lSub.isInstanceOf[Nil] && l.isInstanceOf[Nil] || !lSub.isInstanceOf[Nil] || !l.isInstanceOf[Cons] || subseq[B](lSub, l.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaSubSeqAddSameElmtPreserves' VC for lemmaSubSeqAddSameElmtPreserves @714:39:
debug:  => VALID
info Verified: 476 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug: !subseq[B](lSub, l) || lSub.isInstanceOf[Nil] && l.isInstanceOf[Nil] || !lSub.isInstanceOf[Nil] || !l.isInstanceOf[Cons] || !subseq[B](lSub, l.t) || size[B](l.t) < size[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSubSeqAddSameElmtPreserves @?:?:
debug:  => VALID
info Verified: 477 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @714:39...
debug: Cache miss: 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @714:39...
debug:  - Now solving 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @714:39...
debug: !subseq[B](lSub, l) || lSub.isInstanceOf[Nil] && l.isInstanceOf[Nil] || !lSub.isInstanceOf[Nil] || !l.isInstanceOf[Cons] || !subseq[B](lSub, l.t) || {
  val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](lSub, l.t, b)
  val bdg: List[B] = Cons[B](b, Nil[B]())
  val bdg: List[B] = ++[B](lSub, bdg)
  assume(subseq[B](bdg, ++[B](l.t, bdg)))
  subseq[B](bdg, ++[B](l, bdg))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @714:39:
debug:  => VALID
info Verified: 478 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaSubSeqAddSameElmtPreserves' VC for lemmaSubSeqAddSameElmtPreserves @717:11...
debug: Cache hit: 'body assertion: Inlined precondition of lemmaSubSeqAddSameElmtPreserves' VC for lemmaSubSeqAddSameElmtPreserves @717:11...
info Verified: 479 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug: !subseq[B](lSub, l) || lSub.isInstanceOf[Nil] && l.isInstanceOf[Nil] || lSub.isInstanceOf[Nil] && l.isInstanceOf[Cons] || !lSub.isInstanceOf[Cons] || !l.isInstanceOf[Cons] || lSub.h != l.h || !subseq[B](lSub.t, l.t) || size[B](l.t) < size[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSubSeqAddSameElmtPreserves @?:?:
debug:  => VALID
info Verified: 480 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @717:11...
debug: Cache miss: 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @717:11...
debug:  - Now solving 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @717:11...
debug: !subseq[B](lSub, l) || lSub.isInstanceOf[Nil] && l.isInstanceOf[Nil] || lSub.isInstanceOf[Nil] && l.isInstanceOf[Cons] || !lSub.isInstanceOf[Cons] || !l.isInstanceOf[Cons] || lSub.h != l.h || !subseq[B](lSub.t, l.t) || {
  val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](lSub.t, l.t, b)
  val bdg: List[B] = Cons[B](b, Nil[B]())
  assume(subseq[B](++[B](lSub.t, bdg), ++[B](l.t, bdg)))
  subseq[B](++[B](lSub, bdg), ++[B](l, bdg))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @717:11:
debug:  => VALID
info Verified: 481 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaSubSeqAddSameElmtPreserves' VC for lemmaSubSeqAddSameElmtPreserves @720:11...
debug: Cache hit: 'body assertion: Inlined precondition of lemmaSubSeqAddSameElmtPreserves' VC for lemmaSubSeqAddSameElmtPreserves @720:11...
info Verified: 482 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSubSeqAddSameElmtPreserves @?:?...
debug: !subseq[B](lSub, l) || lSub.isInstanceOf[Nil] && l.isInstanceOf[Nil] || lSub.isInstanceOf[Nil] && l.isInstanceOf[Cons] || !lSub.isInstanceOf[Cons] || !l.isInstanceOf[Cons] || lSub.h == l.h && subseq[B](lSub.t, l.t) || !subseq[B](lSub, l.t) || size[B](l.t) < size[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSubSeqAddSameElmtPreserves @?:?:
debug:  => VALID
info Verified: 483 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @720:11...
debug: Cache miss: 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @720:11...
debug:  - Now solving 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @720:11...
debug: !subseq[B](lSub, l) || lSub.isInstanceOf[Nil] && l.isInstanceOf[Nil] || lSub.isInstanceOf[Nil] && l.isInstanceOf[Cons] || !lSub.isInstanceOf[Cons] || !l.isInstanceOf[Cons] || lSub.h == l.h && subseq[B](lSub.t, l.t) || !subseq[B](lSub, l.t) || {
  val bdg: Unit = lemmaSubSeqAddSameElmtPreserves[B](lSub, l.t, b)
  val bdg: List[B] = Cons[B](b, Nil[B]())
  val bdg: List[B] = ++[B](lSub, bdg)
  assume(subseq[B](bdg, ++[B](l.t, bdg)))
  subseq[B](bdg, ++[B](l, bdg))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @720:11:
debug:  => VALID
info Verified: 484 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaSubSeqAddSameElmtPreserves @712:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaSubSeqAddSameElmtPreserves @712:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaSubSeqAddSameElmtPreserves @712:5...
debug: !subseq[B](lSub, l) || lSub.isInstanceOf[Nil] && l.isInstanceOf[Nil] || lSub.isInstanceOf[Nil] && l.isInstanceOf[Cons] || lSub.isInstanceOf[Cons] && l.isInstanceOf[Cons]
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaSubSeqAddSameElmtPreserves @712:5:
debug:  => VALID
info Verified: 485 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @712:5...
debug: Cache miss: 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @712:5...
debug:  - Now solving 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @712:5...
debug: !subseq[B](lSub, l) || lSub.isInstanceOf[Nil] && l.isInstanceOf[Nil] || lSub.isInstanceOf[Nil] && l.isInstanceOf[Cons] || lSub.isInstanceOf[Cons] && l.isInstanceOf[Cons] || {
  val bdg: List[B] = Cons[B](b, Nil[B]())
  subseq[B](++[B](lSub, bdg), ++[B](l, bdg))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubSeqAddSameElmtPreserves @712:5:
debug:  => VALID
info Verified: 486 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaConcatThenFirstSubseqOfTot @729:15...
debug: Cache miss: 'non-negative measure' VC for lemmaConcatThenFirstSubseqOfTot @729:15...
debug:  - Now solving 'non-negative measure' VC for lemmaConcatThenFirstSubseqOfTot @729:15...
debug: size[B](l1) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaConcatThenFirstSubseqOfTot @729:15:
debug:  => VALID
info Verified: 487 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaConcatThenFirstSubseqOfTot @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaConcatThenFirstSubseqOfTot @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaConcatThenFirstSubseqOfTot @?:?...
debug: !l1.isInstanceOf[Cons] || size[B](l1.t) < size[B](l1)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaConcatThenFirstSubseqOfTot @?:?:
debug:  => VALID
info Verified: 488 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatThenFirstSubseqOfTot @731:28...
debug: Cache miss: 'postcondition' VC for lemmaConcatThenFirstSubseqOfTot @731:28...
debug:  - Now solving 'postcondition' VC for lemmaConcatThenFirstSubseqOfTot @731:28...
debug: !l1.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaConcatThenFirstSubseqOfTot[B](l1.t, l2)
  assume(subseq[B](l1.t, ++[B](l1.t, l2)))
  subseq[B](l1, ++[B](l1, l2))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaConcatThenFirstSubseqOfTot @731:28:
debug:  => VALID
info Verified: 489 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatThenFirstSubseqOfTot @732:28...
debug: Cache miss: 'postcondition' VC for lemmaConcatThenFirstSubseqOfTot @732:28...
debug:  - Now solving 'postcondition' VC for lemmaConcatThenFirstSubseqOfTot @732:28...
debug: l1.isInstanceOf[Cons] || subseq[B](l1, ++[B](l1, l2))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaConcatThenFirstSubseqOfTot @732:28:
debug:  => VALID
info Verified: 490 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaConcatThenFirstSubseqOfTot @730:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaConcatThenFirstSubseqOfTot @730:5...
info Verified: 491 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatThenFirstSubseqOfTot @730:5...
debug: Cache miss: 'postcondition' VC for lemmaConcatThenFirstSubseqOfTot @730:5...
info Verified: 492 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 1/2))' VC for lemmaForallNotContainsForConcat @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 1/2))' VC for lemmaForallNotContainsForConcat @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 1/2))' VC for lemmaForallNotContainsForConcat @?:?...
debug: !forall[B](l1, (b: B) => !contains[B](lRef, b)) || !forall[B](l2, (b: B) => !contains[B](lRef, b)) || !l1.isInstanceOf[Cons] || forall[B](l1.t, (b: B) => !contains[B](lRef, b))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 1/2))' VC for lemmaForallNotContainsForConcat @?:?:
debug:  => VALID
info Verified: 493 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 2/2))' VC for lemmaForallNotContainsForConcat @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 2/2))' VC for lemmaForallNotContainsForConcat @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 2/2))' VC for lemmaForallNotContainsForConcat @?:?...
debug: !forall[B](l1, (b: B) => !contains[B](lRef, b)) || !forall[B](l2, (b: B) => !contains[B](lRef, b)) || !l1.isInstanceOf[Cons] || !forall[B](l1.t, (b: B) => !contains[B](lRef, b)) || forall[B](l2, (b: B) => !contains[B](lRef, b))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 2/2))' VC for lemmaForallNotContainsForConcat @?:?:
debug:  => VALID
info Verified: 494 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallNotContainsForConcat @941:50...
debug: Cache miss: 'non-negative measure' VC for lemmaForallNotContainsForConcat @941:50...
debug:  - Now solving 'non-negative measure' VC for lemmaForallNotContainsForConcat @941:50...
debug: !forall[B](l1, (b: B) => !contains[B](lRef, b)) || !forall[B](l2, (b: B) => !contains[B](lRef, b)) || ListPrimitiveSize[B](l1) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaForallNotContainsForConcat @941:50:
debug:  => VALID
info Verified: 495 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallNotContainsForConcat @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaForallNotContainsForConcat @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaForallNotContainsForConcat @?:?...
debug: !forall[B](l1, (b: B) => !contains[B](lRef, b)) || !forall[B](l2, (b: B) => !contains[B](lRef, b)) || !l1.isInstanceOf[Cons] || ListPrimitiveSize[B](l1.t) < ListPrimitiveSize[B](l1)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallNotContainsForConcat @?:?:
debug:  => VALID
info Verified: 496 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
debug: !forall[B](l1, (b: B) => !contains[B](lRef, b)) || !forall[B](l2, (b: B) => !contains[B](lRef, b)) || !l1.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaForallNotContainsForConcat[B](l1.t, l2, lRef)
  forall[B](++[B](l1, l2), (b: B) => !contains[B](lRef, b))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallNotContainsForConcat @?:?:
debug:  => VALID
info Verified: 497 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
debug: !forall[B](l1, (b: B) => !contains[B](lRef, b)) || !forall[B](l2, (b: B) => !contains[B](lRef, b)) || l1.isInstanceOf[Cons] || forall[B](++[B](l1, l2), (b: B) => !contains[B](lRef, b))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallNotContainsForConcat @?:?:
debug:  => VALID
info Verified: 498 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsForConcat @?:?...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsForConcat @?:?...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsForConcat @?:?...
debug: !forall[B](l1, (b: B) => !contains[B](lRef, b)) || {
  val bdg: Boolean = forall[B](l2, (b: B) => !contains[B](lRef, b))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsForConcat @?:?:
debug:  => VALID
info Verified: 499 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
debug: Cache hit: 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
info Verified: 500 / 982
debug:  - Checking cache: 'precond. (call lemmaListContainsThenFilterContainsNo... (require 1/2))' VC for lemmaListContainsThenFilterContainsNotEmpty @?:?...
debug: Cache miss: 'precond. (call lemmaListContainsThenFilterContainsNo... (require 1/2))' VC for lemmaListContainsThenFilterContainsNotEmpty @?:?...
debug:  - Now solving 'precond. (call lemmaListContainsThenFilterContainsNo... (require 1/2))' VC for lemmaListContainsThenFilterContainsNotEmpty @?:?...
debug: !contains[B](l1, b) || !contains[B](l2, b) || !l1.isInstanceOf[Cons] || l1.h == b || {
  val bdg: Boolean = contains[B](l1.t, b)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaListContainsThenFilterContainsNo... (require 1/2))' VC for lemmaListContainsThenFilterContainsNotEmpty @?:?:
debug:  => VALID
info Verified: 501 / 982
debug:  - Checking cache: 'precond. (call lemmaListContainsThenFilterContainsNo... (require 2/2))' VC for lemmaListContainsThenFilterContainsNotEmpty @?:?...
debug: Cache hit: 'precond. (call lemmaListContainsThenFilterContainsNo... (require 2/2))' VC for lemmaListContainsThenFilterContainsNotEmpty @?:?...
info Verified: 502 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaListContainsThenFilterContainsNotEmpty @1151:15...
debug: Cache miss: 'non-negative measure' VC for lemmaListContainsThenFilterContainsNotEmpty @1151:15...
debug:  - Now solving 'non-negative measure' VC for lemmaListContainsThenFilterContainsNotEmpty @1151:15...
debug: !contains[B](l1, b) || !contains[B](l2, b) || size[B](l1) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaListContainsThenFilterContainsNotEmpty @1151:15:
debug:  => VALID
info Verified: 503 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaListContainsThenFilterContainsNotEmpty' VC for lemmaListContainsThenFilterContainsNotEmpty @1155:11...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaListContainsThenFilterContainsNotEmpty' VC for lemmaListContainsThenFilterContainsNotEmpty @1155:11...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaListContainsThenFilterContainsNotEmpty' VC for lemmaListContainsThenFilterContainsNotEmpty @1155:11...
debug: !contains[B](l1, b) || !contains[B](l2, b) || !l1.isInstanceOf[Cons] || l1.h == b || contains[B](l1.t, b)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaListContainsThenFilterContainsNotEmpty' VC for lemmaListContainsThenFilterContainsNotEmpty @1155:11:
debug:  => VALID
info Verified: 504 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaListContainsThenFilterContainsNotEmpty' VC for lemmaListContainsThenFilterContainsNotEmpty @1155:11...
debug: Cache hit: 'body assertion: Inlined precondition (2/2) of lemmaListContainsThenFilterContainsNotEmpty' VC for lemmaListContainsThenFilterContainsNotEmpty @1155:11...
info Verified: 505 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaListContainsThenFilterContainsNotEmpty @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaListContainsThenFilterContainsNotEmpty @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaListContainsThenFilterContainsNotEmpty @?:?...
debug: !contains[B](l1, b) || !contains[B](l2, b) || !l1.isInstanceOf[Cons] || l1.h == b || !contains[B](l1.t, b) || size[B](l1.t) < size[B](l1)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaListContainsThenFilterContainsNotEmpty @?:?:
debug:  => VALID
info Verified: 506 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaListContainsThenFilterContainsNotEmpty @1155:11...
debug: Cache miss: 'postcondition' VC for lemmaListContainsThenFilterContainsNotEmpty @1155:11...
debug:  - Now solving 'postcondition' VC for lemmaListContainsThenFilterContainsNotEmpty @1155:11...
debug: !contains[B](l1, b) || !contains[B](l2, b) || !l1.isInstanceOf[Cons] || l1.h == b || !contains[B](l1.t, b) || {
  val bdg: Unit = lemmaListContainsThenFilterContainsNotEmpty[B](l1.t, l2, b)
  assume(!isEmpty[B](filter[B](l1.t, (e: B) => contains[B](l2, e))))
  !isEmpty[B](filter[B](l1, (e: B) => contains[B](l2, e)))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaListContainsThenFilterContainsNotEmpty @1155:11:
debug:  => VALID
info Verified: 507 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaListContainsThenFilterContainsNotEmpty @1156:10...
debug: Cache miss: 'postcondition' VC for lemmaListContainsThenFilterContainsNotEmpty @1156:10...
debug:  - Now solving 'postcondition' VC for lemmaListContainsThenFilterContainsNotEmpty @1156:10...
debug: !contains[B](l1, b) || !contains[B](l2, b) || !l1.isInstanceOf[Cons] || l1.h != b || !isEmpty[B](filter[B](l1, (e: B) => contains[B](l2, e)))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaListContainsThenFilterContainsNotEmpty @1156:10:
debug:  => VALID
info Verified: 508 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of check' VC for lemmaListContainsThenFilterContainsNotEmpty @1158:21...
debug: Cache miss: 'body assertion: Inlined precondition of check' VC for lemmaListContainsThenFilterContainsNotEmpty @1158:21...
debug:  - Now solving 'body assertion: Inlined precondition of check' VC for lemmaListContainsThenFilterContainsNotEmpty @1158:21...
debug: !contains[B](l1, b) || !contains[B](l2, b) || l1.isInstanceOf[Cons]
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of check' VC for lemmaListContainsThenFilterContainsNotEmpty @1158:21:
debug:  => VALID
info Verified: 509 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaListContainsThenFilterContainsNotEmpty @1158:21...
debug: Cache miss: 'postcondition' VC for lemmaListContainsThenFilterContainsNotEmpty @1158:21...
debug:  - Now solving 'postcondition' VC for lemmaListContainsThenFilterContainsNotEmpty @1158:21...
debug: !contains[B](l1, b) || {
  val bdg: Boolean = contains[B](l2, b)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaListContainsThenFilterContainsNotEmpty @1158:21:
debug:  => VALID
info Verified: 510 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaListContainsThenFilterContainsNotEmpty @1152:5...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for lemmaListContainsThenFilterContainsNotEmpty @1152:5...
info Verified: 511 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaListContainsThenFilterContainsNotEmpty @1152:5...
debug: Cache hit: 'postcondition' VC for lemmaListContainsThenFilterContainsNotEmpty @1152:5...
info Verified: 512 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaConcatThenSecondSubseqOfTot @739:15...
debug: Cache hit: 'non-negative measure' VC for lemmaConcatThenSecondSubseqOfTot @739:15...
info Verified: 513 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaConcatThenSecondSubseqOfTot @?:?...
debug: Cache hit: 'measure decreases' VC for lemmaConcatThenSecondSubseqOfTot @?:?...
info Verified: 514 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatThenSecondSubseqOfTot @741:28...
debug: Cache miss: 'postcondition' VC for lemmaConcatThenSecondSubseqOfTot @741:28...
debug:  - Now solving 'postcondition' VC for lemmaConcatThenSecondSubseqOfTot @741:28...
debug: !l1.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaConcatThenSecondSubseqOfTot[B](l1.t, l2)
  assume(subseq[B](l2, ++[B](l1.t, l2)))
  subseq[B](l2, ++[B](l1, l2))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaConcatThenSecondSubseqOfTot @741:28:
debug:  => VALID
info Verified: 515 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatThenSecondSubseqOfTot @742:28...
debug: Cache miss: 'postcondition' VC for lemmaConcatThenSecondSubseqOfTot @742:28...
debug:  - Now solving 'postcondition' VC for lemmaConcatThenSecondSubseqOfTot @742:28...
debug: l1.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaSubseqRefl[B](l2)
  assume(subseq[B](l2, l2))
  subseq[B](l2, ++[B](l1, l2))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaConcatThenSecondSubseqOfTot @742:28:
debug:  => VALID
info Verified: 516 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaConcatThenSecondSubseqOfTot @740:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaConcatThenSecondSubseqOfTot @740:5...
info Verified: 517 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatThenSecondSubseqOfTot @740:5...
debug: Cache miss: 'postcondition' VC for lemmaConcatThenSecondSubseqOfTot @740:5...
info Verified: 518 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainsCannotContain[B... (require 1/2))' VC for lemmaForallNotContainsCannotContain @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainsCannotContain[B... (require 1/2))' VC for lemmaForallNotContainsCannotContain @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainsCannotContain[B... (require 1/2))' VC for lemmaForallNotContainsCannotContain @?:?...
debug: !forall[B](l, (bb: B) => !contains[B](lRef, bb)) || !contains[B](lRef, b) || !l.isInstanceOf[Cons] || forall[B](l.t, (bb: B) => !contains[B](lRef, bb))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainsCannotContain[B... (require 1/2))' VC for lemmaForallNotContainsCannotContain @?:?:
debug:  => VALID
info Verified: 519 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainsCannotContain[B... (require 2/2))' VC for lemmaForallNotContainsCannotContain @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainsCannotContain[B... (require 2/2))' VC for lemmaForallNotContainsCannotContain @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainsCannotContain[B... (require 2/2))' VC for lemmaForallNotContainsCannotContain @?:?...
debug: !forall[B](l, (bb: B) => !contains[B](lRef, bb)) || !contains[B](lRef, b) || !l.isInstanceOf[Cons] || {
  val bdg: Boolean = forall[B](l.t, (bb: B) => !contains[B](lRef, bb))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainsCannotContain[B... (require 2/2))' VC for lemmaForallNotContainsCannotContain @?:?:
debug:  => VALID
info Verified: 520 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallNotContainsCannotContain @949:54...
debug: Cache miss: 'non-negative measure' VC for lemmaForallNotContainsCannotContain @949:54...
debug:  - Now solving 'non-negative measure' VC for lemmaForallNotContainsCannotContain @949:54...
debug: !forall[B](l, (bb: B) => !contains[B](lRef, bb)) || !contains[B](lRef, b) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaForallNotContainsCannotContain @949:54:
debug:  => VALID
info Verified: 521 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallNotContainsCannotContain @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaForallNotContainsCannotContain @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaForallNotContainsCannotContain @?:?...
debug: !forall[B](l, (bb: B) => !contains[B](lRef, bb)) || !contains[B](lRef, b) || !l.isInstanceOf[Cons] || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallNotContainsCannotContain @?:?:
debug:  => VALID
info Verified: 522 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsCannotContain @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallNotContainsCannotContain @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallNotContainsCannotContain @?:?...
debug: !forall[B](l, (bb: B) => !contains[B](lRef, bb)) || !contains[B](lRef, b) || !l.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaForallNotContainsCannotContain[B](l.t, lRef, b)
  !contains[B](l, b)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallNotContainsCannotContain @?:?:
debug:  => VALID
info Verified: 523 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsCannotContain @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallNotContainsCannotContain @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallNotContainsCannotContain @?:?...
debug: !forall[B](l, (bb: B) => !contains[B](lRef, bb)) || !contains[B](lRef, b) || l.isInstanceOf[Cons] || !contains[B](l, b)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallNotContainsCannotContain @?:?:
debug:  => VALID
info Verified: 524 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsCannotContain @?:?...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsCannotContain @?:?...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsCannotContain @?:?...
debug: !forall[B](l, (bb: B) => !contains[B](lRef, bb)) || {
  val bdg: Boolean = contains[B](lRef, b)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsCannotContain @?:?:
debug:  => VALID
info Verified: 525 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsCannotContain @?:?...
debug: Cache hit: 'postcondition' VC for lemmaForallNotContainsCannotContain @?:?...
info Verified: 526 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaRemoveLastPrefixStillPrefix @382:65...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaRemoveLastPrefixStillPrefix @382:65...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaRemoveLastPrefixStillPrefix @382:65...
debug: isEmpty[B](l) || !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaRemoveLastPrefixStillPrefix @382:65:
debug:  => VALID
info Verified: 527 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveLastPrefixStillPrefix[B](p... (require 1/3))' VC for lemmaRemoveLastPrefixStillPrefix @?:?...
debug: Cache miss: 'precond. (call lemmaRemoveLastPrefixStillPrefix[B](p... (require 1/3))' VC for lemmaRemoveLastPrefixStillPrefix @?:?...
debug:  - Now solving 'precond. (call lemmaRemoveLastPrefixStillPrefix[B](p... (require 1/3))' VC for lemmaRemoveLastPrefixStillPrefix @?:?...
debug: isEmpty[B](l) || !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  isEmpty[B](bdg) || !isPrefix[B](p.t, bdg) || {
    val bdg: BigInt = size[B](p.t)
    val bdg: BigInt = size[B](bdg)
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaRemoveLastPrefixStillPrefix[B](p... (require 1/3))' VC for lemmaRemoveLastPrefixStillPrefix @?:?:
debug:  => VALID
info Verified: 528 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveLastPrefixStillPrefix[B](p... (require 2/3))' VC for lemmaRemoveLastPrefixStillPrefix @?:?...
debug: Cache hit: 'precond. (call lemmaRemoveLastPrefixStillPrefix[B](p... (require 2/3))' VC for lemmaRemoveLastPrefixStillPrefix @?:?...
info Verified: 529 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveLastPrefixStillPrefix[B](p... (require 3/3))' VC for lemmaRemoveLastPrefixStillPrefix @?:?...
debug: Cache hit: 'precond. (call lemmaRemoveLastPrefixStillPrefix[B](p... (require 3/3))' VC for lemmaRemoveLastPrefixStillPrefix @?:?...
info Verified: 530 / 982
debug:  - Checking cache: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastPrefixStillPrefix @386:27...
debug: Cache miss: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastPrefixStillPrefix @386:27...
debug:  - Now solving 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastPrefixStillPrefix @386:27...
debug: isEmpty[B](l) || !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  isEmpty[B](bdg) || !isPrefix[B](p.t, bdg) || size[B](p.t) >= size[B](bdg) || {
    val bdg: Unit = lemmaRemoveLastPrefixStillPrefix[B](p.t, bdg)
    assume(isPrefix[B](p.t, removeLast[B](bdg)))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastPrefixStillPrefix @386:27:
debug:  => VALID
info Verified: 531 / 982
debug:  - Checking cache: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastPrefixStillPrefix @386:27...
debug: Cache miss: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastPrefixStillPrefix @386:27...
debug:  - Now solving 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastPrefixStillPrefix @386:27...
debug: isEmpty[B](l) || !isPrefix[B](p, l) || {
  val bdg: BigInt = size[B](p)
  val bdg: BigInt = size[B](l)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastPrefixStillPrefix @386:27:
debug:  => VALID
info Verified: 532 / 982
debug:  - Checking cache: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastPrefixStillPrefix @386:27...
debug: Cache hit: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastPrefixStillPrefix @386:27...
info Verified: 533 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaRemoveLastPrefixStillPrefix @386:38...
debug: Cache miss: 'non-negative measure' VC for lemmaRemoveLastPrefixStillPrefix @386:38...
debug:  - Now solving 'non-negative measure' VC for lemmaRemoveLastPrefixStillPrefix @386:38...
debug: isEmpty[B](l) || !isPrefix[B](p, l) || size[B](p) >= size[B](l) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaRemoveLastPrefixStillPrefix @386:38:
debug:  => VALID
info Verified: 534 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/3) of lemmaRemoveLastPrefixStillPrefix' VC for lemmaRemoveLastPrefixStillPrefix @382:28...
debug: Cache miss: 'body assertion: Inlined precondition (1/3) of lemmaRemoveLastPrefixStillPrefix' VC for lemmaRemoveLastPrefixStillPrefix @382:28...
debug:  - Now solving 'body assertion: Inlined precondition (1/3) of lemmaRemoveLastPrefixStillPrefix' VC for lemmaRemoveLastPrefixStillPrefix @382:28...
debug: isEmpty[B](l) || !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || !isEmpty[B](tail[B](l))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/3) of lemmaRemoveLastPrefixStillPrefix' VC for lemmaRemoveLastPrefixStillPrefix @382:28:
debug:  => VALID
info Verified: 535 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/3) of lemmaRemoveLastPrefixStillPrefix' VC for lemmaRemoveLastPrefixStillPrefix @382:28...
debug: Cache miss: 'body assertion: Inlined precondition (2/3) of lemmaRemoveLastPrefixStillPrefix' VC for lemmaRemoveLastPrefixStillPrefix @382:28...
debug:  - Now solving 'body assertion: Inlined precondition (2/3) of lemmaRemoveLastPrefixStillPrefix' VC for lemmaRemoveLastPrefixStillPrefix @382:28...
debug: isEmpty[B](l) || !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  isEmpty[B](bdg) || isPrefix[B](p.t, bdg)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/3) of lemmaRemoveLastPrefixStillPrefix' VC for lemmaRemoveLastPrefixStillPrefix @382:28:
debug:  => VALID
info Verified: 536 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (3/3) of lemmaRemoveLastPrefixStillPrefix' VC for lemmaRemoveLastPrefixStillPrefix @382:28...
debug: Cache miss: 'body assertion: Inlined precondition (3/3) of lemmaRemoveLastPrefixStillPrefix' VC for lemmaRemoveLastPrefixStillPrefix @382:28...
debug:  - Now solving 'body assertion: Inlined precondition (3/3) of lemmaRemoveLastPrefixStillPrefix' VC for lemmaRemoveLastPrefixStillPrefix @382:28...
debug: isEmpty[B](l) || !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  isEmpty[B](bdg) || !isPrefix[B](p.t, bdg) || size[B](p.t) < size[B](bdg)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (3/3) of lemmaRemoveLastPrefixStillPrefix' VC for lemmaRemoveLastPrefixStillPrefix @382:28:
debug:  => VALID
info Verified: 537 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaRemoveLastPrefixStillPrefix @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaRemoveLastPrefixStillPrefix @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaRemoveLastPrefixStillPrefix @?:?...
debug: isEmpty[B](l) || !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  isEmpty[B](bdg) || !isPrefix[B](p.t, bdg) || size[B](p.t) >= size[B](bdg) || ListPrimitiveSize[B](bdg) < ListPrimitiveSize[B](l)
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaRemoveLastPrefixStillPrefix @?:?:
debug:  => VALID
info Verified: 538 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveLastPrefixStillPrefix @382:28...
debug: Cache miss: 'postcondition' VC for lemmaRemoveLastPrefixStillPrefix @382:28...
debug:  - Now solving 'postcondition' VC for lemmaRemoveLastPrefixStillPrefix @382:28...
debug: isEmpty[B](l) || !isPrefix[B](p, l) || size[B](p) >= size[B](l) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  isEmpty[B](bdg) || !isPrefix[B](p.t, bdg) || size[B](p.t) >= size[B](bdg) || {
    val bdg: Unit = lemmaRemoveLastPrefixStillPrefix[B](p.t, bdg)
    assume(isPrefix[B](p.t, removeLast[B](bdg)))
    isPrefix[B](p, removeLast[B](l))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveLastPrefixStillPrefix @382:28:
debug:  => VALID
info Verified: 539 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveLastPrefixStillPrefix @383:28...
debug: Cache miss: 'postcondition' VC for lemmaRemoveLastPrefixStillPrefix @383:28...
debug:  - Now solving 'postcondition' VC for lemmaRemoveLastPrefixStillPrefix @383:28...
debug: isEmpty[B](l) || !isPrefix[B](p, l) || size[B](p) >= size[B](l) || p.isInstanceOf[Cons] || isPrefix[B](p, removeLast[B](l))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveLastPrefixStillPrefix @383:28:
debug:  => VALID
info Verified: 540 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaRemoveLastPrefixStillPrefix @381:5...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for lemmaRemoveLastPrefixStillPrefix @381:5...
info Verified: 541 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveLastPrefixStillPrefix @381:5...
debug: Cache hit: 'postcondition' VC for lemmaRemoveLastPrefixStillPrefix @381:5...
info Verified: 542 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsThenInOtherList[B]... (require 1/2))' VC for lemmaForallContainsThenInOtherList @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsThenInOtherList[B]... (require 1/2))' VC for lemmaForallContainsThenInOtherList @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsThenInOtherList[B]... (require 1/2))' VC for lemmaForallContainsThenInOtherList @?:?...
debug: !contains[B](l1, e) || !forall[B](l1, (b: B) => contains[B](l2, b)) || l1.isInstanceOf[Cons] && l1.h == e || !l1.isInstanceOf[Cons] || !contains[B](l1.t, e) || {
  val bdg: Boolean = forall[B](l1.t, (b: B) => contains[B](l2, b))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsThenInOtherList[B]... (require 1/2))' VC for lemmaForallContainsThenInOtherList @?:?:
debug:  => VALID
info Verified: 543 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsThenInOtherList[B]... (require 2/2))' VC for lemmaForallContainsThenInOtherList @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsThenInOtherList[B]... (require 2/2))' VC for lemmaForallContainsThenInOtherList @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsThenInOtherList[B]... (require 2/2))' VC for lemmaForallContainsThenInOtherList @?:?...
debug: !contains[B](l1, e) || !forall[B](l1, (b: B) => contains[B](l2, b)) || l1.isInstanceOf[Cons] && l1.h == e || !l1.isInstanceOf[Cons] || !contains[B](l1.t, e) || !forall[B](l1.t, (b: B) => contains[B](l2, b)) || forall[B](l1.t, (b: B) => contains[B](l2, b))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsThenInOtherList[B]... (require 2/2))' VC for lemmaForallContainsThenInOtherList @?:?:
debug:  => VALID
info Verified: 544 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallContainsThenInOtherList @776:5...
debug: Cache miss: 'non-negative measure' VC for lemmaForallContainsThenInOtherList @776:5...
debug:  - Now solving 'non-negative measure' VC for lemmaForallContainsThenInOtherList @776:5...
debug: !contains[B](l1, e) || !forall[B](l1, (b: B) => contains[B](l2, b)) || ListPrimitiveSize[B](l1) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaForallContainsThenInOtherList @776:5:
debug:  => VALID
info Verified: 545 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsThenInOtherList @777:39...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsThenInOtherList @777:39...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsThenInOtherList @777:39...
debug: !contains[B](l1, e) || !forall[B](l1, (b: B) => contains[B](l2, b)) || !l1.isInstanceOf[Cons] || l1.h != e || contains[B](l2, e)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsThenInOtherList @777:39:
debug:  => VALID
info Verified: 546 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaForallContainsThenInOtherList' VC for lemmaForallContainsThenInOtherList @778:39...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaForallContainsThenInOtherList' VC for lemmaForallContainsThenInOtherList @778:39...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaForallContainsThenInOtherList' VC for lemmaForallContainsThenInOtherList @778:39...
debug: !contains[B](l1, e) || !forall[B](l1, (b: B) => contains[B](l2, b)) || l1.isInstanceOf[Cons] && l1.h == e || !l1.isInstanceOf[Cons] || contains[B](l1.t, e)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaForallContainsThenInOtherList' VC for lemmaForallContainsThenInOtherList @778:39:
debug:  => VALID
info Verified: 547 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaForallContainsThenInOtherList' VC for lemmaForallContainsThenInOtherList @778:39...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaForallContainsThenInOtherList' VC for lemmaForallContainsThenInOtherList @778:39...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaForallContainsThenInOtherList' VC for lemmaForallContainsThenInOtherList @778:39...
debug: !contains[B](l1, e) || !forall[B](l1, (b: B) => contains[B](l2, b)) || l1.isInstanceOf[Cons] && l1.h == e || !l1.isInstanceOf[Cons] || !contains[B](l1.t, e) || forall[B](l1.t, (b: B) => contains[B](l2, b))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaForallContainsThenInOtherList' VC for lemmaForallContainsThenInOtherList @778:39:
debug:  => VALID
info Verified: 548 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallContainsThenInOtherList @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaForallContainsThenInOtherList @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaForallContainsThenInOtherList @?:?...
debug: !contains[B](l1, e) || !forall[B](l1, (b: B) => contains[B](l2, b)) || l1.isInstanceOf[Cons] && l1.h == e || !l1.isInstanceOf[Cons] || !contains[B](l1.t, e) || !forall[B](l1.t, (b: B) => contains[B](l2, b)) || ListPrimitiveSize[B](l1.t) < ListPrimitiveSize[B](l1)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallContainsThenInOtherList @?:?:
debug:  => VALID
info Verified: 549 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsThenInOtherList @778:39...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsThenInOtherList @778:39...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsThenInOtherList @778:39...
debug: !contains[B](l1, e) || !forall[B](l1, (b: B) => contains[B](l2, b)) || l1.isInstanceOf[Cons] && l1.h == e || !l1.isInstanceOf[Cons] || !contains[B](l1.t, e) || !forall[B](l1.t, (b: B) => contains[B](l2, b)) || {
  val bdg: Unit = lemmaForallContainsThenInOtherList[B](l1.t, l2, e)
  assume(contains[B](l2, e))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsThenInOtherList @778:39:
debug:  => VALID
info Verified: 550 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsThenInOtherList @779:39...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsThenInOtherList @779:39...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsThenInOtherList @779:39...
debug: !contains[B](l1, e) || !forall[B](l1, (b: B) => contains[B](l2, b)) || l1.isInstanceOf[Cons] && l1.h == e || l1.isInstanceOf[Cons] || contains[B](l2, e)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsThenInOtherList @779:39:
debug:  => VALID
info Verified: 551 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallContainsThenInOtherList @776:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaForallContainsThenInOtherList @776:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaForallContainsThenInOtherList @776:5...
debug: !contains[B](l1, e) || {
  val bdg: Boolean = forall[B](l1, (b: B) => contains[B](l2, b))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaForallContainsThenInOtherList @776:5:
debug:  => VALID
info Verified: 552 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsThenInOtherList @776:5...
debug: Cache hit: 'postcondition' VC for lemmaForallContainsThenInOtherList @776:5...
info Verified: 553 / 982
debug:  - Checking cache: 'precond. (call head[B](l2))' VC for lemmaChangeCutStillConcatTotal @353:47...
debug: Cache miss: 'precond. (call head[B](l2))' VC for lemmaChangeCutStillConcatTotal @353:47...
debug:  - Now solving 'precond. (call head[B](l2))' VC for lemmaChangeCutStillConcatTotal @353:47...
debug: ++[B](l1, l2) != lTot || isEmpty[B](l2) || l2 != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](l2))' VC for lemmaChangeCutStillConcatTotal @353:47:
debug:  => VALID
info Verified: 554 / 982
debug:  - Checking cache: 'precond. (call tail[B](l2))' VC for lemmaChangeCutStillConcatTotal @353:57...
debug: Cache hit: 'precond. (call tail[B](l2))' VC for lemmaChangeCutStillConcatTotal @353:57...
info Verified: 555 / 982
debug:  - Checking cache: 'precond. (call head[B](l2))' VC for lemmaChangeCutStillConcatTotal @355:27...
debug: Cache miss: 'precond. (call head[B](l2))' VC for lemmaChangeCutStillConcatTotal @355:27...
debug:  - Now solving 'precond. (call head[B](l2))' VC for lemmaChangeCutStillConcatTotal @355:27...
debug: ++[B](l1, l2) != lTot || isEmpty[B](l2) || {
  val bdg: List[B] = Cons[B](head[B](l2), Nil[B]())
  val bdg: List[B] = tail[B](l2)
  val bdg: Unit = lemmaTwoListsConcatAssociativity[B](l1, bdg, bdg)
  assume(++[B](++[B](l1, bdg), bdg) == ++[B](l1, ++[B](bdg, bdg)))
  l2 != Nil[B]()
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](l2))' VC for lemmaChangeCutStillConcatTotal @355:27:
debug:  => VALID
info Verified: 556 / 982
debug:  - Checking cache: 'precond. (call tail[B](l2))' VC for lemmaChangeCutStillConcatTotal @355:40...
debug: Cache hit: 'precond. (call tail[B](l2))' VC for lemmaChangeCutStillConcatTotal @355:40...
info Verified: 557 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaChangeCutStillConcatTotal @353:5...
debug: Cache miss: 'postcondition' VC for lemmaChangeCutStillConcatTotal @353:5...
debug:  - Now solving 'postcondition' VC for lemmaChangeCutStillConcatTotal @353:5...
debug: ++[B](l1, l2) != lTot || isEmpty[B](l2) || {
  val bdg: List[B] = Cons[B](head[B](l2), Nil[B]())
  val bdg: List[B] = tail[B](l2)
  val bdg: Unit = lemmaTwoListsConcatAssociativity[B](l1, bdg, bdg)
  val bdg: List[B] = ++[B](l1, bdg)
  val bdg: List[B] = ++[B](bdg, bdg)
  val bdg: List[B] = ++[B](bdg, bdg)
  assume(bdg == ++[B](l1, bdg))
  bdg == lTot
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaChangeCutStillConcatTotal @353:5:
debug:  => VALID
info Verified: 558 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaTwoListsConcatAssociativity @333:15...
debug: Cache hit: 'non-negative measure' VC for lemmaTwoListsConcatAssociativity @333:15...
info Verified: 559 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaTwoListsConcatAssociativity @?:?...
debug: Cache hit: 'measure decreases' VC for lemmaTwoListsConcatAssociativity @?:?...
info Verified: 560 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaTwoListsConcatAssociativity @336:9...
debug: Cache miss: 'postcondition' VC for lemmaTwoListsConcatAssociativity @336:9...
debug:  - Now solving 'postcondition' VC for lemmaTwoListsConcatAssociativity @336:9...
debug: !l1.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaTwoListsConcatAssociativity[B](l1.t, l2, l3)
  val bdg: List[B] = ++[B](l1.t, l2)
  val bdg: List[B] = ++[B](l2, l3)
  assume(++[B](bdg, l3) == ++[B](l1.t, bdg))
  ++[B](++[B](l1, l2), l3) == ++[B](l1, bdg)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaTwoListsConcatAssociativity @336:9:
debug:  => VALID
info Verified: 561 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaTwoListsConcatAssociativity @338:21...
debug: Cache miss: 'postcondition' VC for lemmaTwoListsConcatAssociativity @338:21...
debug:  - Now solving 'postcondition' VC for lemmaTwoListsConcatAssociativity @338:21...
debug: l1.isInstanceOf[Cons] || ++[B](++[B](l1, l2), l3) == ++[B](l1, ++[B](l2, l3))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaTwoListsConcatAssociativity @338:21:
debug:  => VALID
info Verified: 562 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaTwoListsConcatAssociativity @334:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaTwoListsConcatAssociativity @334:5...
info Verified: 563 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaTwoListsConcatAssociativity @334:5...
debug: Cache miss: 'postcondition' VC for lemmaTwoListsConcatAssociativity @334:5...
info Verified: 564 / 982
debug:  - Checking cache: 'non-negative measure' VC for reverseList @30:5...
debug: Cache hit: 'non-negative measure' VC for reverseList @30:5...
info Verified: 565 / 982
debug:  - Checking cache: 'measure decreases' VC for reverseList @31:28...
debug: Cache hit: 'measure decreases' VC for reverseList @31:28...
info Verified: 566 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for reverseList @30:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for reverseList @30:5...
info Verified: 567 / 982
debug:  - Checking cache: 'precond. (call tail[B](scrut._1))' VC for lemmaIsPrefixThenSmallerEqSize @493:57...
debug: Cache miss: 'precond. (call tail[B](scrut._1))' VC for lemmaIsPrefixThenSmallerEqSize @493:57...
debug:  - Now solving 'precond. (call tail[B](scrut._1))' VC for lemmaIsPrefixThenSmallerEqSize @493:57...
debug: !isPrefix[B](p, l) || p.isInstanceOf[Nil] || l.isInstanceOf[Nil] || p != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](scrut._1))' VC for lemmaIsPrefixThenSmallerEqSize @493:57:
debug:  => VALID
info Verified: 568 / 982
debug:  - Checking cache: 'precond. (call tail[B](scrut._2))' VC for lemmaIsPrefixThenSmallerEqSize @493:66...
debug: Cache miss: 'precond. (call tail[B](scrut._2))' VC for lemmaIsPrefixThenSmallerEqSize @493:66...
debug:  - Now solving 'precond. (call tail[B](scrut._2))' VC for lemmaIsPrefixThenSmallerEqSize @493:66...
debug: !isPrefix[B](p, l) || p.isInstanceOf[Nil] || l.isInstanceOf[Nil] || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](scrut._2))' VC for lemmaIsPrefixThenSmallerEqSize @493:66:
debug:  => VALID
info Verified: 569 / 982
debug:  - Checking cache: 'precond. (call lemmaIsPrefixThenSmallerEqSize[B](p, l))' VC for lemmaIsPrefixThenSmallerEqSize @?:?...
debug: Cache miss: 'precond. (call lemmaIsPrefixThenSmallerEqSize[B](p, l))' VC for lemmaIsPrefixThenSmallerEqSize @?:?...
debug:  - Now solving 'precond. (call lemmaIsPrefixThenSmallerEqSize[B](p, l))' VC for lemmaIsPrefixThenSmallerEqSize @?:?...
debug: !isPrefix[B](p, l) || p.isInstanceOf[Nil] || l.isInstanceOf[Nil] || {
  val bdg: Boolean = isPrefix[B](tail[B](p), tail[B](l))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaIsPrefixThenSmallerEqSize[B](p, l))' VC for lemmaIsPrefixThenSmallerEqSize @?:?:
debug:  => VALID
info Verified: 570 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaIsPrefixThenSmallerEqSize @495:25...
debug: Cache miss: 'non-negative measure' VC for lemmaIsPrefixThenSmallerEqSize @495:25...
debug:  - Now solving 'non-negative measure' VC for lemmaIsPrefixThenSmallerEqSize @495:25...
debug: !isPrefix[B](p, l) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaIsPrefixThenSmallerEqSize @495:25:
debug:  => VALID
info Verified: 571 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsPrefixThenSmallerEqSize @491:26...
debug: Cache miss: 'postcondition' VC for lemmaIsPrefixThenSmallerEqSize @491:26...
debug:  - Now solving 'postcondition' VC for lemmaIsPrefixThenSmallerEqSize @491:26...
debug: !isPrefix[B](p, l) || !p.isInstanceOf[Nil] || size[B](p) <= size[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaIsPrefixThenSmallerEqSize @491:26:
debug:  => VALID
info Verified: 572 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsPrefixThenSmallerEqSize @492:26...
debug: Cache miss: 'postcondition' VC for lemmaIsPrefixThenSmallerEqSize @492:26...
debug:  - Now solving 'postcondition' VC for lemmaIsPrefixThenSmallerEqSize @492:26...
debug: !isPrefix[B](p, l) || p.isInstanceOf[Nil] || !l.isInstanceOf[Nil] || size[B](p) <= size[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaIsPrefixThenSmallerEqSize @492:26:
debug:  => VALID
info Verified: 573 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaIsPrefixThenSmallerEqSize' VC for lemmaIsPrefixThenSmallerEqSize @493:26...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaIsPrefixThenSmallerEqSize' VC for lemmaIsPrefixThenSmallerEqSize @493:26...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaIsPrefixThenSmallerEqSize' VC for lemmaIsPrefixThenSmallerEqSize @493:26...
debug: !isPrefix[B](p, l) || p.isInstanceOf[Nil] || l.isInstanceOf[Nil] || isPrefix[B](tail[B](p), tail[B](l))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaIsPrefixThenSmallerEqSize' VC for lemmaIsPrefixThenSmallerEqSize @493:26:
debug:  => VALID
info Verified: 574 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaIsPrefixThenSmallerEqSize @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaIsPrefixThenSmallerEqSize @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaIsPrefixThenSmallerEqSize @?:?...
debug: !isPrefix[B](p, l) || p.isInstanceOf[Nil] || l.isInstanceOf[Nil] || {
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](tail[B](p), bdg) || ListPrimitiveSize[B](bdg) < ListPrimitiveSize[B](l)
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaIsPrefixThenSmallerEqSize @?:?:
debug:  => VALID
info Verified: 575 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsPrefixThenSmallerEqSize @493:26...
debug: Cache miss: 'postcondition' VC for lemmaIsPrefixThenSmallerEqSize @493:26...
debug:  - Now solving 'postcondition' VC for lemmaIsPrefixThenSmallerEqSize @493:26...
debug: !isPrefix[B](p, l) || p.isInstanceOf[Nil] || l.isInstanceOf[Nil] || {
  val bdg: List[B] = tail[B](p)
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](bdg, bdg) || {
    val bdg: Unit = lemmaIsPrefixThenSmallerEqSize[B](bdg, bdg)
    assume(size[B](bdg) <= size[B](bdg))
    size[B](p) <= size[B](l)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaIsPrefixThenSmallerEqSize @493:26:
debug:  => VALID
info Verified: 576 / 982
debug:  - Checking cache: 'precond. (call head[B](l2))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1189:16...
debug: Cache miss: 'precond. (call head[B](l2))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1189:16...
debug:  - Now solving 'precond. (call head[B](l2))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1189:16...
debug: content[B](l1) != content[B](l2) || {
  val bdg: BigInt = size[B](l1)
  bdg != size[B](l2) || bdg > BigInt("1") || l1.isInstanceOf[Nil] || l2 != Nil[B]()
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](l2))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1189:16:
debug:  => VALID
info Verified: 577 / 982
debug:  - Checking cache: 'precond. (call tail[B](l2))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:58...
debug: Cache miss: 'precond. (call tail[B](l2))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:58...
debug:  - Now solving 'precond. (call tail[B](l2))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:58...
debug: content[B](l1) != content[B](l2) || {
  val bdg: BigInt = size[B](l1)
  bdg != size[B](l2) || bdg > BigInt("1") || l1.isInstanceOf[Nil] || head[B](l2) != l1.h || !isEmpty[B](l1.t) || l2 != Nil[B]()
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l2))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:58:
debug:  => VALID
info Verified: 578 / 982
debug:  - Checking cache: 'precond. (call lemmaSameContentSameSizeSmallerEqOneS... (require 1/3))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @?:?...
debug: Cache miss: 'precond. (call lemmaSameContentSameSizeSmallerEqOneS... (require 1/3))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @?:?...
debug:  - Now solving 'precond. (call lemmaSameContentSameSizeSmallerEqOneS... (require 1/3))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @?:?...
debug: content[B](l1) != content[B](l2) || {
  val bdg: BigInt = size[B](l1)
  bdg != size[B](l2) || bdg > BigInt("1") || l1.isInstanceOf[Nil] || head[B](l2) != l1.h || !isEmpty[B](l1.t) || {
    val bdg: List[B] = tail[B](l2)
    content[B](l1.t) != content[B](bdg) || {
      val bdg: BigInt = size[B](l1.t)
      val bdg: BigInt = size[B](bdg)
      true
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSameContentSameSizeSmallerEqOneS... (require 1/3))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @?:?:
debug:  => VALID
info Verified: 579 / 982
debug:  - Checking cache: 'precond. (call lemmaSameContentSameSizeSmallerEqOneS... (require 2/3))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @?:?...
debug: Cache hit: 'precond. (call lemmaSameContentSameSizeSmallerEqOneS... (require 2/3))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @?:?...
info Verified: 580 / 982
debug:  - Checking cache: 'precond. (call lemmaSameContentSameSizeSmallerEqOneS... (require 3/3))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @?:?...
debug: Cache hit: 'precond. (call lemmaSameContentSameSizeSmallerEqOneS... (require 3/3))' VC for lemmaSameContentSameSizeSmallerEqOneSameList @?:?...
info Verified: 581 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1186:16...
debug: Cache miss: 'body assertion' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1186:16...
debug:  - Now solving 'body assertion' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1186:16...
debug: content[B](l1) != content[B](l2) || {
  val bdg: BigInt = size[B](l1)
  bdg != size[B](l2) || bdg > BigInt("1") || !l1.isInstanceOf[Nil] || isEmpty[B](l2)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1186:16:
debug:  => VALID
info Verified: 582 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1189:16...
debug: Cache miss: 'body assertion' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1189:16...
debug:  - Now solving 'body assertion' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1189:16...
debug: content[B](l1) != content[B](l2) || {
  val bdg: BigInt = size[B](l1)
  bdg != size[B](l2) || bdg > BigInt("1") || l1.isInstanceOf[Nil] || head[B](l2) == l1.h
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1189:16:
debug:  => VALID
info Verified: 583 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1190:16...
debug: Cache miss: 'body assertion' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1190:16...
debug:  - Now solving 'body assertion' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1190:16...
debug: content[B](l1) != content[B](l2) || {
  val bdg: BigInt = size[B](l1)
  bdg != size[B](l2) || bdg > BigInt("1") || l1.isInstanceOf[Nil] || head[B](l2) != l1.h || isEmpty[B](l1.t)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1190:16:
debug:  => VALID
info Verified: 584 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1182:15...
debug: Cache miss: 'non-negative measure' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1182:15...
debug:  - Now solving 'non-negative measure' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1182:15...
debug: content[B](l1) != content[B](l2) || {
  val bdg: BigInt = size[B](l1)
  bdg != size[B](l2) || bdg > BigInt("1") || bdg >= BigInt("0")
}
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1182:15:
debug:  => VALID
info Verified: 585 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1186:9...
debug: Cache miss: 'postcondition' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1186:9...
debug:  - Now solving 'postcondition' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1186:9...
debug: content[B](l1) != content[B](l2) || {
  val bdg: BigInt = size[B](l1)
  bdg != size[B](l2) || bdg > BigInt("1") || !l1.isInstanceOf[Nil] || !isEmpty[B](l2) || l1 == l2
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1186:9:
debug:  => VALID
info Verified: 586 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/3) of lemmaSameContentSameSizeSmallerEqOneSameList' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/3) of lemmaSameContentSameSizeSmallerEqOneSameList' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/3) of lemmaSameContentSameSizeSmallerEqOneSameList' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9...
debug: content[B](l1) != content[B](l2) || {
  val bdg: BigInt = size[B](l1)
  bdg != size[B](l2) || bdg > BigInt("1") || l1.isInstanceOf[Nil] || head[B](l2) != l1.h || !isEmpty[B](l1.t) || content[B](l1.t) == content[B](tail[B](l2))
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/3) of lemmaSameContentSameSizeSmallerEqOneSameList' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9:
debug:  => VALID
info Verified: 587 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/3) of lemmaSameContentSameSizeSmallerEqOneSameList' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/3) of lemmaSameContentSameSizeSmallerEqOneSameList' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/3) of lemmaSameContentSameSizeSmallerEqOneSameList' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9...
debug: content[B](l1) != content[B](l2) || {
  val bdg: BigInt = size[B](l1)
  bdg != size[B](l2) || bdg > BigInt("1") || l1.isInstanceOf[Nil] || head[B](l2) != l1.h || !isEmpty[B](l1.t) || {
    val bdg: List[B] = tail[B](l2)
    content[B](l1.t) != content[B](bdg) || size[B](l1.t) == size[B](bdg)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/3) of lemmaSameContentSameSizeSmallerEqOneSameList' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9:
debug:  => VALID
info Verified: 588 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (3/3) of lemmaSameContentSameSizeSmallerEqOneSameList' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9...
debug: Cache miss: 'body assertion: Inlined precondition (3/3) of lemmaSameContentSameSizeSmallerEqOneSameList' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9...
debug:  - Now solving 'body assertion: Inlined precondition (3/3) of lemmaSameContentSameSizeSmallerEqOneSameList' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9...
debug: content[B](l1) != content[B](l2) || {
  val bdg: BigInt = size[B](l1)
  bdg != size[B](l2) || bdg > BigInt("1") || l1.isInstanceOf[Nil] || head[B](l2) != l1.h || !isEmpty[B](l1.t) || {
    val bdg: List[B] = tail[B](l2)
    content[B](l1.t) != content[B](bdg) || {
      val bdg: BigInt = size[B](l1.t)
      bdg != size[B](bdg) || bdg <= BigInt("1")
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (3/3) of lemmaSameContentSameSizeSmallerEqOneSameList' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9:
debug:  => VALID
info Verified: 589 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSameContentSameSizeSmallerEqOneSameList @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSameContentSameSizeSmallerEqOneSameList @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSameContentSameSizeSmallerEqOneSameList @?:?...
debug: content[B](l1) != content[B](l2) || {
  val bdg: BigInt = size[B](l1)
  bdg != size[B](l2) || bdg > BigInt("1") || l1.isInstanceOf[Nil] || head[B](l2) != l1.h || !isEmpty[B](l1.t) || {
    val bdg: List[B] = tail[B](l2)
    content[B](l1.t) != content[B](bdg) || {
      val bdg: BigInt = size[B](l1.t)
      bdg != size[B](bdg) || bdg > BigInt("1") || bdg < bdg
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSameContentSameSizeSmallerEqOneSameList @?:?:
debug:  => VALID
info Verified: 590 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9...
debug: Cache miss: 'postcondition' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9...
debug:  - Now solving 'postcondition' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9...
debug: content[B](l1) != content[B](l2) || {
  val bdg: BigInt = size[B](l1)
  bdg != size[B](l2) || bdg > BigInt("1") || l1.isInstanceOf[Nil] || head[B](l2) != l1.h || !isEmpty[B](l1.t) || {
    val bdg: List[B] = tail[B](l2)
    content[B](l1.t) != content[B](bdg) || {
      val bdg: BigInt = size[B](l1.t)
      bdg != size[B](bdg) || bdg > BigInt("1") || {
        val bdg: Unit = lemmaSameContentSameSizeSmallerEqOneSameList[B](l1.t, bdg)
        assume(l1.t == bdg)
        l1 == l2
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1191:9:
debug:  => VALID
info Verified: 591 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1184:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1184:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1184:5...
debug: content[B](l1) != content[B](l2) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1184:5:
debug:  => VALID
info Verified: 592 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1184:5...
debug: Cache hit: 'postcondition' VC for lemmaSameContentSameSizeSmallerEqOneSameList @1184:5...
info Verified: 593 / 982
debug:  - Checking cache: 'precond. (call lemmaSubseqOfEmptyIsEmpty[B]((scrut.t... (require 1/2))' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
debug: Cache miss: 'precond. (call lemmaSubseqOfEmptyIsEmpty[B]((scrut.t... (require 1/2))' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
debug:  - Now solving 'precond. (call lemmaSubseqOfEmptyIsEmpty[B]((scrut.t... (require 1/2))' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
debug: !isEmpty[B](l2) || {
  val bdg: Boolean = subseq[B](l1, l2)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubseqOfEmptyIsEmpty[B]((scrut.t... (require 1/2))' VC for lemmaSubseqOfEmptyIsEmpty @?:?:
debug:  => VALID
info Verified: 594 / 982
debug:  - Checking cache: 'precond. (call lemmaSubseqOfEmptyIsEmpty[B]((scrut.t... (require 2/2))' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
debug: Cache miss: 'precond. (call lemmaSubseqOfEmptyIsEmpty[B]((scrut.t... (require 2/2))' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
debug:  - Now solving 'precond. (call lemmaSubseqOfEmptyIsEmpty[B]((scrut.t... (require 2/2))' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
debug: !isEmpty[B](l2) || !subseq[B](l1, l2) || !l1.isInstanceOf[Cons] || subseq[B](l1.t, l2)
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubseqOfEmptyIsEmpty[B]((scrut.t... (require 2/2))' VC for lemmaSubseqOfEmptyIsEmpty @?:?:
debug:  => VALID
info Verified: 595 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaSubseqOfEmptyIsEmpty @628:44...
debug: Cache miss: 'non-negative measure' VC for lemmaSubseqOfEmptyIsEmpty @628:44...
debug:  - Now solving 'non-negative measure' VC for lemmaSubseqOfEmptyIsEmpty @628:44...
debug: !isEmpty[B](l2) || !subseq[B](l1, l2) || ListPrimitiveSize[B](l1) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaSubseqOfEmptyIsEmpty @628:44:
debug:  => VALID
info Verified: 596 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
debug: !isEmpty[B](l2) || !subseq[B](l1, l2) || !l1.isInstanceOf[Cons] || ListPrimitiveSize[B](l1.t) < ListPrimitiveSize[B](l1)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSubseqOfEmptyIsEmpty @?:?:
debug:  => VALID
info Verified: 597 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
debug: Cache miss: 'postcondition' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
debug:  - Now solving 'postcondition' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
debug: !isEmpty[B](l2) || !subseq[B](l1, l2) || !l1.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaSubseqOfEmptyIsEmpty[B](l1.t, l2)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubseqOfEmptyIsEmpty @?:?:
debug:  => VALID
info Verified: 598 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
debug: Cache hit: 'postcondition' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
info Verified: 599 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
info Verified: 600 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
debug: Cache hit: 'postcondition' VC for lemmaSubseqOfEmptyIsEmpty @?:?...
info Verified: 601 / 982
debug:  - Checking cache: 'precond. (call lemmaSubsetContentThenForallContains[...)' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: Cache miss: 'precond. (call lemmaSubsetContentThenForallContains[...)' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug:  - Now solving 'precond. (call lemmaSubsetContentThenForallContains[...)' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: !noDuplicate[B](l1) || size[B](l1) != size[B](l2) || {
  val bdg: Set[B] = content[B](l1)
  val bdg: Set[B] = content[B](l2)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubsetContentThenForallContains[...)' VC for lemmaNoDuplicatePreservedSameContent @?:?:
debug:  => VALID
info Verified: 602 / 982
debug:  - Checking cache: 'precond. (call lemmaSubsetContentThenForallContains[...)' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: Cache miss: 'precond. (call lemmaSubsetContentThenForallContains[...)' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug:  - Now solving 'precond. (call lemmaSubsetContentThenForallContains[...)' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: !noDuplicate[B](l1) || size[B](l1) != size[B](l2) || content[B](l1) != content[B](l2) || {
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
  assume(forall[B](l1, (b: B) => contains[B](l2, b)))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubsetContentThenForallContains[...)' VC for lemmaNoDuplicatePreservedSameContent @?:?:
debug:  => VALID
info Verified: 603 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveOneElmtPreservesNoDuplicat...)' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: Cache miss: 'precond. (call lemmaRemoveOneElmtPreservesNoDuplicat...)' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug:  - Now solving 'precond. (call lemmaRemoveOneElmtPreservesNoDuplicat...)' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: !noDuplicate[B](l1) || size[B](l1) != size[B](l2) || content[B](l1) != content[B](l2) || {
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
  assume(forall[B](l1, (b: B) => contains[B](l2, b)))
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
  assume(forall[B](l2, (b: B) => contains[B](l1, b)))
  !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
    val bdg: List[B] = -[B](l1, l2.h)
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaRemoveOneElmtPreservesNoDuplicat...)' VC for lemmaNoDuplicatePreservedSameContent @?:?:
debug:  => VALID
info Verified: 604 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 1/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: Cache miss: 'precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 1/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug:  - Now solving 'precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 1/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: !noDuplicate[B](l1) || size[B](l1) != size[B](l2) || content[B](l1) != content[B](l2) || {
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
  assume(forall[B](l1, (b: B) => contains[B](l2, b)))
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
  assume(forall[B](l2, (b: B) => contains[B](l1, b)))
  !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
    val bdg: List[B] = -[B](l1, l2.h)
    val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
    assume(noDuplicate[B](bdg))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 1/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?:
debug:  => VALID
info Verified: 605 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 2/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: Cache hit: 'precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 2/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
info Verified: 606 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsPreservedRemoveElm...)' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsPreservedRemoveElm...)' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsPreservedRemoveElm...)' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || !forall[B](l1, (b: B) => contains[B](l2, b)) || forall[B](l1, (b: B) => contains[B](l2, b))
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsPreservedRemoveElm...)' VC for lemmaNoDuplicatePreservedSameContent @?:?:
debug:  => VALID
info Verified: 607 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 1/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 1/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 1/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || !forall[B](bdg, (e: B) => contains[B](l2, e)) || forall[B](bdg, (e: B) => contains[B](l2, e))
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 1/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?:
debug:  => VALID
info Verified: 608 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 2/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 2/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 2/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || !forall[B](bdg, (e: B) => contains[B](l2, e)) || {
          val bdg: Boolean = forall[B](bdg, (e: B) => contains[B](l2, e))
          true
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 2/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?:
debug:  => VALID
info Verified: 609 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 1/3))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 1/3))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 1/3))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            !forall[B](bdg, (bb: B) => contains[B](l2, bb)) || forall[B](bdg, (bb: B) => contains[B](l2, bb))
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 1/3))' VC for lemmaNoDuplicatePreservedSameContent @?:?:
debug:  => VALID
info Verified: 610 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 2/3))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 2/3))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 2/3))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            !forall[B](bdg, (bb: B) => contains[B](l2, bb)) || {
              val bdg: Boolean = forall[B](bdg, (bb: B) => contains[B](l2, bb))
              true
            }
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 2/3))' VC for lemmaNoDuplicatePreservedSameContent @?:?:
debug:  => VALID
info Verified: 611 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 3/3))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: Cache hit: 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 3/3))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
info Verified: 612 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 1/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 1/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 1/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](bdg, l2, bdg, l2.h)
            assume(forall[B](bdg, (bb: B) => contains[B](bdg, bb)))
            assume(forall[B](bdg, (b: B) => contains[B](bdg, b)))
            !forall[B](bdg, (e: B) => contains[B](bdg, e)) || forall[B](bdg, (e: B) => contains[B](bdg, e))
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 1/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?:
debug:  => VALID
info Verified: 613 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 2/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 2/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 2/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](bdg, l2, bdg, l2.h)
            assume(forall[B](bdg, (bb: B) => contains[B](bdg, bb)))
            assume(forall[B](bdg, (b: B) => contains[B](bdg, b)))
            !forall[B](bdg, (e: B) => contains[B](bdg, e)) || {
              val bdg: Boolean = forall[B](bdg, (e: B) => contains[B](bdg, e))
              true
            }
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 2/2))' VC for lemmaNoDuplicatePreservedSameContent @?:?:
debug:  => VALID
info Verified: 614 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: Cache miss: 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug:  - Now solving 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaNoDuplicatePreservedSameContent @?:?...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](bdg, l2, bdg, l2.h)
            assume(forall[B](bdg, (bb: B) => contains[B](bdg, bb)))
            assume(forall[B](bdg, (b: B) => contains[B](bdg, b)))
            val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, bdg)
            val bdg: BigInt = size[B](bdg)
            assume(bdg <= bdg)
            bdg < bdg || {
              val bdg: Boolean = contains[B](l2.t, l2.h)
              true
            }
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaNoDuplicatePreservedSameContent @?:?:
debug:  => VALID
info Verified: 615 / 982
debug:  - Checking cache: 'precond. (call lemmaNoDuplicatePreservedSameContent[... (require 1/3))' VC for lemmaNoDuplicatePreservedSameContent @1098:9...
debug: Cache miss: 'precond. (call lemmaNoDuplicatePreservedSameContent[... (require 1/3))' VC for lemmaNoDuplicatePreservedSameContent @1098:9...
debug:  - Now solving 'precond. (call lemmaNoDuplicatePreservedSameContent[... (require 1/3))' VC for lemmaNoDuplicatePreservedSameContent @1098:9...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](bdg, l2, bdg, l2.h)
            assume(forall[B](bdg, (bb: B) => contains[B](bdg, bb)))
            assume(forall[B](bdg, (b: B) => contains[B](bdg, b)))
            val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, bdg)
            val bdg: BigInt = size[B](bdg)
            assume(bdg <= bdg)
            bdg < bdg || {
              val bdg: Unit = if (contains[B](l2.t, l2.h)) {
                val bdg: Unit = lemmaRemoveElmtContainedSizeSmaller[B](l2.t, l2.h)
                assume(size[B](-[B](l2.t, l2.h)) < size[B](l2.t))
                assume(false)
                ()
              } else {
                ()
              }
              true
            }
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaNoDuplicatePreservedSameContent[... (require 1/3))' VC for lemmaNoDuplicatePreservedSameContent @1098:9:
debug:  => VALID
info Verified: 616 / 982
debug:  - Checking cache: 'precond. (call lemmaNoDuplicatePreservedSameContent[... (require 2/3))' VC for lemmaNoDuplicatePreservedSameContent @1098:9...
debug: Cache miss: 'precond. (call lemmaNoDuplicatePreservedSameContent[... (require 2/3))' VC for lemmaNoDuplicatePreservedSameContent @1098:9...
debug:  - Now solving 'precond. (call lemmaNoDuplicatePreservedSameContent[... (require 2/3))' VC for lemmaNoDuplicatePreservedSameContent @1098:9...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](bdg, l2, bdg, l2.h)
            assume(forall[B](bdg, (bb: B) => contains[B](bdg, bb)))
            assume(forall[B](bdg, (b: B) => contains[B](bdg, b)))
            val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, bdg)
            val bdg: BigInt = size[B](bdg)
            assume(bdg <= bdg)
            bdg < bdg || {
              val bdg: Unit = if (contains[B](l2.t, l2.h)) {
                val bdg: Unit = lemmaRemoveElmtContainedSizeSmaller[B](l2.t, l2.h)
                assume(size[B](-[B](l2.t, l2.h)) < size[B](l2.t))
                assume(false)
                ()
              } else {
                ()
              }
              bdg == size[B](l2.t)
            }
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaNoDuplicatePreservedSameContent[... (require 2/3))' VC for lemmaNoDuplicatePreservedSameContent @1098:9:
debug:  => VALID
info Verified: 617 / 982
debug:  - Checking cache: 'precond. (call lemmaNoDuplicatePreservedSameContent[... (require 3/3))' VC for lemmaNoDuplicatePreservedSameContent @1098:9...
debug: Cache miss: 'precond. (call lemmaNoDuplicatePreservedSameContent[... (require 3/3))' VC for lemmaNoDuplicatePreservedSameContent @1098:9...
debug:  - Now solving 'precond. (call lemmaNoDuplicatePreservedSameContent[... (require 3/3))' VC for lemmaNoDuplicatePreservedSameContent @1098:9...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](bdg, l2, bdg, l2.h)
            assume(forall[B](bdg, (bb: B) => contains[B](bdg, bb)))
            assume(forall[B](bdg, (b: B) => contains[B](bdg, b)))
            val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, bdg)
            val bdg: BigInt = size[B](bdg)
            assume(bdg <= bdg)
            bdg < bdg || {
              val bdg: Unit = if (contains[B](l2.t, l2.h)) {
                val bdg: Unit = lemmaRemoveElmtContainedSizeSmaller[B](l2.t, l2.h)
                assume(size[B](-[B](l2.t, l2.h)) < size[B](l2.t))
                assume(false)
                ()
              } else {
                ()
              }
              bdg != size[B](l2.t) || content[B](bdg) == content[B](l2.t)
            }
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaNoDuplicatePreservedSameContent[... (require 3/3))' VC for lemmaNoDuplicatePreservedSameContent @1098:9:
debug:  => VALID
info Verified: 618 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1067:12...
debug: Cache miss: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1067:12...
debug:  - Now solving 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1067:12...
debug: !noDuplicate[B](l1) || size[B](l1) != size[B](l2) || content[B](l1) != content[B](l2) || {
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
  assume(forall[B](l1, (b: B) => contains[B](l2, b)))
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
  assume(forall[B](l2, (b: B) => contains[B](l1, b)))
  forall[B](l1, (b: B) => contains[B](l2, b))
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1067:12:
debug:  => VALID
info Verified: 619 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1068:12...
debug: Cache miss: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1068:12...
debug:  - Now solving 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1068:12...
debug: !noDuplicate[B](l1) || size[B](l1) != size[B](l2) || content[B](l1) != content[B](l2) || {
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
  assume(forall[B](l1, (b: B) => contains[B](l2, b)))
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
  assume(forall[B](l2, (b: B) => contains[B](l1, b)))
  !forall[B](l1, (b: B) => contains[B](l2, b)) || forall[B](l2, (b: B) => contains[B](l1, b))
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1068:12:
debug:  => VALID
info Verified: 620 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1072:16...
debug: Cache miss: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1072:16...
debug:  - Now solving 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1072:16...
debug: !noDuplicate[B](l1) || size[B](l1) != size[B](l2) || content[B](l1) != content[B](l2) || {
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
  assume(forall[B](l1, (b: B) => contains[B](l2, b)))
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
  assume(forall[B](l2, (b: B) => contains[B](l1, b)))
  !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || contains[B](l1, l2.h)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1072:16:
debug:  => VALID
info Verified: 621 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1077:16...
debug: Cache miss: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1077:16...
debug:  - Now solving 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1077:16...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg >= bdg
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1077:16:
debug:  => VALID
info Verified: 622 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1079:16...
debug: Cache miss: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1079:16...
debug:  - Now solving 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1079:16...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        forall[B](bdg, (b: B) => contains[B](l2, b))
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1079:16:
debug:  => VALID
info Verified: 623 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1081:16...
debug: Cache miss: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1081:16...
debug:  - Now solving 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1081:16...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg >= bdg
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1081:16:
debug:  => VALID
info Verified: 624 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1082:16...
debug: Cache miss: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1082:16...
debug:  - Now solving 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1082:16...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || !contains[B](bdg, l2.h)
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1082:16:
debug:  => VALID
info Verified: 625 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1083:16...
debug: Cache miss: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1083:16...
debug:  - Now solving 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1083:16...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || {
            val bdg: Boolean = contains[B](bdg, l2.h)
            true
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1083:16:
debug:  => VALID
info Verified: 626 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1084:16...
debug: Cache miss: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1084:16...
debug:  - Now solving 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1084:16...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || forall[B](bdg, (b: B) => contains[B](l2, b))
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1084:16:
debug:  => VALID
info Verified: 627 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1089:16...
debug: Cache miss: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1089:16...
debug:  - Now solving 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1089:16...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](bdg, l2, bdg, l2.h)
            assume(forall[B](bdg, (bb: B) => contains[B](bdg, bb)))
            assume(forall[B](bdg, (b: B) => contains[B](bdg, b)))
            val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, bdg)
            val bdg: BigInt = size[B](bdg)
            assume(bdg <= bdg)
            bdg >= bdg
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1089:16:
debug:  => VALID
info Verified: 628 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1092:18...
debug: Cache miss: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1092:18...
debug:  - Now solving 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1092:18...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](bdg, l2, bdg, l2.h)
            assume(forall[B](bdg, (bb: B) => contains[B](bdg, bb)))
            assume(forall[B](bdg, (b: B) => contains[B](bdg, b)))
            val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, bdg)
            val bdg: BigInt = size[B](bdg)
            assume(bdg <= bdg)
            bdg < bdg || !contains[B](l2.t, l2.h) || {
              val bdg: Unit = lemmaRemoveElmtContainedSizeSmaller[B](l2.t, l2.h)
              assume(size[B](-[B](l2.t, l2.h)) < size[B](l2.t))
              true
            }
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1092:18:
debug:  => VALID
info Verified: 629 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1093:18...
debug: Cache miss: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1093:18...
debug:  - Now solving 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1093:18...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](bdg, l2, bdg, l2.h)
            assume(forall[B](bdg, (bb: B) => contains[B](bdg, bb)))
            assume(forall[B](bdg, (b: B) => contains[B](bdg, b)))
            val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, bdg)
            val bdg: BigInt = size[B](bdg)
            assume(bdg <= bdg)
            bdg < bdg || !contains[B](l2.t, l2.h) || {
              val bdg: Unit = lemmaRemoveElmtContainedSizeSmaller[B](l2.t, l2.h)
              val bdg: BigInt = size[B](-[B](l2.t, l2.h))
              val bdg: BigInt = size[B](l2.t)
              assume(bdg < bdg)
              bdg < bdg
            }
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1093:18:
debug:  => VALID
info Verified: 630 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1094:18...
debug: Cache miss: 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1094:18...
debug:  - Now solving 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1094:18...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](bdg, l2, bdg, l2.h)
            assume(forall[B](bdg, (bb: B) => contains[B](bdg, bb)))
            assume(forall[B](bdg, (b: B) => contains[B](bdg, b)))
            val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, bdg)
            val bdg: BigInt = size[B](bdg)
            assume(bdg <= bdg)
            bdg < bdg || !contains[B](l2.t, l2.h) || {
              val bdg: Unit = lemmaRemoveElmtContainedSizeSmaller[B](l2.t, l2.h)
              val bdg: BigInt = size[B](-[B](l2.t, l2.h))
              val bdg: BigInt = size[B](l2.t)
              assume(bdg < bdg)
              bdg >= bdg
            }
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaNoDuplicatePreservedSameContent @1094:18:
debug:  => VALID
info Verified: 631 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaNoDuplicatePreservedSameContent @1101:37...
debug: Cache miss: 'non-negative measure' VC for lemmaNoDuplicatePreservedSameContent @1101:37...
debug:  - Now solving 'non-negative measure' VC for lemmaNoDuplicatePreservedSameContent @1101:37...
debug: !noDuplicate[B](l1) || size[B](l1) != size[B](l2) || content[B](l1) != content[B](l2) || ListPrimitiveSize[B](l2) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaNoDuplicatePreservedSameContent @1101:37:
debug:  => VALID
info Verified: 632 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaSubsetContentThenForallContains' VC for lemmaNoDuplicatePreservedSameContent @1065:5...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaSubsetContentThenForallContains' VC for lemmaNoDuplicatePreservedSameContent @1065:5...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaSubsetContentThenForallContains' VC for lemmaNoDuplicatePreservedSameContent @1065:5...
debug: !noDuplicate[B](l1) || size[B](l1) != size[B](l2) || {
  val bdg: Set[B] = content[B](l1)
  val bdg: Set[B] = content[B](l2)
  bdg != bdg || bdg.subsetOf(bdg)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaSubsetContentThenForallContains' VC for lemmaNoDuplicatePreservedSameContent @1065:5:
debug:  => VALID
info Verified: 633 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaSubsetContentThenForallContains' VC for lemmaNoDuplicatePreservedSameContent @1066:5...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaSubsetContentThenForallContains' VC for lemmaNoDuplicatePreservedSameContent @1066:5...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaSubsetContentThenForallContains' VC for lemmaNoDuplicatePreservedSameContent @1066:5...
debug: !noDuplicate[B](l1) || size[B](l1) != size[B](l2) || {
  val bdg: Set[B] = content[B](l1)
  val bdg: Set[B] = content[B](l2)
  bdg != bdg || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    bdg.subsetOf(bdg)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaSubsetContentThenForallContains' VC for lemmaNoDuplicatePreservedSameContent @1066:5:
debug:  => VALID
info Verified: 634 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaNoDuplicatePreservedSameContent @1101:15...
debug: Cache miss: 'postcondition' VC for lemmaNoDuplicatePreservedSameContent @1101:15...
debug:  - Now solving 'postcondition' VC for lemmaNoDuplicatePreservedSameContent @1101:15...
debug: !noDuplicate[B](l1) || size[B](l1) != size[B](l2) || content[B](l1) != content[B](l2) || {
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
  assume(forall[B](l1, (b: B) => contains[B](l2, b)))
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
  assume(forall[B](l2, (b: B) => contains[B](l1, b)))
  !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || !l2.isInstanceOf[Nil] || noDuplicate[B](l2)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaNoDuplicatePreservedSameContent @1101:15:
debug:  => VALID
info Verified: 635 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaRemoveOneElmtPreservesNoDuplicate' VC for lemmaNoDuplicatePreservedSameContent @1074:9...
debug: Cache hit: 'body assertion: Inlined precondition of lemmaRemoveOneElmtPreservesNoDuplicate' VC for lemmaNoDuplicatePreservedSameContent @1074:9...
info Verified: 636 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne' VC for lemmaNoDuplicatePreservedSameContent @1075:9...
debug: Cache hit: 'body assertion: Inlined precondition (1/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne' VC for lemmaNoDuplicatePreservedSameContent @1075:9...
info Verified: 637 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne' VC for lemmaNoDuplicatePreservedSameContent @1075:9...
debug: Cache hit: 'body assertion: Inlined precondition (2/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne' VC for lemmaNoDuplicatePreservedSameContent @1075:9...
info Verified: 638 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaForallContainsPreservedRemoveElmt' VC for lemmaNoDuplicatePreservedSameContent @1078:9...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaForallContainsPreservedRemoveElmt' VC for lemmaNoDuplicatePreservedSameContent @1078:9...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaForallContainsPreservedRemoveElmt' VC for lemmaNoDuplicatePreservedSameContent @1078:9...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || forall[B](l1, (b: B) => contains[B](l2, b))
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaForallContainsPreservedRemoveElmt' VC for lemmaNoDuplicatePreservedSameContent @1078:9:
debug:  => VALID
info Verified: 639 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1080:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1080:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1080:9...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || forall[B](bdg, (e: B) => contains[B](l2, e))
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1080:9:
debug:  => VALID
info Verified: 640 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1080:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1080:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1080:9...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Boolean = forall[B](bdg, (e: B) => contains[B](l2, e))
          true
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1080:9:
debug:  => VALID
info Verified: 641 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/3) of lemmaForallContainsPreservedRemoveElmtInRefList' VC for lemmaNoDuplicatePreservedSameContent @1086:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/3) of lemmaForallContainsPreservedRemoveElmtInRefList' VC for lemmaNoDuplicatePreservedSameContent @1086:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/3) of lemmaForallContainsPreservedRemoveElmtInRefList' VC for lemmaNoDuplicatePreservedSameContent @1086:9...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            forall[B](bdg, (bb: B) => contains[B](l2, bb))
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/3) of lemmaForallContainsPreservedRemoveElmtInRefList' VC for lemmaNoDuplicatePreservedSameContent @1086:9:
debug:  => VALID
info Verified: 642 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/3) of lemmaForallContainsPreservedRemoveElmtInRefList' VC for lemmaNoDuplicatePreservedSameContent @1086:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/3) of lemmaForallContainsPreservedRemoveElmtInRefList' VC for lemmaNoDuplicatePreservedSameContent @1086:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/3) of lemmaForallContainsPreservedRemoveElmtInRefList' VC for lemmaNoDuplicatePreservedSameContent @1086:9...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Boolean = forall[B](bdg, (bb: B) => contains[B](l2, bb))
            true
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/3) of lemmaForallContainsPreservedRemoveElmtInRefList' VC for lemmaNoDuplicatePreservedSameContent @1086:9:
debug:  => VALID
info Verified: 643 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (3/3) of lemmaForallContainsPreservedRemoveElmtInRefList' VC for lemmaNoDuplicatePreservedSameContent @1086:9...
debug: Cache hit: 'body assertion: Inlined precondition (3/3) of lemmaForallContainsPreservedRemoveElmtInRefList' VC for lemmaNoDuplicatePreservedSameContent @1086:9...
info Verified: 644 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of check' VC for lemmaNoDuplicatePreservedSameContent @1087:9...
debug: Cache miss: 'body assertion: Inlined precondition of check' VC for lemmaNoDuplicatePreservedSameContent @1087:9...
debug:  - Now solving 'body assertion: Inlined precondition of check' VC for lemmaNoDuplicatePreservedSameContent @1087:9...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](bdg, l2, bdg, l2.h)
            assume(forall[B](bdg, (bb: B) => contains[B](bdg, bb)))
            forall[B](bdg, (b: B) => contains[B](bdg, b))
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of check' VC for lemmaNoDuplicatePreservedSameContent @1087:9:
debug:  => VALID
info Verified: 645 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1088:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1088:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1088:9...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](bdg, l2, bdg, l2.h)
            assume(forall[B](bdg, (bb: B) => contains[B](bdg, bb)))
            assume(forall[B](bdg, (b: B) => contains[B](bdg, b)))
            forall[B](bdg, (e: B) => contains[B](bdg, e))
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1088:9:
debug:  => VALID
info Verified: 646 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1088:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1088:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1088:9...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](bdg, l2, bdg, l2.h)
            assume(forall[B](bdg, (bb: B) => contains[B](bdg, bb)))
            assume(forall[B](bdg, (b: B) => contains[B](bdg, b)))
            val bdg: Boolean = forall[B](bdg, (e: B) => contains[B](bdg, e))
            true
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaNoDuplicatePreservedSameContent @1088:9:
debug:  => VALID
info Verified: 647 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaRemoveElmtContainedSizeSmaller' VC for lemmaNoDuplicatePreservedSameContent @1091:11...
debug: Cache hit: 'body assertion: Inlined precondition of lemmaRemoveElmtContainedSizeSmaller' VC for lemmaNoDuplicatePreservedSameContent @1091:11...
info Verified: 648 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of check' VC for lemmaNoDuplicatePreservedSameContent @1095:11...
debug: Cache hit: 'body assertion: Inlined precondition of check' VC for lemmaNoDuplicatePreservedSameContent @1095:11...
info Verified: 649 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaNoDuplicatePreservedSameContent @1098:9...
debug: Cache miss: 'measure decreases' VC for lemmaNoDuplicatePreservedSameContent @1098:9...
debug:  - Now solving 'measure decreases' VC for lemmaNoDuplicatePreservedSameContent @1098:9...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](bdg, l2, bdg, l2.h)
            assume(forall[B](bdg, (bb: B) => contains[B](bdg, bb)))
            assume(forall[B](bdg, (b: B) => contains[B](bdg, b)))
            val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, bdg)
            val bdg: BigInt = size[B](bdg)
            assume(bdg <= bdg)
            bdg < bdg || {
              val bdg: Unit = if (contains[B](l2.t, l2.h)) {
                val bdg: Unit = lemmaRemoveElmtContainedSizeSmaller[B](l2.t, l2.h)
                assume(size[B](-[B](l2.t, l2.h)) < size[B](l2.t))
                assume(false)
                ()
              } else {
                ()
              }
              ListPrimitiveSize[B](l2.t) < ListPrimitiveSize[B](l2)
            }
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaNoDuplicatePreservedSameContent @1098:9:
debug:  => VALID
info Verified: 650 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaNoDuplicatePreservedSameContent @1101:15...
debug: Cache miss: 'postcondition' VC for lemmaNoDuplicatePreservedSameContent @1101:15...
debug:  - Now solving 'postcondition' VC for lemmaNoDuplicatePreservedSameContent @1101:15...
debug: !noDuplicate[B](l1) || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg != bdg || content[B](l1) != content[B](l2) || {
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
    assume(forall[B](l1, (b: B) => contains[B](l2, b)))
    val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
    assume(forall[B](l2, (b: B) => contains[B](l1, b)))
    !forall[B](l1, (b: B) => contains[B](l2, b)) || !forall[B](l2, (b: B) => contains[B](l1, b)) || l2.isInstanceOf[Nil] || !contains[B](l1, l2.h) || {
      val bdg: List[B] = -[B](l1, l2.h)
      val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l1, l2.h)
      assume(noDuplicate[B](bdg))
      val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l1, l2.h)
      assume(isEmpty[B](l1) || size[B](bdg) == bdg - BigInt("1"))
      bdg < bdg || {
        val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l1, l2, l2.h)
        assume(forall[B](bdg, (b: B) => contains[B](l2, b)))
        !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
          val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](l2, bdg)
          val bdg: BigInt = size[B](bdg)
          assume(bdg <= bdg)
          bdg < bdg || contains[B](bdg, l2.h) || !forall[B](bdg, (b: B) => contains[B](l2, b)) || {
            val bdg: List[B] = -[B](l2, l2.h)
            val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](bdg, l2, bdg, l2.h)
            assume(forall[B](bdg, (bb: B) => contains[B](bdg, bb)))
            assume(forall[B](bdg, (b: B) => contains[B](bdg, b)))
            val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, bdg)
            val bdg: BigInt = size[B](bdg)
            assume(bdg <= bdg)
            bdg < bdg || {
              val bdg: Unit = if (contains[B](l2.t, l2.h)) {
                val bdg: Unit = lemmaRemoveElmtContainedSizeSmaller[B](l2.t, l2.h)
                assume(size[B](-[B](l2.t, l2.h)) < size[B](l2.t))
                assume(false)
                ()
              } else {
                ()
              }
              val bdg: Unit = lemmaNoDuplicatePreservedSameContent[B](bdg, l2.t)
              noDuplicate[B](l2)
            }
          }
        }
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaNoDuplicatePreservedSameContent @1101:15:
debug:  => VALID
info Verified: 651 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaNoDuplicatePreservedSameContent @1069:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaNoDuplicatePreservedSameContent @1069:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaNoDuplicatePreservedSameContent @1069:5...
debug: !noDuplicate[B](l1) || size[B](l1) != size[B](l2) || content[B](l1) != content[B](l2) || {
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1, l2)
  assume(forall[B](l1, (b: B) => contains[B](l2, b)))
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l2, l1)
  assume(forall[B](l2, (b: B) => contains[B](l1, b)))
  !forall[B](l1, (b: B) => contains[B](l2, b)) || {
    val bdg: Boolean = forall[B](l2, (b: B) => contains[B](l1, b))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaNoDuplicatePreservedSameContent @1069:5:
debug:  => VALID
info Verified: 652 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaNoDuplicatePreservedSameContent @1101:15...
debug: Cache hit: 'postcondition' VC for lemmaNoDuplicatePreservedSameContent @1101:15...
info Verified: 653 / 982
debug:  - Checking cache: 'precond. (call forallContainsSubset[B](lIn, l))' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @822:9...
debug: Cache miss: 'precond. (call forallContainsSubset[B](lIn, l))' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @822:9...
debug:  - Now solving 'precond. (call forallContainsSubset[B](lIn, l))' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @822:9...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || forall[B](lIn, (v: B) => contains[B](l, v))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call forallContainsSubset[B](lIn, l))' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @822:9:
debug:  => VALID
info Verified: 654 / 982
debug:  - Checking cache: 'precond. (call subsetContains[B]((scrut.t): @DropVCs...)' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @827:9...
debug: Cache miss: 'precond. (call subsetContains[B]((scrut.t): @DropVCs...)' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @827:9...
debug:  - Now solving 'precond. (call subsetContains[B]((scrut.t): @DropVCs...)' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @827:9...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || {
  val bdg: Unit = forallContainsSubset[B](lIn, l)
  val bdg: Set[B] = content[B](lIn)
  val bdg: Set[B] = content[B](l)
  !bdg.subsetOf(bdg) || contains[B](lIn.t, lIn.h) || {
    val bdg: Set[B] = content[B](-[B](l, lIn.h))
    bdg != bdg \\ Set(lIn.h) || content[B](lIn.t).subsetOf(bdg)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call subsetContains[B]((scrut.t): @DropVCs...)' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @827:9:
debug:  => VALID
info Verified: 655 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 1/2))' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 1/2))' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 1/2))' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || {
  val bdg: Unit = forallContainsSubset[B](lIn, l)
  val bdg: Set[B] = content[B](lIn)
  val bdg: Set[B] = content[B](l)
  !bdg.subsetOf(bdg) || contains[B](lIn.t, lIn.h) || {
    val bdg: List[B] = -[B](l, lIn.h)
    content[B](bdg) != bdg \\ Set(lIn.h) || {
      val bdg: Unit = subsetContains[B](lIn.t, bdg)
      !forall[B](lIn.t, (e: B) => contains[B](bdg, e)) || !noDuplicate[B](lIn.t) || forall[B](lIn.t, (e: B) => contains[B](bdg, e))
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 1/2))' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?:
debug:  => VALID
info Verified: 656 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 2/2))' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 2/2))' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 2/2))' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || {
  val bdg: Unit = forallContainsSubset[B](lIn, l)
  val bdg: Set[B] = content[B](lIn)
  val bdg: Set[B] = content[B](l)
  !bdg.subsetOf(bdg) || contains[B](lIn.t, lIn.h) || {
    val bdg: List[B] = -[B](l, lIn.h)
    content[B](bdg) != bdg \\ Set(lIn.h) || {
      val bdg: Unit = subsetContains[B](lIn.t, bdg)
      !forall[B](lIn.t, (e: B) => contains[B](bdg, e)) || !noDuplicate[B](lIn.t) || {
        val bdg: Boolean = forall[B](lIn.t, (e: B) => contains[B](bdg, e))
        true
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsAndNoDuplicateThen... (require 2/2))' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?:
debug:  => VALID
info Verified: 657 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?...
debug: Cache miss: 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?...
debug:  - Now solving 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || {
  val bdg: Unit = forallContainsSubset[B](lIn, l)
  val bdg: Set[B] = content[B](lIn)
  val bdg: Set[B] = content[B](l)
  !bdg.subsetOf(bdg) || contains[B](lIn.t, lIn.h) || {
    val bdg: List[B] = -[B](l, lIn.h)
    content[B](bdg) != bdg \\ Set(lIn.h) || {
      val bdg: Unit = subsetContains[B](lIn.t, bdg)
      val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, lIn.t)
      val bdg: BigInt = size[B](lIn.t)
      assume(bdg <= size[B](bdg))
      BigInt("1") + bdg != size[B](lIn) || {
        val bdg: Boolean = contains[B](l, lIn.h)
        true
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?:
debug:  => VALID
info Verified: 658 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @823:16...
debug: Cache miss: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @823:16...
debug:  - Now solving 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @823:16...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || {
  val bdg: Unit = forallContainsSubset[B](lIn, l)
  content[B](lIn).subsetOf(content[B](l))
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @823:16:
debug:  => VALID
info Verified: 659 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @824:16...
debug: Cache miss: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @824:16...
debug:  - Now solving 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @824:16...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || {
  val bdg: Unit = forallContainsSubset[B](lIn, l)
  !content[B](lIn).subsetOf(content[B](l)) || !contains[B](lIn.t, lIn.h)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @824:16:
debug:  => VALID
info Verified: 660 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @826:16...
debug: Cache miss: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @826:16...
debug:  - Now solving 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @826:16...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || {
  val bdg: Unit = forallContainsSubset[B](lIn, l)
  val bdg: Set[B] = content[B](lIn)
  val bdg: Set[B] = content[B](l)
  !bdg.subsetOf(bdg) || contains[B](lIn.t, lIn.h) || content[B](-[B](l, lIn.h)) == bdg \\ Set(lIn.h)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @826:16:
debug:  => VALID
info Verified: 661 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @829:16...
debug: Cache miss: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @829:16...
debug:  - Now solving 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @829:16...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || {
  val bdg: Unit = forallContainsSubset[B](lIn, l)
  val bdg: Set[B] = content[B](lIn)
  val bdg: Set[B] = content[B](l)
  !bdg.subsetOf(bdg) || contains[B](lIn.t, lIn.h) || {
    val bdg: List[B] = -[B](l, lIn.h)
    content[B](bdg) != bdg \\ Set(lIn.h) || {
      val bdg: Unit = subsetContains[B](lIn.t, bdg)
      val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, lIn.t)
      assume(size[B](lIn.t) <= size[B](bdg))
      true
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @829:16:
debug:  => VALID
info Verified: 662 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @830:16...
debug: Cache miss: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @830:16...
debug:  - Now solving 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @830:16...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || {
  val bdg: Unit = forallContainsSubset[B](lIn, l)
  val bdg: Set[B] = content[B](lIn)
  val bdg: Set[B] = content[B](l)
  !bdg.subsetOf(bdg) || contains[B](lIn.t, lIn.h) || {
    val bdg: List[B] = -[B](l, lIn.h)
    content[B](bdg) != bdg \\ Set(lIn.h) || {
      val bdg: Unit = subsetContains[B](lIn.t, bdg)
      val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, lIn.t)
      val bdg: BigInt = size[B](lIn.t)
      assume(bdg <= size[B](bdg))
      BigInt("1") + bdg == size[B](lIn)
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @830:16:
debug:  => VALID
info Verified: 663 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @831:16...
debug: Cache miss: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @831:16...
debug:  - Now solving 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @831:16...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || {
  val bdg: Unit = forallContainsSubset[B](lIn, l)
  val bdg: Set[B] = content[B](lIn)
  val bdg: Set[B] = content[B](l)
  !bdg.subsetOf(bdg) || contains[B](lIn.t, lIn.h) || {
    val bdg: List[B] = -[B](l, lIn.h)
    content[B](bdg) != bdg \\ Set(lIn.h) || {
      val bdg: Unit = subsetContains[B](lIn.t, bdg)
      val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, lIn.t)
      val bdg: BigInt = size[B](lIn.t)
      assume(bdg <= size[B](bdg))
      BigInt("1") + bdg != size[B](lIn) || contains[B](l, lIn.h)
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @831:16:
debug:  => VALID
info Verified: 664 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @832:16...
debug: Cache hit: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @832:16...
info Verified: 665 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @834:16...
debug: Cache miss: 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @834:16...
debug:  - Now solving 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @834:16...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || {
  val bdg: Unit = forallContainsSubset[B](lIn, l)
  val bdg: Set[B] = content[B](lIn)
  val bdg: Set[B] = content[B](l)
  !bdg.subsetOf(bdg) || contains[B](lIn.t, lIn.h) || {
    val bdg: List[B] = -[B](l, lIn.h)
    content[B](bdg) != bdg \\ Set(lIn.h) || {
      val bdg: Unit = subsetContains[B](lIn.t, bdg)
      val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, lIn.t)
      val bdg: BigInt = size[B](lIn.t)
      val bdg: BigInt = size[B](bdg)
      assume(bdg <= bdg)
      BigInt("1") + bdg != size[B](lIn) || !contains[B](l, lIn.h) || {
        val bdg: Unit = lemmaRemoveElmtContainedSizeSmaller[B](l, lIn.h)
        val bdg: BigInt = size[B](l)
        assume(bdg < bdg)
        bdg > bdg
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @834:16:
debug:  => VALID
info Verified: 666 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @817:15...
debug: Cache miss: 'non-negative measure' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @817:15...
debug:  - Now solving 'non-negative measure' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @817:15...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || size[B](lIn) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @817:15:
debug:  => VALID
info Verified: 667 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @828:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @828:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @828:9...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || {
  val bdg: Unit = forallContainsSubset[B](lIn, l)
  val bdg: Set[B] = content[B](lIn)
  val bdg: Set[B] = content[B](l)
  !bdg.subsetOf(bdg) || contains[B](lIn.t, lIn.h) || {
    val bdg: List[B] = -[B](l, lIn.h)
    content[B](bdg) != bdg \\ Set(lIn.h) || {
      val bdg: Unit = subsetContains[B](lIn.t, bdg)
      forall[B](lIn.t, (e: B) => contains[B](bdg, e))
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @828:9:
debug:  => VALID
info Verified: 668 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @828:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @828:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @828:9...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || {
  val bdg: Unit = forallContainsSubset[B](lIn, l)
  val bdg: Set[B] = content[B](lIn)
  val bdg: Set[B] = content[B](l)
  !bdg.subsetOf(bdg) || contains[B](lIn.t, lIn.h) || {
    val bdg: List[B] = -[B](l, lIn.h)
    content[B](bdg) != bdg \\ Set(lIn.h) || {
      val bdg: Unit = subsetContains[B](lIn.t, bdg)
      !forall[B](lIn.t, (e: B) => contains[B](bdg, e)) || noDuplicate[B](lIn.t)
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @828:9:
debug:  => VALID
info Verified: 669 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || {
  val bdg: Unit = forallContainsSubset[B](lIn, l)
  val bdg: Set[B] = content[B](lIn)
  val bdg: Set[B] = content[B](l)
  !bdg.subsetOf(bdg) || contains[B](lIn.t, lIn.h) || {
    val bdg: List[B] = -[B](l, lIn.h)
    content[B](bdg) != bdg \\ Set(lIn.h) || {
      val bdg: Unit = subsetContains[B](lIn.t, bdg)
      !forall[B](lIn.t, (e: B) => contains[B](bdg, e)) || !noDuplicate[B](lIn.t) || size[B](lIn.t) < size[B](lIn)
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @?:?:
debug:  => VALID
info Verified: 670 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaRemoveElmtContainedSizeSmaller' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @833:9...
debug: Cache hit: 'body assertion: Inlined precondition of lemmaRemoveElmtContainedSizeSmaller' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @833:9...
info Verified: 671 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @834:9...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @834:9...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @834:9...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || !lIn.isInstanceOf[Cons] || {
  val bdg: Unit = forallContainsSubset[B](lIn, l)
  val bdg: Set[B] = content[B](lIn)
  val bdg: Set[B] = content[B](l)
  !bdg.subsetOf(bdg) || contains[B](lIn.t, lIn.h) || {
    val bdg: List[B] = -[B](l, lIn.h)
    content[B](bdg) != bdg \\ Set(lIn.h) || {
      val bdg: Unit = subsetContains[B](lIn.t, bdg)
      val bdg: Unit = lemmaForallContainsAndNoDuplicateThenSmallerList[B](bdg, lIn.t)
      val bdg: BigInt = size[B](lIn.t)
      val bdg: BigInt = size[B](bdg)
      assume(bdg <= bdg)
      val bdg: BigInt = size[B](lIn)
      BigInt("1") + bdg != bdg || !contains[B](l, lIn.h) || {
        val bdg: Unit = lemmaRemoveElmtContainedSizeSmaller[B](l, lIn.h)
        val bdg: BigInt = size[B](l)
        assume(bdg < bdg)
        bdg <= bdg || bdg <= bdg
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @834:9:
debug:  => VALID
info Verified: 672 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @836:21...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @836:21...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @836:21...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || !noDuplicate[B](lIn) || lIn.isInstanceOf[Cons] || size[B](lIn) <= size[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @836:21:
debug:  => VALID
info Verified: 673 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @819:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @819:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @819:5...
debug: !forall[B](lIn, (e: B) => contains[B](l, e)) || {
  val bdg: Boolean = noDuplicate[B](lIn)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @819:5:
debug:  => VALID
info Verified: 674 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @819:5...
debug: Cache hit: 'postcondition' VC for lemmaForallContainsAndNoDuplicateThenSmallerList @819:5...
info Verified: 675 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 1/3))' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 1/3))' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 1/3))' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug: !forall[B](l, (bb: B) => contains[B](lRef, bb)) || contains[B](l, b) || newLRef != -[B](lRef, b) || !l.isInstanceOf[Cons] || forall[B](l.t, (bb: B) => contains[B](lRef, bb))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 1/3))' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?:
debug:  => VALID
info Verified: 676 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 2/3))' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 2/3))' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 2/3))' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug: !forall[B](l, (bb: B) => contains[B](lRef, bb)) || contains[B](l, b) || newLRef != -[B](lRef, b) || !l.isInstanceOf[Cons] || !forall[B](l.t, (bb: B) => contains[B](lRef, bb)) || !contains[B](l.t, b)
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 2/3))' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?:
debug:  => VALID
info Verified: 677 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 3/3))' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug: Cache miss: 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 3/3))' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug:  - Now solving 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 3/3))' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug: !forall[B](l, (bb: B) => contains[B](lRef, bb)) || contains[B](l, b) || newLRef != -[B](lRef, b) || !l.isInstanceOf[Cons] || !forall[B](l.t, (bb: B) => contains[B](lRef, bb)) || {
  val bdg: Boolean = contains[B](l.t, b)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallContainsPreservedRemoveElm... (require 3/3))' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?:
debug:  => VALID
info Verified: 678 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallContainsPreservedRemoveElmtInRefList @901:66...
debug: Cache miss: 'non-negative measure' VC for lemmaForallContainsPreservedRemoveElmtInRefList @901:66...
debug:  - Now solving 'non-negative measure' VC for lemmaForallContainsPreservedRemoveElmtInRefList @901:66...
debug: !forall[B](l, (bb: B) => contains[B](lRef, bb)) || contains[B](l, b) || newLRef != -[B](lRef, b) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaForallContainsPreservedRemoveElmtInRefList @901:66:
debug:  => VALID
info Verified: 679 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug: !forall[B](l, (bb: B) => contains[B](lRef, bb)) || contains[B](l, b) || newLRef != -[B](lRef, b) || !l.isInstanceOf[Cons] || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?:
debug:  => VALID
info Verified: 680 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug: !forall[B](l, (bb: B) => contains[B](lRef, bb)) || contains[B](l, b) || newLRef != -[B](lRef, b) || !l.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaForallContainsPreservedRemoveElmtInRefList[B](l.t, lRef, newLRef, b)
  forall[B](l, (bb: B) => contains[B](newLRef, bb))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?:
debug:  => VALID
info Verified: 681 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug: !forall[B](l, (bb: B) => contains[B](lRef, bb)) || contains[B](l, b) || newLRef != -[B](lRef, b) || l.isInstanceOf[Cons] || forall[B](l, (bb: B) => contains[B](newLRef, bb))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?:
debug:  => VALID
info Verified: 682 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug: !forall[B](l, (bb: B) => contains[B](lRef, bb)) || contains[B](l, b) || {
  val bdg: List[B] = -[B](lRef, b)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?:
debug:  => VALID
info Verified: 683 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
debug: Cache hit: 'postcondition' VC for lemmaForallContainsPreservedRemoveElmtInRefList @?:?...
info Verified: 684 / 982
debug:  - Checking cache: 'precond. (call lemmaSubsetContentThenForallContains[...)' VC for lemmaSubsetContentThenForallContains @?:?...
debug: Cache miss: 'precond. (call lemmaSubsetContentThenForallContains[...)' VC for lemmaSubsetContentThenForallContains @?:?...
debug:  - Now solving 'precond. (call lemmaSubsetContentThenForallContains[...)' VC for lemmaSubsetContentThenForallContains @?:?...
debug: val bdg: Set[B] = content[B](l1)
val bdg: Set[B] = content[B](l2)
!bdg.subsetOf(bdg) || !l1.isInstanceOf[Cons] || content[B](l1.t).subsetOf(bdg)
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaSubsetContentThenForallContains[...)' VC for lemmaSubsetContentThenForallContains @?:?:
debug:  => VALID
info Verified: 685 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaSubsetContentThenForallContains @1119:55...
debug: Cache miss: 'non-negative measure' VC for lemmaSubsetContentThenForallContains @1119:55...
debug:  - Now solving 'non-negative measure' VC for lemmaSubsetContentThenForallContains @1119:55...
debug: !content[B](l1).subsetOf(content[B](l2)) || ListPrimitiveSize[B](l1) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaSubsetContentThenForallContains @1119:55:
debug:  => VALID
info Verified: 686 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSubsetContentThenForallContains @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSubsetContentThenForallContains @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSubsetContentThenForallContains @?:?...
debug: !content[B](l1).subsetOf(content[B](l2)) || !l1.isInstanceOf[Cons] || ListPrimitiveSize[B](l1.t) < ListPrimitiveSize[B](l1)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSubsetContentThenForallContains @?:?:
debug:  => VALID
info Verified: 687 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubsetContentThenForallContains @?:?...
debug: Cache miss: 'postcondition' VC for lemmaSubsetContentThenForallContains @?:?...
debug:  - Now solving 'postcondition' VC for lemmaSubsetContentThenForallContains @?:?...
debug: !content[B](l1).subsetOf(content[B](l2)) || !l1.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaSubsetContentThenForallContains[B](l1.t, l2)
  forall[B](l1, (b: B) => contains[B](l2, b))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubsetContentThenForallContains @?:?:
debug:  => VALID
info Verified: 688 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubsetContentThenForallContains @?:?...
debug: Cache miss: 'postcondition' VC for lemmaSubsetContentThenForallContains @?:?...
debug:  - Now solving 'postcondition' VC for lemmaSubsetContentThenForallContains @?:?...
debug: !content[B](l1).subsetOf(content[B](l2)) || l1.isInstanceOf[Cons] || forall[B](l1, (b: B) => contains[B](l2, b))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubsetContentThenForallContains @?:?:
debug:  => VALID
info Verified: 689 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaSubsetContentThenForallContains @?:?...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaSubsetContentThenForallContains @?:?...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaSubsetContentThenForallContains @?:?...
debug: val bdg: Set[B] = content[B](l1)
val bdg: Set[B] = content[B](l2)
true
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaSubsetContentThenForallContains @?:?:
debug:  => VALID
info Verified: 690 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubsetContentThenForallContains @?:?...
debug: Cache hit: 'postcondition' VC for lemmaSubsetContentThenForallContains @?:?...
info Verified: 691 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaRemoveElmtContainedSizeSmaller @?:?...
debug: Cache miss: 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaRemoveElmtContainedSizeSmaller @?:?...
debug:  - Now solving 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaRemoveElmtContainedSizeSmaller @?:?...
debug: !contains[B](l, e) || !l.isInstanceOf[Cons] || l.h != e || -[B](l, e) != -[B](l.t, e) || {
  val bdg: Boolean = contains[B](l.t, e)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaRemoveElmtContainedSizeSmaller @?:?:
debug:  => VALID
info Verified: 692 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaRemoveElmtContainedSizeSmaller @?:?...
debug: Cache miss: 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaRemoveElmtContainedSizeSmaller @?:?...
debug:  - Now solving 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaRemoveElmtContainedSizeSmaller @?:?...
debug: !contains[B](l, e) || l.isInstanceOf[Cons] && l.h == e || !l.isInstanceOf[Cons] || {
  val bdg: Boolean = contains[B](l.t, e)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)' VC for lemmaRemoveElmtContainedSizeSmaller @?:?:
debug:  => VALID
info Verified: 693 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaRemoveElmtContainedSizeSmaller @991:16...
debug: Cache miss: 'body assertion' VC for lemmaRemoveElmtContainedSizeSmaller @991:16...
debug:  - Now solving 'body assertion' VC for lemmaRemoveElmtContainedSizeSmaller @991:16...
debug: !contains[B](l, e) || !l.isInstanceOf[Cons] || l.h != e || -[B](l, e) == -[B](l.t, e)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaRemoveElmtContainedSizeSmaller @991:16:
debug:  => VALID
info Verified: 694 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaRemoveElmtContainedSizeSmaller @999:30...
debug: Cache miss: 'non-negative measure' VC for lemmaRemoveElmtContainedSizeSmaller @999:30...
debug:  - Now solving 'non-negative measure' VC for lemmaRemoveElmtContainedSizeSmaller @999:30...
debug: !contains[B](l, e) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaRemoveElmtContainedSizeSmaller @999:30:
debug:  => VALID
info Verified: 695 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaRemoveElmtContainedSizeSmaller' VC for lemmaRemoveElmtContainedSizeSmaller @993:11...
debug: Cache hit: 'body assertion: Inlined precondition of lemmaRemoveElmtContainedSizeSmaller' VC for lemmaRemoveElmtContainedSizeSmaller @993:11...
info Verified: 696 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaRemoveElmtContainedSizeSmaller @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaRemoveElmtContainedSizeSmaller @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaRemoveElmtContainedSizeSmaller @?:?...
debug: !contains[B](l, e) || !l.isInstanceOf[Cons] || l.h != e || -[B](l, e) != -[B](l.t, e) || !contains[B](l.t, e) || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaRemoveElmtContainedSizeSmaller @?:?:
debug:  => VALID
info Verified: 697 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @993:11...
debug: Cache miss: 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @993:11...
debug:  - Now solving 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @993:11...
debug: !contains[B](l, e) || !l.isInstanceOf[Cons] || l.h != e || {
  val bdg: List[B] = -[B](l, e)
  val bdg: List[B] = -[B](l.t, e)
  bdg != bdg || !contains[B](l.t, e) || {
    val bdg: Unit = lemmaRemoveElmtContainedSizeSmaller[B](l.t, e)
    assume(size[B](bdg) < size[B](l.t))
    size[B](bdg) < size[B](l)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @993:11:
debug:  => VALID
info Verified: 698 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @994:10...
debug: Cache miss: 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @994:10...
debug:  - Now solving 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @994:10...
debug: !contains[B](l, e) || !l.isInstanceOf[Cons] || l.h != e || {
  val bdg: List[B] = -[B](l, e)
  bdg != -[B](l.t, e) || contains[B](l.t, e) || size[B](bdg) < size[B](l)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @994:10:
debug:  => VALID
info Verified: 699 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaRemoveElmtContainedSizeSmaller' VC for lemmaRemoveElmtContainedSizeSmaller @996:28...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaRemoveElmtContainedSizeSmaller' VC for lemmaRemoveElmtContainedSizeSmaller @996:28...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaRemoveElmtContainedSizeSmaller' VC for lemmaRemoveElmtContainedSizeSmaller @996:28...
debug: !contains[B](l, e) || l.isInstanceOf[Cons] && l.h == e || !l.isInstanceOf[Cons] || contains[B](l.t, e)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaRemoveElmtContainedSizeSmaller' VC for lemmaRemoveElmtContainedSizeSmaller @996:28:
debug:  => VALID
info Verified: 700 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaRemoveElmtContainedSizeSmaller @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaRemoveElmtContainedSizeSmaller @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaRemoveElmtContainedSizeSmaller @?:?...
debug: !contains[B](l, e) || l.isInstanceOf[Cons] && l.h == e || !l.isInstanceOf[Cons] || !contains[B](l.t, e) || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaRemoveElmtContainedSizeSmaller @?:?:
debug:  => VALID
info Verified: 701 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @996:28...
debug: Cache miss: 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @996:28...
debug:  - Now solving 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @996:28...
debug: !contains[B](l, e) || l.isInstanceOf[Cons] && l.h == e || !l.isInstanceOf[Cons] || !contains[B](l.t, e) || {
  val bdg: Unit = lemmaRemoveElmtContainedSizeSmaller[B](l.t, e)
  assume(size[B](-[B](l.t, e)) < size[B](l.t))
  size[B](-[B](l, e)) < size[B](l)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @996:28:
debug:  => VALID
info Verified: 702 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of check' VC for lemmaRemoveElmtContainedSizeSmaller @997:28...
debug: Cache miss: 'body assertion: Inlined precondition of check' VC for lemmaRemoveElmtContainedSizeSmaller @997:28...
debug:  - Now solving 'body assertion: Inlined precondition of check' VC for lemmaRemoveElmtContainedSizeSmaller @997:28...
debug: !contains[B](l, e) || l.isInstanceOf[Cons] && l.h == e || l.isInstanceOf[Cons]
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of check' VC for lemmaRemoveElmtContainedSizeSmaller @997:28:
debug:  => VALID
info Verified: 703 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @997:28...
debug: Cache hit: 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @997:28...
info Verified: 704 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaRemoveElmtContainedSizeSmaller @989:5...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for lemmaRemoveElmtContainedSizeSmaller @989:5...
info Verified: 705 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @989:5...
debug: Cache hit: 'postcondition' VC for lemmaRemoveElmtContainedSizeSmaller @989:5...
info Verified: 706 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveOneElmtNotContainedSameLis...)' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @?:?...
debug: Cache miss: 'precond. (call lemmaRemoveOneElmtNotContainedSameLis...)' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @?:?...
debug:  - Now solving 'precond. (call lemmaRemoveOneElmtNotContainedSameLis...)' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @?:?...
debug: !noDuplicate[B](l) || !contains[B](l, b) || l.isInstanceOf[Nil] || l.h != b || {
  val bdg: Boolean = contains[B](l.t, b)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaRemoveOneElmtNotContainedSameLis...)' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @?:?:
debug:  => VALID
info Verified: 707 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 1/2))' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @?:?...
debug: Cache miss: 'precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 1/2))' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @?:?...
debug:  - Now solving 'precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 1/2))' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @?:?...
debug: !noDuplicate[B](l) || !contains[B](l, b) || l.isInstanceOf[Nil] || l.h == b || !noDuplicate[B](l.t) || {
  val bdg: Boolean = contains[B](l.t, b)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 1/2))' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @?:?:
debug:  => VALID
info Verified: 708 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 2/2))' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @?:?...
debug: Cache hit: 'precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 2/2))' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @?:?...
info Verified: 709 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1014:44...
debug: Cache miss: 'non-negative measure' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1014:44...
debug:  - Now solving 'non-negative measure' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1014:44...
debug: !noDuplicate[B](l) || !contains[B](l, b) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1014:44:
debug:  => VALID
info Verified: 710 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1009:39...
debug: Cache miss: 'postcondition' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1009:39...
debug:  - Now solving 'postcondition' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1009:39...
debug: !noDuplicate[B](l) || !contains[B](l, b) || !l.isInstanceOf[Nil] || isEmpty[B](l) || size[B](-[B](l, b)) == size[B](l) - BigInt("1")
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1009:39:
debug:  => VALID
info Verified: 711 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaRemoveOneElmtNotContainedSameList' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1010:39...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaRemoveOneElmtNotContainedSameList' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1010:39...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaRemoveOneElmtNotContainedSameList' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1010:39...
debug: !noDuplicate[B](l) || !contains[B](l, b) || l.isInstanceOf[Nil] || l.h != b || !contains[B](l.t, b)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaRemoveOneElmtNotContainedSameList' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1010:39:
debug:  => VALID
info Verified: 712 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1010:39...
debug: Cache miss: 'postcondition' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1010:39...
debug:  - Now solving 'postcondition' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1010:39...
debug: !noDuplicate[B](l) || !contains[B](l, b) || l.isInstanceOf[Nil] || l.h != b || contains[B](l.t, b) || {
  val bdg: Unit = lemmaRemoveOneElmtNotContainedSameList[B](l.t, b)
  assume(-[B](l.t, b) == l.t)
  isEmpty[B](l) || size[B](-[B](l, b)) == size[B](l) - BigInt("1")
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1010:39:
debug:  => VALID
info Verified: 713 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1011:39...
debug: Cache miss: 'body assertion: Inlined precondition (1/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1011:39...
debug:  - Now solving 'body assertion: Inlined precondition (1/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1011:39...
debug: !noDuplicate[B](l) || !contains[B](l, b) || l.isInstanceOf[Nil] || l.h == b || noDuplicate[B](l.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1011:39:
debug:  => VALID
info Verified: 714 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1011:39...
debug: Cache miss: 'body assertion: Inlined precondition (2/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1011:39...
debug:  - Now solving 'body assertion: Inlined precondition (2/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1011:39...
debug: !noDuplicate[B](l) || !contains[B](l, b) || l.isInstanceOf[Nil] || l.h == b || !noDuplicate[B](l.t) || contains[B](l.t, b)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1011:39:
debug:  => VALID
info Verified: 715 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @?:?...
debug: !noDuplicate[B](l) || !contains[B](l, b) || l.isInstanceOf[Nil] || l.h == b || !noDuplicate[B](l.t) || !contains[B](l.t, b) || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @?:?:
debug:  => VALID
info Verified: 716 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1011:39...
debug: Cache miss: 'postcondition' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1011:39...
debug:  - Now solving 'postcondition' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1011:39...
debug: !noDuplicate[B](l) || !contains[B](l, b) || l.isInstanceOf[Nil] || l.h == b || !noDuplicate[B](l.t) || !contains[B](l.t, b) || {
  val bdg: Unit = lemmaRemoveOneElmtNoDuplicateSizeMinusOne[B](l.t, b)
  assume(isEmpty[B](l.t) || size[B](-[B](l.t, b)) == size[B](l.t) - BigInt("1"))
  isEmpty[B](l) || size[B](-[B](l, b)) == size[B](l) - BigInt("1")
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1011:39:
debug:  => VALID
info Verified: 717 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1008:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1008:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1008:5...
debug: !noDuplicate[B](l) || {
  val bdg: Boolean = contains[B](l, b)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1008:5:
debug:  => VALID
info Verified: 718 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1008:5...
debug: Cache hit: 'postcondition' VC for lemmaRemoveOneElmtNoDuplicateSizeMinusOne @1008:5...
info Verified: 719 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveOneElmtNotContainedSameLis...)' VC for lemmaRemoveOneElmtNotContainedSameList @?:?...
debug: Cache hit: 'precond. (call lemmaRemoveOneElmtNotContainedSameLis...)' VC for lemmaRemoveOneElmtNotContainedSameList @?:?...
info Verified: 720 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaRemoveOneElmtNotContainedSameList @1105:57...
debug: Cache hit: 'non-negative measure' VC for lemmaRemoveOneElmtNotContainedSameList @1105:57...
info Verified: 721 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaRemoveOneElmtNotContainedSameList @?:?...
debug: Cache hit: 'measure decreases' VC for lemmaRemoveOneElmtNotContainedSameList @?:?...
info Verified: 722 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveOneElmtNotContainedSameList @?:?...
debug: Cache miss: 'postcondition' VC for lemmaRemoveOneElmtNotContainedSameList @?:?...
debug:  - Now solving 'postcondition' VC for lemmaRemoveOneElmtNotContainedSameList @?:?...
debug: contains[B](l, b) || !l.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaRemoveOneElmtNotContainedSameList[B](l.t, b)
  -[B](l, b) == l
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveOneElmtNotContainedSameList @?:?:
debug:  => VALID
info Verified: 723 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveOneElmtNotContainedSameList @?:?...
debug: Cache miss: 'postcondition' VC for lemmaRemoveOneElmtNotContainedSameList @?:?...
debug:  - Now solving 'postcondition' VC for lemmaRemoveOneElmtNotContainedSameList @?:?...
debug: contains[B](l, b) || l.isInstanceOf[Cons] || -[B](l, b) == l
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveOneElmtNotContainedSameList @?:?:
debug:  => VALID
info Verified: 724 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaRemoveOneElmtNotContainedSameList @?:?...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for lemmaRemoveOneElmtNotContainedSameList @?:?...
info Verified: 725 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveOneElmtNotContainedSameList @?:?...
debug: Cache hit: 'postcondition' VC for lemmaRemoveOneElmtNotContainedSameList @?:?...
info Verified: 726 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveOneElmtPreservesNoDuplicat...)' VC for lemmaRemoveOneElmtPreservesNoDuplicate @?:?...
debug: Cache miss: 'precond. (call lemmaRemoveOneElmtPreservesNoDuplicat...)' VC for lemmaRemoveOneElmtPreservesNoDuplicate @?:?...
debug:  - Now solving 'precond. (call lemmaRemoveOneElmtPreservesNoDuplicat...)' VC for lemmaRemoveOneElmtPreservesNoDuplicate @?:?...
debug: !noDuplicate[B](l) || !l.isInstanceOf[Cons] || noDuplicate[B](l.t)
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaRemoveOneElmtPreservesNoDuplicat...)' VC for lemmaRemoveOneElmtPreservesNoDuplicate @?:?:
debug:  => VALID
info Verified: 727 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaRemoveOneElmtPreservesNoDuplicate @1112:57...
debug: Cache miss: 'non-negative measure' VC for lemmaRemoveOneElmtPreservesNoDuplicate @1112:57...
debug:  - Now solving 'non-negative measure' VC for lemmaRemoveOneElmtPreservesNoDuplicate @1112:57...
debug: !noDuplicate[B](l) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaRemoveOneElmtPreservesNoDuplicate @1112:57:
debug:  => VALID
info Verified: 728 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaRemoveOneElmtPreservesNoDuplicate @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaRemoveOneElmtPreservesNoDuplicate @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaRemoveOneElmtPreservesNoDuplicate @?:?...
debug: !noDuplicate[B](l) || !l.isInstanceOf[Cons] || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaRemoveOneElmtPreservesNoDuplicate @?:?:
debug:  => VALID
info Verified: 729 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveOneElmtPreservesNoDuplicate @1115:15...
debug: Cache miss: 'postcondition' VC for lemmaRemoveOneElmtPreservesNoDuplicate @1115:15...
debug:  - Now solving 'postcondition' VC for lemmaRemoveOneElmtPreservesNoDuplicate @1115:15...
debug: !noDuplicate[B](l) || !l.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaRemoveOneElmtPreservesNoDuplicate[B](l.t, b)
  noDuplicate[B](-[B](l, b))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveOneElmtPreservesNoDuplicate @1115:15:
debug:  => VALID
info Verified: 730 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveOneElmtPreservesNoDuplicate @1115:15...
debug: Cache miss: 'postcondition' VC for lemmaRemoveOneElmtPreservesNoDuplicate @1115:15...
debug:  - Now solving 'postcondition' VC for lemmaRemoveOneElmtPreservesNoDuplicate @1115:15...
debug: !noDuplicate[B](l) || l.isInstanceOf[Cons] || noDuplicate[B](-[B](l, b))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveOneElmtPreservesNoDuplicate @1115:15:
debug:  => VALID
info Verified: 731 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaRemoveOneElmtPreservesNoDuplicate @?:?...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaRemoveOneElmtPreservesNoDuplicate @?:?...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaRemoveOneElmtPreservesNoDuplicate @?:?...
debug: val bdg: Boolean = noDuplicate[B](l)
true
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaRemoveOneElmtPreservesNoDuplicate @?:?:
debug:  => VALID
info Verified: 732 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveOneElmtPreservesNoDuplicate @1115:15...
debug: Cache hit: 'postcondition' VC for lemmaRemoveOneElmtPreservesNoDuplicate @1115:15...
info Verified: 733 / 982
debug:  - Checking cache: 'precond. (call head[B](l))' VC for lemmaContainsAndNotHdThenTlContains @182:13...
debug: Cache hit: 'precond. (call head[B](l))' VC for lemmaContainsAndNotHdThenTlContains @182:13...
info Verified: 734 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaContainsAndNotHdThenTlContains @184:15...
debug: Cache hit: 'precond. (call tail[B](l))' VC for lemmaContainsAndNotHdThenTlContains @184:15...
info Verified: 735 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaContainsAndNotHdThenTlContains @180:7...
debug: Cache miss: 'postcondition' VC for lemmaContainsAndNotHdThenTlContains @180:7...
debug:  - Now solving 'postcondition' VC for lemmaContainsAndNotHdThenTlContains @180:7...
debug: !contains[B](l, e) || head[B](l) == e || contains[B](tail[B](l), e)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaContainsAndNotHdThenTlContains @180:7:
debug:  => VALID
info Verified: 736 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfListBis @654:45...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfListBis @654:45...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfListBis @654:45...
debug: !l.isInstanceOf[Nil] || isEmpty[B](l) || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfListBis @654:45:
debug:  => VALID
info Verified: 737 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfListBis @654:45...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfListBis @654:45...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfListBis @654:45...
debug: l.isInstanceOf[Nil] || {
  val bdg: Unit = lemmaTailIsSubseqOfList[B](l.h, l.t)
  assume(subseq[B](l.t, Cons[B](l.h, l.t)))
  isEmpty[B](l) || l != Nil[B]()
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfListBis @654:45:
debug:  => VALID
info Verified: 738 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfListBis @654:45...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaTailIsSubseqOfListBis @654:45...
info Verified: 739 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaTailIsSubseqOfListBis @651:28...
debug: Cache miss: 'postcondition' VC for lemmaTailIsSubseqOfListBis @651:28...
debug:  - Now solving 'postcondition' VC for lemmaTailIsSubseqOfListBis @651:28...
debug: !l.isInstanceOf[Nil] || isEmpty[B](l) || subseq[B](tail[B](l), l)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaTailIsSubseqOfListBis @651:28:
debug:  => VALID
info Verified: 740 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaTailIsSubseqOfListBis @652:28...
debug: Cache miss: 'postcondition' VC for lemmaTailIsSubseqOfListBis @652:28...
debug:  - Now solving 'postcondition' VC for lemmaTailIsSubseqOfListBis @652:28...
debug: l.isInstanceOf[Nil] || {
  val bdg: Unit = lemmaTailIsSubseqOfList[B](l.h, l.t)
  assume(subseq[B](l.t, Cons[B](l.h, l.t)))
  isEmpty[B](l) || subseq[B](tail[B](l), l)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaTailIsSubseqOfListBis @652:28:
debug:  => VALID
info Verified: 741 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaTailIsSubseqOfListBis @650:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaTailIsSubseqOfListBis @650:5...
info Verified: 742 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaTailIsSubseqOfListBis @650:5...
debug: Cache miss: 'postcondition' VC for lemmaTailIsSubseqOfListBis @650:5...
info Verified: 743 / 982
debug:  - Checking cache: 'precond. (call subseqTail[B](l, l))' VC for lemmaTailIsSubseqOfList @640:9...
debug: Cache miss: 'precond. (call subseqTail[B](l, l))' VC for lemmaTailIsSubseqOfList @640:9...
debug:  - Now solving 'precond. (call subseqTail[B](l, l))' VC for lemmaTailIsSubseqOfList @640:9...
debug: l.isInstanceOf[Nil] || l.h != elmt || {
  val bdg: Unit = lemmaSubseqRefl[B](l)
  assume(subseq[B](l, l))
  !isEmpty[B](l)
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call subseqTail[B](l, l))' VC for lemmaTailIsSubseqOfList @640:9:
debug:  => VALID
info Verified: 744 / 982
debug:  - Checking cache: 'body assertion' VC for lemmaTailIsSubseqOfList @641:16...
debug: Cache miss: 'body assertion' VC for lemmaTailIsSubseqOfList @641:16...
debug:  - Now solving 'body assertion' VC for lemmaTailIsSubseqOfList @641:16...
debug: l.isInstanceOf[Nil] || l.h != elmt || {
  val bdg: Unit = lemmaSubseqRefl[B](l)
  assume(subseq[B](l, l))
  val bdg: Unit = subseqTail[B](l, l)
  subseq[B](l.t, l)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion' VC for lemmaTailIsSubseqOfList @641:16:
debug:  => VALID
info Verified: 745 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaTailIsSubseqOfList @637:21...
debug: Cache miss: 'postcondition' VC for lemmaTailIsSubseqOfList @637:21...
debug:  - Now solving 'postcondition' VC for lemmaTailIsSubseqOfList @637:21...
debug: !l.isInstanceOf[Nil] || subseq[B](l, Cons[B](elmt, l))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaTailIsSubseqOfList @637:21:
debug:  => VALID
info Verified: 746 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaTailIsSubseqOfList @641:9...
debug: Cache miss: 'postcondition' VC for lemmaTailIsSubseqOfList @641:9...
debug:  - Now solving 'postcondition' VC for lemmaTailIsSubseqOfList @641:9...
debug: l.isInstanceOf[Nil] || l.h != elmt || {
  val bdg: Unit = lemmaSubseqRefl[B](l)
  assume(subseq[B](l, l))
  val bdg: Unit = subseqTail[B](l, l)
  !subseq[B](l.t, l) || subseq[B](l, Cons[B](elmt, l))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaTailIsSubseqOfList @641:9:
debug:  => VALID
info Verified: 747 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaTailIsSubseqOfList @643:42...
debug: Cache miss: 'postcondition' VC for lemmaTailIsSubseqOfList @643:42...
debug:  - Now solving 'postcondition' VC for lemmaTailIsSubseqOfList @643:42...
debug: l.isInstanceOf[Nil] || l.h == elmt || {
  val bdg: Unit = lemmaSubseqRefl[B](l)
  assume(subseq[B](l, l))
  subseq[B](l, Cons[B](elmt, l))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaTailIsSubseqOfList @643:42:
debug:  => VALID
info Verified: 748 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaTailIsSubseqOfList @636:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaTailIsSubseqOfList @636:5...
info Verified: 749 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaTailIsSubseqOfList @636:5...
debug: Cache miss: 'postcondition' VC for lemmaTailIsSubseqOfList @636:5...
info Verified: 750 / 982
debug:  - Checking cache: 'non-negative measure' VC for consecutiveSubseq @61:49...
debug: Cache hit: 'non-negative measure' VC for consecutiveSubseq @61:49...
info Verified: 751 / 982
debug:  - Checking cache: 'measure decreases' VC for consecutiveSubseq @60:46...
debug: Cache miss: 'measure decreases' VC for consecutiveSubseq @60:46...
debug:  - Now solving 'measure decreases' VC for consecutiveSubseq @60:46...
debug: !lTot.isInstanceOf[Cons] || consecutiveSubseqAtHead[B](l1, lTot) || ListPrimitiveSize[B](lTot.t) < ListPrimitiveSize[B](lTot)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for consecutiveSubseq @60:46:
debug:  => VALID
info Verified: 752 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for consecutiveSubseq @58:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for consecutiveSubseq @58:5...
info Verified: 753 / 982
debug:  - Checking cache: 'non-negative measure' VC for consecutiveSubseqAtHead @67:6...
debug: Cache hit: 'non-negative measure' VC for consecutiveSubseqAtHead @67:6...
info Verified: 754 / 982
debug:  - Checking cache: 'measure decreases' VC for consecutiveSubseqAtHead @70:9...
debug: Cache miss: 'measure decreases' VC for consecutiveSubseqAtHead @70:9...
debug:  - Now solving 'measure decreases' VC for consecutiveSubseqAtHead @70:9...
debug: l1.isInstanceOf[Nil] || !lTot.isInstanceOf[Cons] || l1.h != lTot.h || ListPrimitiveSize[B](l1.t) < ListPrimitiveSize[B](l1)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for consecutiveSubseqAtHead @70:9:
debug:  => VALID
info Verified: 755 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @400:54...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @400:54...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @400:54...
debug: !isPrefix[B](p, l) || !p.isInstanceOf[Cons] || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @400:54:
debug:  => VALID
info Verified: 756 / 982
debug:  - Checking cache: 'precond. (call lemmaPrefixStaysPrefixWhenAddingToSuf...)' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @?:?...
debug: Cache miss: 'precond. (call lemmaPrefixStaysPrefixWhenAddingToSuf...)' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @?:?...
debug:  - Now solving 'precond. (call lemmaPrefixStaysPrefixWhenAddingToSuf...)' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @?:?...
debug: !isPrefix[B](p, l) || !p.isInstanceOf[Cons] || {
  val bdg: Boolean = isPrefix[B](p.t, tail[B](l))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaPrefixStaysPrefixWhenAddingToSuf...)' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @?:?:
debug:  => VALID
info Verified: 757 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @403:27...
debug: Cache hit: 'non-negative measure' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @403:27...
info Verified: 758 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaPrefixStaysPrefixWhenAddingToSuffix' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @400:9...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaPrefixStaysPrefixWhenAddingToSuffix' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @400:9...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaPrefixStaysPrefixWhenAddingToSuffix' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @400:9...
debug: !isPrefix[B](p, l) || !p.isInstanceOf[Cons] || isPrefix[B](p.t, tail[B](l))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaPrefixStaysPrefixWhenAddingToSuffix' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @400:9:
debug:  => VALID
info Verified: 759 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @?:?...
debug: !isPrefix[B](p, l) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p.t, bdg) || ListPrimitiveSize[B](bdg) < ListPrimitiveSize[B](l)
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @?:?:
debug:  => VALID
info Verified: 760 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @400:9...
debug: Cache miss: 'postcondition' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @400:9...
debug:  - Now solving 'postcondition' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @400:9...
debug: !isPrefix[B](p, l) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p.t, bdg) || {
    val bdg: Unit = lemmaPrefixStaysPrefixWhenAddingToSuffix[B](p.t, bdg, suffix)
    assume(isPrefix[B](p.t, ++[B](bdg, suffix)))
    isPrefix[B](p, ++[B](l, suffix))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @400:9:
debug:  => VALID
info Verified: 761 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @401:21...
debug: Cache miss: 'postcondition' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @401:21...
debug:  - Now solving 'postcondition' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @401:21...
debug: !isPrefix[B](p, l) || p.isInstanceOf[Cons] || isPrefix[B](p, ++[B](l, suffix))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @401:21:
debug:  => VALID
info Verified: 762 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @398:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @398:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @398:5...
debug: val bdg: Boolean = isPrefix[B](p, l)
true
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @398:5:
debug:  => VALID
info Verified: 763 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @398:5...
debug: Cache hit: 'postcondition' VC for lemmaPrefixStaysPrefixWhenAddingToSuffix @398:5...
info Verified: 764 / 982
debug:  - Checking cache: 'precond. (call lemmaForallThenDisjunction2[B]((scrut...)' VC for lemmaForallThenDisjunction2 @?:?...
debug: Cache miss: 'precond. (call lemmaForallThenDisjunction2[B]((scrut...)' VC for lemmaForallThenDisjunction2 @?:?...
debug:  - Now solving 'precond. (call lemmaForallThenDisjunction2[B]((scrut...)' VC for lemmaForallThenDisjunction2 @?:?...
debug: !forall[B](l, (b: B) => p(b)) || !l.isInstanceOf[Cons] || forall[B](l.t, (b: B) => p(b))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallThenDisjunction2[B]((scrut...)' VC for lemmaForallThenDisjunction2 @?:?:
debug:  => VALID
info Verified: 765 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallThenDisjunction2 @785:46...
debug: Cache miss: 'non-negative measure' VC for lemmaForallThenDisjunction2 @785:46...
debug:  - Now solving 'non-negative measure' VC for lemmaForallThenDisjunction2 @785:46...
debug: !forall[B](l, (b: B) => p(b)) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaForallThenDisjunction2 @785:46:
debug:  => VALID
info Verified: 766 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallThenDisjunction2 @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaForallThenDisjunction2 @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaForallThenDisjunction2 @?:?...
debug: !forall[B](l, (b: B) => p(b)) || !l.isInstanceOf[Cons] || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallThenDisjunction2 @?:?:
debug:  => VALID
info Verified: 767 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallThenDisjunction2 @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallThenDisjunction2 @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallThenDisjunction2 @?:?...
debug: !forall[B](l, (b: B) => p(b)) || !l.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaForallThenDisjunction2[B](l.t, p, q)
  forall[B](l, (b: B) => q(b) || p(b))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallThenDisjunction2 @?:?:
debug:  => VALID
info Verified: 768 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallThenDisjunction2 @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallThenDisjunction2 @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallThenDisjunction2 @?:?...
debug: !forall[B](l, (b: B) => p(b)) || l.isInstanceOf[Cons] || forall[B](l, (b: B) => q(b) || p(b))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallThenDisjunction2 @?:?:
debug:  => VALID
info Verified: 769 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallThenDisjunction2 @?:?...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaForallThenDisjunction2 @?:?...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaForallThenDisjunction2 @?:?...
debug: val bdg: Boolean = forall[B](l, (b: B) => p(b))
true
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaForallThenDisjunction2 @?:?:
debug:  => VALID
info Verified: 770 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallThenDisjunction2 @?:?...
debug: Cache hit: 'postcondition' VC for lemmaForallThenDisjunction2 @?:?...
info Verified: 771 / 982
debug:  - Checking cache: 'precond. (call head[B](l))' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @242:13...
debug: Cache miss: 'precond. (call head[B](l))' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @242:13...
debug:  - Now solving 'precond. (call head[B](l))' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @242:13...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](l))' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @242:13:
debug:  => VALID
info Verified: 772 / 982
debug:  - Checking cache: 'precond. (call getIndex[B](l, e1))' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @243:13...
debug: Cache hit: 'precond. (call getIndex[B](l, e1))' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @243:13...
info Verified: 773 / 982
debug:  - Checking cache: 'precond. (call getIndex[B](l, e2))' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @243:31...
debug: Cache hit: 'precond. (call getIndex[B](l, e2))' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @243:31...
info Verified: 774 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @245:15...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @245:15...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @245:15...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || head[B](l) != e1 || getIndex[B](l, e1) >= getIndex[B](l, e2) || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @245:15:
debug:  => VALID
info Verified: 775 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @235:7...
debug: Cache miss: 'postcondition' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @235:7...
debug:  - Now solving 'postcondition' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @235:7...
debug: !contains[B](l, e1) || !contains[B](l, e2) || e1 == e2 || head[B](l) != e1 || getIndex[B](l, e1) >= getIndex[B](l, e2) || contains[B](tail[B](l), e2)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaGetIndexBiggerAndHeadEqThenTailContains @235:7:
debug:  => VALID
info Verified: 776 / 982
debug:  - Checking cache: 'precond. (call getIndex[B]((scrut.t): @DropVCs , e))' VC for getIndex @51:43...
debug: Cache miss: 'precond. (call getIndex[B]((scrut.t): @DropVCs , e))' VC for getIndex @51:43...
debug:  - Now solving 'precond. (call getIndex[B]((scrut.t): @DropVCs , e))' VC for getIndex @51:43...
debug: !contains[B](l, e) || l.isInstanceOf[Cons] && l.h == e || !l.isInstanceOf[Cons] || l.h == e || contains[B](l.t, e)
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getIndex[B]((scrut.t): @DropVCs , e))' VC for getIndex @51:43:
debug:  => VALID
info Verified: 777 / 982
debug:  - Checking cache: 'non-negative measure' VC for getIndex @49:5...
debug: Cache hit: 'non-negative measure' VC for getIndex @49:5...
info Verified: 778 / 982
debug:  - Checking cache: 'postcondition' VC for getIndex @50:39...
debug: Cache hit: 'postcondition' VC for getIndex @50:39...
info Verified: 779 / 982
debug:  - Checking cache: 'measure decreases' VC for getIndex @51:43...
debug: Cache miss: 'measure decreases' VC for getIndex @51:43...
debug:  - Now solving 'measure decreases' VC for getIndex @51:43...
debug: !contains[B](l, e) || l.isInstanceOf[Cons] && l.h == e || !l.isInstanceOf[Cons] || l.h == e || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for getIndex @51:43:
debug:  => VALID
info Verified: 780 / 982
debug:  - Checking cache: 'postcondition' VC for getIndex @51:39...
debug: Cache miss: 'postcondition' VC for getIndex @51:39...
debug:  - Now solving 'postcondition' VC for getIndex @51:39...
debug: !contains[B](l, e) || l.isInstanceOf[Cons] && l.h == e || !l.isInstanceOf[Cons] || l.h == e || BigInt("1") + getIndex[B](l.t, e) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for getIndex @51:39:
debug:  => VALID
info Verified: 781 / 982
debug:  - Checking cache: 'postcondition' VC for getIndex @52:39...
debug: Cache miss: 'postcondition' VC for getIndex @52:39...
debug:  - Now solving 'postcondition' VC for getIndex @52:39...
debug: !contains[B](l, e) || l.isInstanceOf[Cons] && l.h == e || l.isInstanceOf[Cons] && l.h != e || !l.isInstanceOf[Nil]
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for getIndex @52:39:
debug:  => VALID
info Verified: 782 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for getIndex @49:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for getIndex @49:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for getIndex @49:5...
debug: !contains[B](l, e) || l.isInstanceOf[Cons] && l.h == e || l.isInstanceOf[Cons] && l.h != e || l.isInstanceOf[Nil]
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for getIndex @49:5:
debug:  => VALID
info Verified: 783 / 982
debug:  - Checking cache: 'postcondition' VC for getIndex @49:5...
debug: Cache miss: 'postcondition' VC for getIndex @49:5...
debug:  - Now solving 'postcondition' VC for getIndex @49:5...
debug: !contains[B](l, e) || l.isInstanceOf[Cons] && l.h == e || l.isInstanceOf[Cons] && l.h != e || l.isInstanceOf[Nil] || stainless.lang.error[BigInt]("match exhaustiveness") >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for getIndex @49:5:
debug:  => VALID
info Verified: 784 / 982
debug:  - Checking cache: 'precond. (call lemmaIsSuffixThenSubseq[B](l1, l2))' VC for lemmaIsSuffixThenSubseq @?:?...
debug: Cache hit: 'precond. (call lemmaIsSuffixThenSubseq[B](l1, l2))' VC for lemmaIsSuffixThenSubseq @?:?...
info Verified: 785 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaIsSuffixThenSubseq @99:15...
debug: Cache miss: 'non-negative measure' VC for lemmaIsSuffixThenSubseq @99:15...
debug:  - Now solving 'non-negative measure' VC for lemmaIsSuffixThenSubseq @99:15...
debug: !isSuffix[B](l1, l2) || size[B](l1) + size[B](l2) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaIsSuffixThenSubseq @99:15:
debug:  => VALID
info Verified: 786 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaIsSuffixThenSubseq' VC for lemmaIsSuffixThenSubseq @101:56...
debug: Cache hit: 'body assertion: Inlined precondition of lemmaIsSuffixThenSubseq' VC for lemmaIsSuffixThenSubseq @101:56...
info Verified: 787 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaIsSuffixThenSubseq @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaIsSuffixThenSubseq @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaIsSuffixThenSubseq @?:?...
debug: !isSuffix[B](l1, l2) || !l2.isInstanceOf[Cons] || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](l2)
  bdg >= bdg || !isSuffix[B](l1, l2.t) || bdg + size[B](l2.t) < bdg + bdg
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaIsSuffixThenSubseq @?:?:
debug:  => VALID
info Verified: 788 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsSuffixThenSubseq @101:56...
debug: Cache miss: 'postcondition' VC for lemmaIsSuffixThenSubseq @101:56...
debug:  - Now solving 'postcondition' VC for lemmaIsSuffixThenSubseq @101:56...
debug: !isSuffix[B](l1, l2) || !l2.isInstanceOf[Cons] || size[B](l1) >= size[B](l2) || !isSuffix[B](l1, l2.t) || {
  val bdg: Unit = lemmaIsSuffixThenSubseq[B](l1, l2.t)
  assume(subseq[B](l1, l2.t))
  subseq[B](l1, l2)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaIsSuffixThenSubseq @101:56:
debug:  => VALID
info Verified: 789 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsSuffixThenSubseq @102:56...
debug: Cache miss: 'postcondition' VC for lemmaIsSuffixThenSubseq @102:56...
debug:  - Now solving 'postcondition' VC for lemmaIsSuffixThenSubseq @102:56...
debug: !isSuffix[B](l1, l2) || l2.isInstanceOf[Cons] && size[B](l1) < size[B](l2) || l1 != l2 || {
  val bdg: Unit = lemmaSubseqRefl[B](l1)
  assume(subseq[B](l1, l1))
  subseq[B](l1, l2)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaIsSuffixThenSubseq @102:56:
debug:  => VALID
info Verified: 790 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsSuffixThenSubseq @103:56...
debug: Cache miss: 'postcondition' VC for lemmaIsSuffixThenSubseq @103:56...
debug:  - Now solving 'postcondition' VC for lemmaIsSuffixThenSubseq @103:56...
debug: !isSuffix[B](l1, l2) || l2.isInstanceOf[Cons] && size[B](l1) < size[B](l2) || l1 == l2 || subseq[B](l1, l2)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaIsSuffixThenSubseq @103:56:
debug:  => VALID
info Verified: 791 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 1/2))' VC for lemmaForallNotContainsForConcat @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 1/2))' VC for lemmaForallNotContainsForConcat @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 1/2))' VC for lemmaForallNotContainsForConcat @?:?...
debug: !forall[B](l, (b: B) => !contains[B](l12, b)) || l12 != ++[B](l1, l2) || !l.isInstanceOf[Cons] || forall[B](l.t, (b: B) => !contains[B](l12, b))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 1/2))' VC for lemmaForallNotContainsForConcat @?:?:
debug:  => VALID
info Verified: 792 / 982
debug:  - Checking cache: 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 2/2))' VC for lemmaForallNotContainsForConcat @?:?...
debug: Cache miss: 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 2/2))' VC for lemmaForallNotContainsForConcat @?:?...
debug:  - Now solving 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 2/2))' VC for lemmaForallNotContainsForConcat @?:?...
debug: !forall[B](l, (b: B) => !contains[B](l12, b)) || l12 != ++[B](l1, l2) || !l.isInstanceOf[Cons] || {
  val bdg: Boolean = forall[B](l.t, (b: B) => !contains[B](l12, b))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaForallNotContainsForConcat[B]((s... (require 2/2))' VC for lemmaForallNotContainsForConcat @?:?:
debug:  => VALID
info Verified: 793 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallNotContainsForConcat @933:50...
debug: Cache miss: 'non-negative measure' VC for lemmaForallNotContainsForConcat @933:50...
debug:  - Now solving 'non-negative measure' VC for lemmaForallNotContainsForConcat @933:50...
debug: !forall[B](l, (b: B) => !contains[B](l12, b)) || l12 != ++[B](l1, l2) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaForallNotContainsForConcat @933:50:
debug:  => VALID
info Verified: 794 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallNotContainsForConcat @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaForallNotContainsForConcat @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaForallNotContainsForConcat @?:?...
debug: !forall[B](l, (b: B) => !contains[B](l12, b)) || l12 != ++[B](l1, l2) || !l.isInstanceOf[Cons] || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallNotContainsForConcat @?:?:
debug:  => VALID
info Verified: 795 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
debug: !forall[B](l, (b: B) => !contains[B](l12, b)) || {
  val bdg: List[B] = ++[B](l1, l2)
  l12 != bdg || !l.isInstanceOf[Cons] || {
    val bdg: Unit = lemmaForallNotContainsForConcat[B](l.t, l12, l1, l2)
    forall[B](l, (b: B) => !contains[B](bdg, b))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallNotContainsForConcat @?:?:
debug:  => VALID
info Verified: 796 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
debug: !forall[B](l, (b: B) => !contains[B](l12, b)) || {
  val bdg: List[B] = ++[B](l1, l2)
  l12 != bdg || l.isInstanceOf[Cons] || forall[B](l, (b: B) => !contains[B](bdg, b))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallNotContainsForConcat @?:?:
debug:  => VALID
info Verified: 797 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsForConcat @?:?...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsForConcat @?:?...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsForConcat @?:?...
debug: !forall[B](l, (b: B) => !contains[B](l12, b)) || {
  val bdg: List[B] = ++[B](l1, l2)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaForallNotContainsForConcat @?:?:
debug:  => VALID
info Verified: 798 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
debug: Cache hit: 'postcondition' VC for lemmaForallNotContainsForConcat @?:?...
info Verified: 799 / 982
debug:  - Checking cache: 'precond. (call noDuplicateConcatListNotContainedPres... (require 1/3))' VC for noDuplicateConcatListNotContainedPreserves @?:?...
debug: Cache miss: 'precond. (call noDuplicateConcatListNotContainedPres... (require 1/3))' VC for noDuplicateConcatListNotContainedPreserves @?:?...
debug:  - Now solving 'precond. (call noDuplicateConcatListNotContainedPres... (require 1/3))' VC for noDuplicateConcatListNotContainedPreserves @?:?...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !lB.isInstanceOf[Cons] || !noDuplicate[B](lB.t) || {
  val bdg: Boolean = forall[B](lB.t, (b: B) => !contains[B](l, b))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call noDuplicateConcatListNotContainedPres... (require 1/3))' VC for noDuplicateConcatListNotContainedPreserves @?:?:
debug:  => VALID
info Verified: 800 / 982
debug:  - Checking cache: 'precond. (call noDuplicateConcatListNotContainedPres... (require 2/3))' VC for noDuplicateConcatListNotContainedPreserves @?:?...
debug: Cache hit: 'precond. (call noDuplicateConcatListNotContainedPres... (require 2/3))' VC for noDuplicateConcatListNotContainedPreserves @?:?...
info Verified: 801 / 982
debug:  - Checking cache: 'precond. (call noDuplicateConcatListNotContainedPres... (require 3/3))' VC for noDuplicateConcatListNotContainedPreserves @?:?...
debug: Cache miss: 'precond. (call noDuplicateConcatListNotContainedPres... (require 3/3))' VC for noDuplicateConcatListNotContainedPreserves @?:?...
debug:  - Now solving 'precond. (call noDuplicateConcatListNotContainedPres... (require 3/3))' VC for noDuplicateConcatListNotContainedPreserves @?:?...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !lB.isInstanceOf[Cons] || !noDuplicate[B](lB.t) || !forall[B](lB.t, (b: B) => !contains[B](l, b)) || forall[B](lB.t, (b: B) => !contains[B](l, b))
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call noDuplicateConcatListNotContainedPres... (require 3/3))' VC for noDuplicateConcatListNotContainedPreserves @?:?:
debug:  => VALID
info Verified: 802 / 982
debug:  - Checking cache: 'non-negative measure' VC for noDuplicateConcatListNotContainedPreserves @1037:35...
debug: Cache miss: 'non-negative measure' VC for noDuplicateConcatListNotContainedPreserves @1037:35...
debug:  - Now solving 'non-negative measure' VC for noDuplicateConcatListNotContainedPreserves @1037:35...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || ListPrimitiveSize[B](lB) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for noDuplicateConcatListNotContainedPreserves @1037:35:
debug:  => VALID
info Verified: 803 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/3) of noDuplicateConcatListNotContainedPreserves' VC for noDuplicateConcatListNotContainedPreserves @1033:28...
debug: Cache miss: 'body assertion: Inlined precondition (1/3) of noDuplicateConcatListNotContainedPreserves' VC for noDuplicateConcatListNotContainedPreserves @1033:28...
debug:  - Now solving 'body assertion: Inlined precondition (1/3) of noDuplicateConcatListNotContainedPreserves' VC for noDuplicateConcatListNotContainedPreserves @1033:28...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || {
  val bdg: Boolean = forall[B](lB, (b: B) => !contains[B](l, b))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/3) of noDuplicateConcatListNotContainedPreserves' VC for noDuplicateConcatListNotContainedPreserves @1033:28:
debug:  => VALID
info Verified: 804 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/3) of noDuplicateConcatListNotContainedPreserves' VC for noDuplicateConcatListNotContainedPreserves @1033:28...
debug: Cache miss: 'body assertion: Inlined precondition (2/3) of noDuplicateConcatListNotContainedPreserves' VC for noDuplicateConcatListNotContainedPreserves @1033:28...
debug:  - Now solving 'body assertion: Inlined precondition (2/3) of noDuplicateConcatListNotContainedPreserves' VC for noDuplicateConcatListNotContainedPreserves @1033:28...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !lB.isInstanceOf[Cons] || noDuplicate[B](lB.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/3) of noDuplicateConcatListNotContainedPreserves' VC for noDuplicateConcatListNotContainedPreserves @1033:28:
debug:  => VALID
info Verified: 805 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (3/3) of noDuplicateConcatListNotContainedPreserves' VC for noDuplicateConcatListNotContainedPreserves @1033:28...
debug: Cache miss: 'body assertion: Inlined precondition (3/3) of noDuplicateConcatListNotContainedPreserves' VC for noDuplicateConcatListNotContainedPreserves @1033:28...
debug:  - Now solving 'body assertion: Inlined precondition (3/3) of noDuplicateConcatListNotContainedPreserves' VC for noDuplicateConcatListNotContainedPreserves @1033:28...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !lB.isInstanceOf[Cons] || !noDuplicate[B](lB.t) || forall[B](lB.t, (b: B) => !contains[B](l, b))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (3/3) of noDuplicateConcatListNotContainedPreserves' VC for noDuplicateConcatListNotContainedPreserves @1033:28:
debug:  => VALID
info Verified: 806 / 982
debug:  - Checking cache: 'measure decreases' VC for noDuplicateConcatListNotContainedPreserves @?:?...
debug: Cache miss: 'measure decreases' VC for noDuplicateConcatListNotContainedPreserves @?:?...
debug:  - Now solving 'measure decreases' VC for noDuplicateConcatListNotContainedPreserves @?:?...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !lB.isInstanceOf[Cons] || !noDuplicate[B](lB.t) || !forall[B](lB.t, (b: B) => !contains[B](l, b)) || ListPrimitiveSize[B](lB.t) < ListPrimitiveSize[B](lB)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for noDuplicateConcatListNotContainedPreserves @?:?:
debug:  => VALID
info Verified: 807 / 982
debug:  - Checking cache: 'postcondition' VC for noDuplicateConcatListNotContainedPreserves @1033:28...
debug: Cache miss: 'postcondition' VC for noDuplicateConcatListNotContainedPreserves @1033:28...
debug:  - Now solving 'postcondition' VC for noDuplicateConcatListNotContainedPreserves @1033:28...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || !lB.isInstanceOf[Cons] || !noDuplicate[B](lB.t) || !forall[B](lB.t, (b: B) => !contains[B](l, b)) || {
  val bdg: Unit = noDuplicateConcatListNotContainedPreserves[B](l, lB.t)
  assume(noDuplicate[B](++[B](lB.t, l)))
  noDuplicate[B](++[B](lB, l))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for noDuplicateConcatListNotContainedPreserves @1033:28:
debug:  => VALID
info Verified: 808 / 982
debug:  - Checking cache: 'postcondition' VC for noDuplicateConcatListNotContainedPreserves @1034:28...
debug: Cache miss: 'postcondition' VC for noDuplicateConcatListNotContainedPreserves @1034:28...
debug:  - Now solving 'postcondition' VC for noDuplicateConcatListNotContainedPreserves @1034:28...
debug: !noDuplicate[B](l) || !noDuplicate[B](lB) || !forall[B](lB, (b: B) => !contains[B](l, b)) || lB.isInstanceOf[Cons] || noDuplicate[B](++[B](lB, l))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for noDuplicateConcatListNotContainedPreserves @1034:28:
debug:  => VALID
info Verified: 809 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for noDuplicateConcatListNotContainedPreserves @1032:5...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for noDuplicateConcatListNotContainedPreserves @1032:5...
info Verified: 810 / 982
debug:  - Checking cache: 'postcondition' VC for noDuplicateConcatListNotContainedPreserves @1032:5...
debug: Cache hit: 'postcondition' VC for noDuplicateConcatListNotContainedPreserves @1032:5...
info Verified: 811 / 982
debug:  - Checking cache: 'precond. (call tail[B](tot))' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @368:64...
debug: Cache miss: 'precond. (call tail[B](tot))' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @368:64...
debug:  - Now solving 'precond. (call tail[B](tot))' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @368:64...
debug: !isPrefix[B](++[B](l, Cons[B](elmt, Nil[B]())), tot) || !l.isInstanceOf[Cons] || tot != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](tot))' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @368:64:
debug:  => VALID
info Verified: 812 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveLastConcatenatedPrefixStil...)' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @?:?...
debug: Cache miss: 'precond. (call lemmaRemoveLastConcatenatedPrefixStil...)' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @?:?...
debug:  - Now solving 'precond. (call lemmaRemoveLastConcatenatedPrefixStil...)' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @?:?...
debug: val bdg: List[B] = Cons[B](elmt, Nil[B]())
!isPrefix[B](++[B](l, bdg), tot) || !l.isInstanceOf[Cons] || {
  val bdg: Boolean = isPrefix[B](++[B](l.t, bdg), tail[B](tot))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaRemoveLastConcatenatedPrefixStil...)' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @?:?:
debug:  => VALID
info Verified: 813 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @371:24...
debug: Cache miss: 'non-negative measure' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @371:24...
debug:  - Now solving 'non-negative measure' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @371:24...
debug: !isPrefix[B](++[B](l, Cons[B](elmt, Nil[B]())), tot) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @371:24:
debug:  => VALID
info Verified: 814 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaRemoveLastConcatenatedPrefixStillPrefix' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @368:9...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaRemoveLastConcatenatedPrefixStillPrefix' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @368:9...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaRemoveLastConcatenatedPrefixStillPrefix' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @368:9...
debug: val bdg: List[B] = Cons[B](elmt, Nil[B]())
!isPrefix[B](++[B](l, bdg), tot) || !l.isInstanceOf[Cons] || isPrefix[B](++[B](l.t, bdg), tail[B](tot))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaRemoveLastConcatenatedPrefixStillPrefix' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @368:9:
debug:  => VALID
info Verified: 815 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @?:?...
debug: val bdg: List[B] = Cons[B](elmt, Nil[B]())
!isPrefix[B](++[B](l, bdg), tot) || !l.isInstanceOf[Cons] || !isPrefix[B](++[B](l.t, bdg), tail[B](tot)) || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @?:?:
debug:  => VALID
info Verified: 816 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @368:9...
debug: Cache miss: 'postcondition' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @368:9...
debug:  - Now solving 'postcondition' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @368:9...
debug: val bdg: List[B] = Cons[B](elmt, Nil[B]())
!isPrefix[B](++[B](l, bdg), tot) || !l.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](tot)
  !isPrefix[B](++[B](l.t, bdg), bdg) || {
    val bdg: Unit = lemmaRemoveLastConcatenatedPrefixStillPrefix[B](l.t, elmt, bdg)
    assume(isPrefix[B](l.t, bdg))
    isPrefix[B](l, tot)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @368:9:
debug:  => VALID
info Verified: 817 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @369:21...
debug: Cache miss: 'postcondition' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @369:21...
debug:  - Now solving 'postcondition' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @369:21...
debug: !isPrefix[B](++[B](l, Cons[B](elmt, Nil[B]())), tot) || l.isInstanceOf[Cons] || isPrefix[B](l, tot)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @369:21:
debug:  => VALID
info Verified: 818 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @366:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @366:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @366:5...
debug: val bdg: Boolean = isPrefix[B](++[B](l, Cons[B](elmt, Nil[B]())), tot)
true
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @366:5:
debug:  => VALID
info Verified: 819 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @366:5...
debug: Cache hit: 'postcondition' VC for lemmaRemoveLastConcatenatedPrefixStillPrefix @366:5...
info Verified: 820 / 982
debug:  - Checking cache: 'precond. (call lemmaForallContainsPreservedRemoveElm...)' VC for lemmaForallContainsPreservedRemoveElmt @?:?...
debug: Cache hit: 'precond. (call lemmaForallContainsPreservedRemoveElm...)' VC for lemmaForallContainsPreservedRemoveElmt @?:?...
info Verified: 821 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallContainsPreservedRemoveElmt @894:57...
debug: Cache hit: 'non-negative measure' VC for lemmaForallContainsPreservedRemoveElmt @894:57...
info Verified: 822 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallContainsPreservedRemoveElmt @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaForallContainsPreservedRemoveElmt @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaForallContainsPreservedRemoveElmt @?:?...
debug: !forall[B](l, (b: B) => contains[B](lRef, b)) || !l.isInstanceOf[Cons] || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaForallContainsPreservedRemoveElmt @?:?:
debug:  => VALID
info Verified: 823 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsPreservedRemoveElmt @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsPreservedRemoveElmt @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsPreservedRemoveElmt @?:?...
debug: !forall[B](l, (b: B) => contains[B](lRef, b)) || !l.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaForallContainsPreservedRemoveElmt[B](l.t, lRef, b)
  forall[B](-[B](l, b), (b: B) => contains[B](lRef, b))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsPreservedRemoveElmt @?:?:
debug:  => VALID
info Verified: 824 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsPreservedRemoveElmt @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsPreservedRemoveElmt @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsPreservedRemoveElmt @?:?...
debug: !forall[B](l, (b: B) => contains[B](lRef, b)) || l.isInstanceOf[Cons] || forall[B](-[B](l, b), (b: B) => contains[B](lRef, b))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsPreservedRemoveElmt @?:?:
debug:  => VALID
info Verified: 825 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallContainsPreservedRemoveElmt @?:?...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for lemmaForallContainsPreservedRemoveElmt @?:?...
info Verified: 826 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsPreservedRemoveElmt @?:?...
debug: Cache hit: 'postcondition' VC for lemmaForallContainsPreservedRemoveElmt @?:?...
info Verified: 827 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaSubseqRefl @619:15...
debug: Cache hit: 'non-negative measure' VC for lemmaSubseqRefl @619:15...
info Verified: 828 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubseqRefl @621:28...
debug: Cache miss: 'postcondition' VC for lemmaSubseqRefl @621:28...
debug:  - Now solving 'postcondition' VC for lemmaSubseqRefl @621:28...
debug: !l.isInstanceOf[Nil] || subseq[B](l, l)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubseqRefl @621:28:
debug:  => VALID
info Verified: 829 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaSubseqRefl @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaSubseqRefl @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaSubseqRefl @?:?...
debug: l.isInstanceOf[Nil] || size[B](l.t) < size[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaSubseqRefl @?:?:
debug:  => VALID
info Verified: 830 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubseqRefl @622:28...
debug: Cache miss: 'postcondition' VC for lemmaSubseqRefl @622:28...
debug:  - Now solving 'postcondition' VC for lemmaSubseqRefl @622:28...
debug: l.isInstanceOf[Nil] || {
  val bdg: Unit = lemmaSubseqRefl[B](l.t)
  assume(subseq[B](l.t, l.t))
  subseq[B](l, l)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaSubseqRefl @622:28:
debug:  => VALID
info Verified: 831 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaSubseqRefl @620:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaSubseqRefl @620:5...
info Verified: 832 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaSubseqRefl @620:5...
debug: Cache miss: 'postcondition' VC for lemmaSubseqRefl @620:5...
info Verified: 833 / 982
debug:  - Checking cache: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromLMakesItPrefix @459:24...
debug: Cache miss: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromLMakesItPrefix @459:24...
info Verified: 834 / 982
debug:  - Checking cache: 'precond. (call lemmaRemoveLastFromLMakesItPrefix[B](l))' VC for lemmaRemoveLastFromLMakesItPrefix @?:?...
debug: Cache miss: 'precond. (call lemmaRemoveLastFromLMakesItPrefix[B](l))' VC for lemmaRemoveLastFromLMakesItPrefix @?:?...
info Verified: 835 / 982
debug:  - Checking cache: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromLMakesItPrefix @459:24...
debug: Cache miss: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromLMakesItPrefix @459:24...
debug:  - Now solving 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromLMakesItPrefix @459:24...
debug: isEmpty[B](l) || l.isInstanceOf[Cons] && l.t.isInstanceOf[Nil] || !l.isInstanceOf[Cons] || isEmpty[B](l.t) || {
  val bdg: Unit = lemmaRemoveLastFromLMakesItPrefix[B](l.t)
  assume(isPrefix[B](removeLast[B](l.t), l.t))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromLMakesItPrefix @459:24:
debug:  => VALID
info Verified: 836 / 982
debug:  - Checking cache: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromLMakesItPrefix @459:24...
debug: Cache miss: 'precond. (call removeLast[B](l))' VC for lemmaRemoveLastFromLMakesItPrefix @459:24...
info Verified: 837 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaRemoveLastFromLMakesItPrefix @459:39...
debug: Cache miss: 'non-negative measure' VC for lemmaRemoveLastFromLMakesItPrefix @459:39...
debug:  - Now solving 'non-negative measure' VC for lemmaRemoveLastFromLMakesItPrefix @459:39...
debug: isEmpty[B](l) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaRemoveLastFromLMakesItPrefix @459:39:
debug:  => VALID
info Verified: 838 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveLastFromLMakesItPrefix @455:31...
debug: Cache miss: 'postcondition' VC for lemmaRemoveLastFromLMakesItPrefix @455:31...
debug:  - Now solving 'postcondition' VC for lemmaRemoveLastFromLMakesItPrefix @455:31...
debug: isEmpty[B](l) || !l.isInstanceOf[Cons] || !l.t.isInstanceOf[Nil] || isPrefix[B](removeLast[B](l), l)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveLastFromLMakesItPrefix @455:31:
debug:  => VALID
info Verified: 839 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaRemoveLastFromLMakesItPrefix' VC for lemmaRemoveLastFromLMakesItPrefix @456:31...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaRemoveLastFromLMakesItPrefix' VC for lemmaRemoveLastFromLMakesItPrefix @456:31...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaRemoveLastFromLMakesItPrefix' VC for lemmaRemoveLastFromLMakesItPrefix @456:31...
debug: isEmpty[B](l) || l.isInstanceOf[Cons] && l.t.isInstanceOf[Nil] || !l.isInstanceOf[Cons] || !isEmpty[B](l.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaRemoveLastFromLMakesItPrefix' VC for lemmaRemoveLastFromLMakesItPrefix @456:31:
debug:  => VALID
info Verified: 840 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaRemoveLastFromLMakesItPrefix @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaRemoveLastFromLMakesItPrefix @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaRemoveLastFromLMakesItPrefix @?:?...
debug: isEmpty[B](l) || l.isInstanceOf[Cons] && l.t.isInstanceOf[Nil] || !l.isInstanceOf[Cons] || isEmpty[B](l.t) || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaRemoveLastFromLMakesItPrefix @?:?:
debug:  => VALID
info Verified: 841 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveLastFromLMakesItPrefix @456:31...
debug: Cache miss: 'postcondition' VC for lemmaRemoveLastFromLMakesItPrefix @456:31...
debug:  - Now solving 'postcondition' VC for lemmaRemoveLastFromLMakesItPrefix @456:31...
debug: isEmpty[B](l) || l.isInstanceOf[Cons] && l.t.isInstanceOf[Nil] || !l.isInstanceOf[Cons] || isEmpty[B](l.t) || {
  val bdg: Unit = lemmaRemoveLastFromLMakesItPrefix[B](l.t)
  assume(isPrefix[B](removeLast[B](l.t), l.t))
  isPrefix[B](removeLast[B](l), l)
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveLastFromLMakesItPrefix @456:31:
debug:  => VALID
info Verified: 842 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaRemoveLastFromLMakesItPrefix @454:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaRemoveLastFromLMakesItPrefix @454:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaRemoveLastFromLMakesItPrefix @454:5...
debug: isEmpty[B](l) || l.isInstanceOf[Cons] && l.t.isInstanceOf[Nil] || l.isInstanceOf[Cons]
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaRemoveLastFromLMakesItPrefix @454:5:
debug:  => VALID
info Verified: 843 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemoveLastFromLMakesItPrefix @454:5...
debug: Cache miss: 'postcondition' VC for lemmaRemoveLastFromLMakesItPrefix @454:5...
debug:  - Now solving 'postcondition' VC for lemmaRemoveLastFromLMakesItPrefix @454:5...
debug: isEmpty[B](l) || l.isInstanceOf[Cons] && l.t.isInstanceOf[Nil] || l.isInstanceOf[Cons] || isPrefix[B](removeLast[B](l), l)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemoveLastFromLMakesItPrefix @454:5:
debug:  => VALID
info Verified: 844 / 982
debug:  - Checking cache: 'precond. (call last[B](l))' VC for removeLast @26:34...
debug: Cache miss: 'precond. (call last[B](l))' VC for removeLast @26:34...
info Verified: 845 / 982
debug:  - Checking cache: 'precond. (call removeLast[B]((scrut.t): @DropVCs ))' VC for removeLast @23:40...
debug: Cache hit: 'precond. (call removeLast[B]((scrut.t): @DropVCs ))' VC for removeLast @23:40...
info Verified: 846 / 982
debug:  - Checking cache: 'precond. (call last[B](l))' VC for removeLast @26:34...
debug: Cache miss: 'precond. (call last[B](l))' VC for removeLast @26:34...
debug:  - Now solving 'precond. (call last[B](l))' VC for removeLast @26:34...
debug: isEmpty[B](l) || l.isInstanceOf[Cons] && l.t.isInstanceOf[Nil] || !l.isInstanceOf[Cons] || {
  val bdg: List[B] = removeLast[B](l.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call last[B](l))' VC for removeLast @26:34:
debug:  => VALID
info Verified: 847 / 982
debug:  - Checking cache: 'precond. (call last[B](l))' VC for removeLast @26:34...
debug: Cache miss: 'precond. (call last[B](l))' VC for removeLast @26:34...
info Verified: 848 / 982
debug:  - Checking cache: 'non-negative measure' VC for removeLast @26:45...
debug: Cache hit: 'non-negative measure' VC for removeLast @26:45...
info Verified: 849 / 982
debug:  - Checking cache: 'postcondition' VC for removeLast @22:31...
debug: Cache miss: 'postcondition' VC for removeLast @22:31...
debug:  - Now solving 'postcondition' VC for removeLast @22:31...
debug: isEmpty[B](l) || !l.isInstanceOf[Cons] || !l.t.isInstanceOf[Nil] || ++[B](Nil[B](), Cons[B](last[B](l), Nil[B]())) == l
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for removeLast @22:31:
debug:  => VALID
info Verified: 850 / 982
debug:  - Checking cache: 'measure decreases' VC for removeLast @23:40...
debug: Cache miss: 'measure decreases' VC for removeLast @23:40...
debug:  - Now solving 'measure decreases' VC for removeLast @23:40...
debug: isEmpty[B](l) || l.isInstanceOf[Cons] && l.t.isInstanceOf[Nil] || !l.isInstanceOf[Cons] || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for removeLast @23:40:
debug:  => VALID
info Verified: 851 / 982
debug:  - Checking cache: 'postcondition' VC for removeLast @23:31...
debug: Cache miss: 'postcondition' VC for removeLast @23:31...
debug:  - Now solving 'postcondition' VC for removeLast @23:31...
debug: isEmpty[B](l) || l.isInstanceOf[Cons] && l.t.isInstanceOf[Nil] || !l.isInstanceOf[Cons] || ++[B](Cons[B](l.h, removeLast[B](l.t)), Cons[B](last[B](l), Nil[B]())) == l
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for removeLast @23:31:
debug:  => VALID
info Verified: 852 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for removeLast @21:24...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for removeLast @21:24...
info Verified: 853 / 982
debug:  - Checking cache: 'postcondition' VC for removeLast @21:24...
debug: Cache miss: 'postcondition' VC for removeLast @21:24...
debug:  - Now solving 'postcondition' VC for removeLast @21:24...
debug: isEmpty[B](l) || l.isInstanceOf[Cons] && l.t.isInstanceOf[Nil] || l.isInstanceOf[Cons] || ++[B](stainless.lang.error[List[B]]("match exhaustiveness"), Cons[B](last[B](l), Nil[B]())) == l
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for removeLast @21:24:
debug:  => VALID
info Verified: 854 / 982
debug:  - Checking cache: 'precond. (call lemmaForallThenDisjunction1[B]((scrut...)' VC for lemmaForallThenDisjunction1 @?:?...
debug: Cache hit: 'precond. (call lemmaForallThenDisjunction1[B]((scrut...)' VC for lemmaForallThenDisjunction1 @?:?...
info Verified: 855 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaForallThenDisjunction1 @791:46...
debug: Cache hit: 'non-negative measure' VC for lemmaForallThenDisjunction1 @791:46...
info Verified: 856 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaForallThenDisjunction1 @?:?...
debug: Cache hit: 'measure decreases' VC for lemmaForallThenDisjunction1 @?:?...
info Verified: 857 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallThenDisjunction1 @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallThenDisjunction1 @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallThenDisjunction1 @?:?...
debug: !forall[B](l, (b: B) => p(b)) || !l.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaForallThenDisjunction1[B](l.t, p, q)
  forall[B](l, (b: B) => p(b) || q(b))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallThenDisjunction1 @?:?:
debug:  => VALID
info Verified: 858 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallThenDisjunction1 @?:?...
debug: Cache miss: 'postcondition' VC for lemmaForallThenDisjunction1 @?:?...
debug:  - Now solving 'postcondition' VC for lemmaForallThenDisjunction1 @?:?...
debug: !forall[B](l, (b: B) => p(b)) || l.isInstanceOf[Cons] || forall[B](l, (b: B) => p(b) || q(b))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallThenDisjunction1 @?:?:
debug:  => VALID
info Verified: 859 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaForallThenDisjunction1 @?:?...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for lemmaForallThenDisjunction1 @?:?...
info Verified: 860 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallThenDisjunction1 @?:?...
debug: Cache hit: 'postcondition' VC for lemmaForallThenDisjunction1 @?:?...
info Verified: 861 / 982
debug:  - Checking cache: 'precond. (call lemmaIsPrefixRefl[B](l1, l2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @?:?...
debug: Cache miss: 'precond. (call lemmaIsPrefixRefl[B](l1, l2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @?:?...
info Verified: 862 / 982
debug:  - Checking cache: 'precond. (call getSuffix[B](l, l) (require 1/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15...
debug: Cache miss: 'precond. (call getSuffix[B](l, l) (require 1/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15...
debug:  - Now solving 'precond. (call getSuffix[B](l, l) (require 1/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15...
debug: val bdg: Unit = lemmaIsPrefixRefl[B](l, l)
assume(isPrefix[B](l, l))
!l.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaGetSuffixOnListWithItSelfIsEmpty[B](l.t)
  assume(isEmpty[B](getSuffix[B](l.t, l.t)))
  val bdg: BigInt = size[B](l)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getSuffix[B](l, l) (require 1/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15:
debug:  => VALID
info Verified: 863 / 982
debug:  - Checking cache: 'precond. (call getSuffix[B](l, l) (require 2/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15...
debug: Cache hit: 'precond. (call getSuffix[B](l, l) (require 2/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15...
info Verified: 864 / 982
debug:  - Checking cache: 'precond. (call getSuffix[B](l, l) (require 1/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15...
debug: Cache miss: 'precond. (call getSuffix[B](l, l) (require 1/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15...
debug:  - Now solving 'precond. (call getSuffix[B](l, l) (require 1/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15...
debug: val bdg: Unit = lemmaIsPrefixRefl[B](l, l)
assume(isPrefix[B](l, l))
l.isInstanceOf[Cons] || {
  val bdg: BigInt = size[B](l)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getSuffix[B](l, l) (require 1/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15:
debug:  => VALID
info Verified: 865 / 982
debug:  - Checking cache: 'precond. (call getSuffix[B](l, l) (require 2/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15...
debug: Cache hit: 'precond. (call getSuffix[B](l, l) (require 2/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15...
info Verified: 866 / 982
debug:  - Checking cache: 'precond. (call getSuffix[B](l, l) (require 1/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15...
debug: Cache miss: 'precond. (call getSuffix[B](l, l) (require 1/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15...
debug:  - Now solving 'precond. (call getSuffix[B](l, l) (require 1/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15...
debug: val bdg: Unit = lemmaIsPrefixRefl[B](l, l)
assume(isPrefix[B](l, l))
true
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getSuffix[B](l, l) (require 1/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15:
debug:  => VALID
info Verified: 867 / 982
debug:  - Checking cache: 'precond. (call getSuffix[B](l, l) (require 2/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15...
debug: Cache hit: 'precond. (call getSuffix[B](l, l) (require 2/2))' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:15...
info Verified: 868 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:28...
debug: Cache hit: 'non-negative measure' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @520:28...
info Verified: 869 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaIsPrefixRefl' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @514:5...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaIsPrefixRefl' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @514:5...
info Verified: 870 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @?:?...
debug: val bdg: Unit = lemmaIsPrefixRefl[B](l, l)
assume(isPrefix[B](l, l))
!l.isInstanceOf[Cons] || ListPrimitiveSize[B](l.t) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @?:?:
debug:  => VALID
info Verified: 871 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @517:28...
debug: Cache miss: 'postcondition' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @517:28...
debug:  - Now solving 'postcondition' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @517:28...
debug: val bdg: Unit = lemmaIsPrefixRefl[B](l, l)
assume(isPrefix[B](l, l))
!l.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaGetSuffixOnListWithItSelfIsEmpty[B](l.t)
  assume(isEmpty[B](getSuffix[B](l.t, l.t)))
  isEmpty[B](getSuffix[B](l, l))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @517:28:
debug:  => VALID
info Verified: 872 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @518:28...
debug: Cache miss: 'postcondition' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @518:28...
debug:  - Now solving 'postcondition' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @518:28...
debug: val bdg: Unit = lemmaIsPrefixRefl[B](l, l)
assume(isPrefix[B](l, l))
l.isInstanceOf[Cons] || isEmpty[B](getSuffix[B](l, l))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @518:28:
debug:  => VALID
info Verified: 873 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @516:5...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @516:5...
info Verified: 874 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @516:5...
debug: Cache hit: 'postcondition' VC for lemmaGetSuffixOnListWithItSelfIsEmpty @516:5...
info Verified: 875 / 982
debug:  - Checking cache: 'precond. (call tail[B](l2))' VC for lemmaIsPrefixRefl @265:50...
debug: Cache miss: 'precond. (call tail[B](l2))' VC for lemmaIsPrefixRefl @265:50...
debug:  - Now solving 'precond. (call tail[B](l2))' VC for lemmaIsPrefixRefl @265:50...
debug: l1 != l2 || !l1.isInstanceOf[Cons] || l2 != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l2))' VC for lemmaIsPrefixRefl @265:50:
debug:  => VALID
info Verified: 876 / 982
debug:  - Checking cache: 'precond. (call lemmaIsPrefixRefl[B](l1, l2))' VC for lemmaIsPrefixRefl @?:?...
debug: Cache miss: 'precond. (call lemmaIsPrefixRefl[B](l1, l2))' VC for lemmaIsPrefixRefl @?:?...
info Verified: 877 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaIsPrefixRefl @?:?...
debug: Cache miss: 'non-negative measure' VC for lemmaIsPrefixRefl @?:?...
debug:  - Now solving 'non-negative measure' VC for lemmaIsPrefixRefl @?:?...
debug: l1 != l2 || {
  val bdg: BigInt = ListPrimitiveSize[B](l1)
  val bdg: BigInt = ListPrimitiveSize[B](l2)
  bdg >= BigInt("0") && bdg >= BigInt("0")
}
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaIsPrefixRefl @?:?:
debug:  => VALID
info Verified: 878 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaIsPrefixRefl' VC for lemmaIsPrefixRefl @265:28...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaIsPrefixRefl' VC for lemmaIsPrefixRefl @265:28...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaIsPrefixRefl' VC for lemmaIsPrefixRefl @265:28...
debug: l1 != l2 || !l1.isInstanceOf[Cons] || l1.t == tail[B](l2)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaIsPrefixRefl' VC for lemmaIsPrefixRefl @265:28:
debug:  => VALID
info Verified: 879 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaIsPrefixRefl @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaIsPrefixRefl @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaIsPrefixRefl @?:?...
debug: l1 != l2 || !l1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l2)
  l1.t != bdg || {
    val bdg: BigInt = ListPrimitiveSize[B](l1.t)
    val bdg: BigInt = ListPrimitiveSize[B](bdg)
    val bdg: BigInt = ListPrimitiveSize[B](l1)
    val bdg: BigInt = ListPrimitiveSize[B](l2)
    bdg < bdg || bdg == bdg && bdg < bdg
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaIsPrefixRefl @?:?:
debug:  => VALID
info Verified: 880 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsPrefixRefl @265:28...
debug: Cache miss: 'postcondition' VC for lemmaIsPrefixRefl @265:28...
debug:  - Now solving 'postcondition' VC for lemmaIsPrefixRefl @265:28...
debug: l1 != l2 || !l1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l2)
  l1.t != bdg || {
    val bdg: Unit = lemmaIsPrefixRefl[B](l1.t, bdg)
    assume(isPrefix[B](l1.t, bdg))
    isPrefix[B](l1, l2)
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaIsPrefixRefl @265:28:
debug:  => VALID
info Verified: 881 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsPrefixRefl @266:28...
debug: Cache miss: 'postcondition' VC for lemmaIsPrefixRefl @266:28...
debug:  - Now solving 'postcondition' VC for lemmaIsPrefixRefl @266:28...
debug: l1 != l2 || l1.isInstanceOf[Cons] || isPrefix[B](l1, l2)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaIsPrefixRefl @266:28:
debug:  => VALID
info Verified: 882 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaIsPrefixRefl @264:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaIsPrefixRefl @264:5...
info Verified: 883 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsPrefixRefl @264:5...
debug: Cache miss: 'postcondition' VC for lemmaIsPrefixRefl @264:5...
info Verified: 884 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for getSuffix @41:38...
debug: Cache miss: 'precond. (call tail[B](l))' VC for getSuffix @41:38...
debug:  - Now solving 'precond. (call tail[B](l))' VC for getSuffix @41:38...
debug: size[B](l) < size[B](p) || !isPrefix[B](p, l) || !p.isInstanceOf[Cons] || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for getSuffix @41:38:
debug:  => VALID
info Verified: 885 / 982
debug:  - Checking cache: 'precond. (call getSuffix[B](tail[B](l), (scrut.t): @... (require 1/2))' VC for getSuffix @41:28...
debug: Cache miss: 'precond. (call getSuffix[B](tail[B](l), (scrut.t): @... (require 1/2))' VC for getSuffix @41:28...
debug:  - Now solving 'precond. (call getSuffix[B](tail[B](l), (scrut.t): @... (require 1/2))' VC for getSuffix @41:28...
debug: size[B](l) < size[B](p) || !isPrefix[B](p, l) || !p.isInstanceOf[Cons] || size[B](tail[B](l)) >= size[B](p.t)
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getSuffix[B](tail[B](l), (scrut.t): @... (require 1/2))' VC for getSuffix @41:28:
debug:  => VALID
info Verified: 886 / 982
debug:  - Checking cache: 'precond. (call getSuffix[B](tail[B](l), (scrut.t): @... (require 2/2))' VC for getSuffix @41:28...
debug: Cache miss: 'precond. (call getSuffix[B](tail[B](l), (scrut.t): @... (require 2/2))' VC for getSuffix @41:28...
debug:  - Now solving 'precond. (call getSuffix[B](tail[B](l), (scrut.t): @... (require 2/2))' VC for getSuffix @41:28...
debug: size[B](l) < size[B](p) || !isPrefix[B](p, l) || !p.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  size[B](bdg) < size[B](p.t) || isPrefix[B](p.t, bdg)
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getSuffix[B](tail[B](l), (scrut.t): @... (require 2/2))' VC for getSuffix @41:28:
debug:  => VALID
info Verified: 887 / 982
debug:  - Checking cache: 'non-negative measure' VC for getSuffix @44:34...
debug: Cache miss: 'non-negative measure' VC for getSuffix @44:34...
debug:  - Now solving 'non-negative measure' VC for getSuffix @44:34...
debug: size[B](l) < size[B](p) || !isPrefix[B](p, l) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for getSuffix @44:34:
debug:  => VALID
info Verified: 888 / 982
debug:  - Checking cache: 'measure decreases' VC for getSuffix @41:28...
debug: Cache miss: 'measure decreases' VC for getSuffix @41:28...
debug:  - Now solving 'measure decreases' VC for getSuffix @41:28...
debug: size[B](l) < size[B](p) || !isPrefix[B](p, l) || !p.isInstanceOf[Cons] || ListPrimitiveSize[B](tail[B](l)) < ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for getSuffix @41:28:
debug:  => VALID
info Verified: 889 / 982
debug:  - Checking cache: 'postcondition' VC for getSuffix @41:28...
debug: Cache miss: 'postcondition' VC for getSuffix @41:28...
debug:  - Now solving 'postcondition' VC for getSuffix @41:28...
debug: size[B](l) < size[B](p) || !isPrefix[B](p, l) || !p.isInstanceOf[Cons] || ++[B](p, getSuffix[B](tail[B](l), p.t)) == l
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for getSuffix @41:28:
debug:  => VALID
info Verified: 890 / 982
debug:  - Checking cache: 'postcondition' VC for getSuffix @44:34...
debug: Cache miss: 'postcondition' VC for getSuffix @44:34...
debug:  - Now solving 'postcondition' VC for getSuffix @44:34...
debug: size[B](l) < size[B](p) || !isPrefix[B](p, l) || p.isInstanceOf[Cons] || ++[B](p, l) == l
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for getSuffix @44:34:
debug:  => VALID
info Verified: 891 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for getSuffix @40:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for getSuffix @40:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for getSuffix @40:5...
debug: size[B](l) < size[B](p) || {
  val bdg: Boolean = isPrefix[B](p, l)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for getSuffix @40:5:
debug:  => VALID
info Verified: 892 / 982
debug:  - Checking cache: 'postcondition' VC for getSuffix @40:5...
debug: Cache hit: 'postcondition' VC for getSuffix @40:5...
info Verified: 893 / 982
debug:  - Checking cache: 'precond. (call tail[B](p2))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @301:11...
debug: Cache miss: 'precond. (call tail[B](p2))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @301:11...
debug:  - Now solving 'precond. (call tail[B](p2))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @301:11...
debug: !isPrefix[B](p2, l) || {
  val bdg: List[B] = ++[B](p1, s1)
  bdg != l || isEmpty[B](s1) || size[B](p1) >= size[B](p2) || {
    val bdg: Unit = lemmaConcatTwoListThenFirstIsPrefix[B](p1, s1)
    assume(isPrefix[B](p1, bdg))
    !p1.isInstanceOf[Cons] || p2 != Nil[B]()
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](p2))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @301:11:
debug:  => VALID
info Verified: 894 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @302:11...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @302:11...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @302:11...
debug: !isPrefix[B](p2, l) || {
  val bdg: List[B] = ++[B](p1, s1)
  bdg != l || isEmpty[B](s1) || size[B](p1) >= size[B](p2) || {
    val bdg: Unit = lemmaConcatTwoListThenFirstIsPrefix[B](p1, s1)
    assume(isPrefix[B](p1, bdg))
    !p1.isInstanceOf[Cons] || l != Nil[B]()
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @302:11:
debug:  => VALID
info Verified: 895 / 982
debug:  - Checking cache: 'precond. (call lemmaLongerPrefixContainsHeadOfSuffix... (require 1/4))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @?:?...
debug: Cache miss: 'precond. (call lemmaLongerPrefixContainsHeadOfSuffix... (require 1/4))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @?:?...
debug:  - Now solving 'precond. (call lemmaLongerPrefixContainsHeadOfSuffix... (require 1/4))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @?:?...
debug: !isPrefix[B](p2, l) || {
  val bdg: List[B] = ++[B](p1, s1)
  bdg != l || isEmpty[B](s1) || size[B](p1) >= size[B](p2) || {
    val bdg: Unit = lemmaConcatTwoListThenFirstIsPrefix[B](p1, s1)
    assume(isPrefix[B](p1, bdg))
    !p1.isInstanceOf[Cons] || {
      val bdg: List[B] = tail[B](p2)
      val bdg: List[B] = tail[B](l)
      !isPrefix[B](bdg, bdg) || ++[B](p1.t, s1) != bdg || {
        val bdg: BigInt = size[B](p1.t)
        val bdg: BigInt = size[B](bdg)
        true
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaLongerPrefixContainsHeadOfSuffix... (require 1/4))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @?:?:
debug:  => VALID
info Verified: 896 / 982
debug:  - Checking cache: 'precond. (call lemmaLongerPrefixContainsHeadOfSuffix... (require 2/4))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @?:?...
debug: Cache hit: 'precond. (call lemmaLongerPrefixContainsHeadOfSuffix... (require 2/4))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @?:?...
info Verified: 897 / 982
debug:  - Checking cache: 'precond. (call lemmaLongerPrefixContainsHeadOfSuffix... (require 3/4))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @?:?...
debug: Cache hit: 'precond. (call lemmaLongerPrefixContainsHeadOfSuffix... (require 3/4))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @?:?...
info Verified: 898 / 982
debug:  - Checking cache: 'precond. (call lemmaLongerPrefixContainsHeadOfSuffix... (require 4/4))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @?:?...
debug: Cache hit: 'precond. (call lemmaLongerPrefixContainsHeadOfSuffix... (require 4/4))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @?:?...
info Verified: 899 / 982
debug:  - Checking cache: 'precond. (call head[B](s1))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @306:27...
debug: Cache miss: 'precond. (call head[B](s1))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @306:27...
debug:  - Now solving 'precond. (call head[B](s1))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @306:27...
debug: !isPrefix[B](p2, l) || {
  val bdg: List[B] = ++[B](p1, s1)
  bdg != l || isEmpty[B](s1) || size[B](p1) >= size[B](p2) || {
    val bdg: Unit = lemmaConcatTwoListThenFirstIsPrefix[B](p1, s1)
    assume(isPrefix[B](p1, bdg))
    !p1.isInstanceOf[Cons] || {
      val bdg: List[B] = tail[B](p2)
      val bdg: List[B] = tail[B](l)
      !isPrefix[B](bdg, bdg) || ++[B](p1.t, s1) != bdg || size[B](p1.t) >= size[B](bdg) || {
        val bdg: Unit = lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref[B](p1.t, s1, bdg, bdg)
        assume(contains[B](bdg, head[B](s1)))
        s1 != Nil[B]()
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](s1))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @306:27:
debug:  => VALID
info Verified: 900 / 982
debug:  - Checking cache: 'precond. (call head[B](s1))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @306:27...
debug: Cache miss: 'precond. (call head[B](s1))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @306:27...
debug:  - Now solving 'precond. (call head[B](s1))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @306:27...
debug: !isPrefix[B](p2, l) || {
  val bdg: List[B] = ++[B](p1, s1)
  bdg != l || isEmpty[B](s1) || size[B](p1) >= size[B](p2) || {
    val bdg: Unit = lemmaConcatTwoListThenFirstIsPrefix[B](p1, s1)
    assume(isPrefix[B](p1, bdg))
    p1.isInstanceOf[Cons] || s1 != Nil[B]()
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](s1))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @306:27:
debug:  => VALID
info Verified: 901 / 982
debug:  - Checking cache: 'precond. (call head[B](s1))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @306:27...
debug: Cache miss: 'precond. (call head[B](s1))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @306:27...
debug:  - Now solving 'precond. (call head[B](s1))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @306:27...
debug: !isPrefix[B](p2, l) || {
  val bdg: List[B] = ++[B](p1, s1)
  bdg != l || isEmpty[B](s1) || size[B](p1) >= size[B](p2) || {
    val bdg: Unit = lemmaConcatTwoListThenFirstIsPrefix[B](p1, s1)
    assume(isPrefix[B](p1, bdg))
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](s1))' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @306:27:
debug:  => VALID
info Verified: 902 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @302:11...
debug: Cache miss: 'non-negative measure' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @302:11...
debug:  - Now solving 'non-negative measure' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @302:11...
debug: !isPrefix[B](p2, l) || ++[B](p1, s1) != l || isEmpty[B](s1) || size[B](p1) >= size[B](p2) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @302:11:
debug:  => VALID
info Verified: 903 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9...
debug: !isPrefix[B](p2, l) || {
  val bdg: List[B] = ++[B](p1, s1)
  bdg != l || isEmpty[B](s1) || size[B](p1) >= size[B](p2) || {
    val bdg: Unit = lemmaConcatTwoListThenFirstIsPrefix[B](p1, s1)
    assume(isPrefix[B](p1, bdg))
    !p1.isInstanceOf[Cons] || isPrefix[B](tail[B](p2), tail[B](l))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9:
debug:  => VALID
info Verified: 904 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9...
debug: !isPrefix[B](p2, l) || {
  val bdg: List[B] = ++[B](p1, s1)
  bdg != l || isEmpty[B](s1) || size[B](p1) >= size[B](p2) || {
    val bdg: Unit = lemmaConcatTwoListThenFirstIsPrefix[B](p1, s1)
    assume(isPrefix[B](p1, bdg))
    !p1.isInstanceOf[Cons] || {
      val bdg: List[B] = tail[B](l)
      !isPrefix[B](tail[B](p2), bdg) || ++[B](p1.t, s1) == bdg
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9:
debug:  => VALID
info Verified: 905 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (3/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9...
debug: Cache miss: 'body assertion: Inlined precondition (3/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9...
debug:  - Now solving 'body assertion: Inlined precondition (3/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9...
debug: !isPrefix[B](p2, l) || {
  val bdg: List[B] = ++[B](p1, s1)
  bdg != l || isEmpty[B](s1) || size[B](p1) >= size[B](p2) || {
    val bdg: Unit = lemmaConcatTwoListThenFirstIsPrefix[B](p1, s1)
    assume(isPrefix[B](p1, bdg))
    !p1.isInstanceOf[Cons] || !isPrefix[B](tail[B](p2), tail[B](l)) || {
      val bdg: List[B] = ++[B](p1.t, s1)
      true
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (3/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9:
debug:  => VALID
info Verified: 906 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (4/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9...
debug: Cache miss: 'body assertion: Inlined precondition (4/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9...
debug:  - Now solving 'body assertion: Inlined precondition (4/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9...
debug: !isPrefix[B](p2, l) || {
  val bdg: List[B] = ++[B](p1, s1)
  bdg != l || isEmpty[B](s1) || size[B](p1) >= size[B](p2) || {
    val bdg: Unit = lemmaConcatTwoListThenFirstIsPrefix[B](p1, s1)
    assume(isPrefix[B](p1, bdg))
    !p1.isInstanceOf[Cons] || {
      val bdg: List[B] = tail[B](p2)
      val bdg: List[B] = tail[B](l)
      !isPrefix[B](bdg, bdg) || ++[B](p1.t, s1) != bdg || size[B](p1.t) < size[B](bdg)
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (4/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9:
debug:  => VALID
info Verified: 907 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @?:?...
debug: !isPrefix[B](p2, l) || {
  val bdg: List[B] = ++[B](p1, s1)
  bdg != l || isEmpty[B](s1) || size[B](p1) >= size[B](p2) || {
    val bdg: Unit = lemmaConcatTwoListThenFirstIsPrefix[B](p1, s1)
    assume(isPrefix[B](p1, bdg))
    !p1.isInstanceOf[Cons] || {
      val bdg: List[B] = tail[B](p2)
      val bdg: List[B] = tail[B](l)
      !isPrefix[B](bdg, bdg) || ++[B](p1.t, s1) != bdg || size[B](p1.t) >= size[B](bdg) || ListPrimitiveSize[B](bdg) < ListPrimitiveSize[B](l)
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @?:?:
debug:  => VALID
info Verified: 908 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9...
debug: Cache miss: 'postcondition' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9...
debug:  - Now solving 'postcondition' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9...
debug: !isPrefix[B](p2, l) || {
  val bdg: List[B] = ++[B](p1, s1)
  bdg != l || isEmpty[B](s1) || size[B](p1) >= size[B](p2) || {
    val bdg: Unit = lemmaConcatTwoListThenFirstIsPrefix[B](p1, s1)
    assume(isPrefix[B](p1, bdg))
    !p1.isInstanceOf[Cons] || {
      val bdg: List[B] = tail[B](p2)
      val bdg: List[B] = tail[B](l)
      !isPrefix[B](bdg, bdg) || ++[B](p1.t, s1) != bdg || size[B](p1.t) >= size[B](bdg) || {
        val bdg: Unit = lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref[B](p1.t, s1, bdg, bdg)
        val bdg: B = head[B](s1)
        assume(contains[B](bdg, bdg))
        contains[B](p2, bdg)
      }
    }
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @298:9:
debug:  => VALID
info Verified: 909 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @304:21...
debug: Cache miss: 'postcondition' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @304:21...
debug:  - Now solving 'postcondition' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @304:21...
debug: !isPrefix[B](p2, l) || {
  val bdg: List[B] = ++[B](p1, s1)
  bdg != l || isEmpty[B](s1) || size[B](p1) >= size[B](p2) || {
    val bdg: Unit = lemmaConcatTwoListThenFirstIsPrefix[B](p1, s1)
    assume(isPrefix[B](p1, bdg))
    p1.isInstanceOf[Cons] || contains[B](p2, head[B](s1))
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @304:21:
debug:  => VALID
info Verified: 910 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @296:5...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @296:5...
info Verified: 911 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @296:5...
debug: Cache hit: 'postcondition' VC for lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref @296:5...
info Verified: 912 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaConcatTwoListThenFirstIsPrefix @278:28...
debug: Cache hit: 'non-negative measure' VC for lemmaConcatTwoListThenFirstIsPrefix @278:28...
info Verified: 913 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaConcatTwoListThenFirstIsPrefix @?:?...
debug: Cache hit: 'measure decreases' VC for lemmaConcatTwoListThenFirstIsPrefix @?:?...
info Verified: 914 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatTwoListThenFirstIsPrefix @275:28...
debug: Cache miss: 'postcondition' VC for lemmaConcatTwoListThenFirstIsPrefix @275:28...
debug:  - Now solving 'postcondition' VC for lemmaConcatTwoListThenFirstIsPrefix @275:28...
debug: !l1.isInstanceOf[Cons] || {
  val bdg: Unit = lemmaConcatTwoListThenFirstIsPrefix[B](l1.t, l2)
  assume(isPrefix[B](l1.t, ++[B](l1.t, l2)))
  isPrefix[B](l1, ++[B](l1, l2))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaConcatTwoListThenFirstIsPrefix @275:28:
debug:  => VALID
info Verified: 915 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatTwoListThenFirstIsPrefix @276:28...
debug: Cache miss: 'postcondition' VC for lemmaConcatTwoListThenFirstIsPrefix @276:28...
debug:  - Now solving 'postcondition' VC for lemmaConcatTwoListThenFirstIsPrefix @276:28...
debug: l1.isInstanceOf[Cons] || isPrefix[B](l1, ++[B](l1, l2))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaConcatTwoListThenFirstIsPrefix @276:28:
debug:  => VALID
info Verified: 916 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaConcatTwoListThenFirstIsPrefix @274:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaConcatTwoListThenFirstIsPrefix @274:5...
info Verified: 917 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaConcatTwoListThenFirstIsPrefix @274:5...
debug: Cache miss: 'postcondition' VC for lemmaConcatTwoListThenFirstIsPrefix @274:5...
info Verified: 918 / 982
debug:  - Checking cache: 'precond. (call tail[B](p2))' VC for lemmaIsPrefixSameLengthThenSameList @425:49...
debug: Cache miss: 'precond. (call tail[B](p2))' VC for lemmaIsPrefixSameLengthThenSameList @425:49...
debug:  - Now solving 'precond. (call tail[B](p2))' VC for lemmaIsPrefixSameLengthThenSameList @425:49...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || size[B](p1) != size[B](p2) || !p1.isInstanceOf[Cons] || p2 != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](p2))' VC for lemmaIsPrefixSameLengthThenSameList @425:49:
debug:  => VALID
info Verified: 919 / 982
debug:  - Checking cache: 'precond. (call tail[B](l))' VC for lemmaIsPrefixSameLengthThenSameList @425:58...
debug: Cache miss: 'precond. (call tail[B](l))' VC for lemmaIsPrefixSameLengthThenSameList @425:58...
debug:  - Now solving 'precond. (call tail[B](l))' VC for lemmaIsPrefixSameLengthThenSameList @425:58...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || size[B](p1) != size[B](p2) || !p1.isInstanceOf[Cons] || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](l))' VC for lemmaIsPrefixSameLengthThenSameList @425:58:
debug:  => VALID
info Verified: 920 / 982
debug:  - Checking cache: 'precond. (call lemmaIsPrefixSameLengthThenSameList[B... (require 1/3))' VC for lemmaIsPrefixSameLengthThenSameList @?:?...
debug: Cache miss: 'precond. (call lemmaIsPrefixSameLengthThenSameList[B... (require 1/3))' VC for lemmaIsPrefixSameLengthThenSameList @?:?...
debug:  - Now solving 'precond. (call lemmaIsPrefixSameLengthThenSameList[B... (require 1/3))' VC for lemmaIsPrefixSameLengthThenSameList @?:?...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || size[B](p1) != size[B](p2) || !p1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](p2)
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p1.t, bdg) || !isPrefix[B](bdg, bdg) || {
    val bdg: BigInt = size[B](p1.t)
    val bdg: BigInt = size[B](bdg)
    true
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaIsPrefixSameLengthThenSameList[B... (require 1/3))' VC for lemmaIsPrefixSameLengthThenSameList @?:?:
debug:  => VALID
info Verified: 921 / 982
debug:  - Checking cache: 'precond. (call lemmaIsPrefixSameLengthThenSameList[B... (require 2/3))' VC for lemmaIsPrefixSameLengthThenSameList @?:?...
debug: Cache hit: 'precond. (call lemmaIsPrefixSameLengthThenSameList[B... (require 2/3))' VC for lemmaIsPrefixSameLengthThenSameList @?:?...
info Verified: 922 / 982
debug:  - Checking cache: 'precond. (call lemmaIsPrefixSameLengthThenSameList[B... (require 3/3))' VC for lemmaIsPrefixSameLengthThenSameList @?:?...
debug: Cache hit: 'precond. (call lemmaIsPrefixSameLengthThenSameList[B... (require 3/3))' VC for lemmaIsPrefixSameLengthThenSameList @?:?...
info Verified: 923 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaIsPrefixSameLengthThenSameList @425:58...
debug: Cache miss: 'non-negative measure' VC for lemmaIsPrefixSameLengthThenSameList @425:58...
debug:  - Now solving 'non-negative measure' VC for lemmaIsPrefixSameLengthThenSameList @425:58...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || size[B](p1) != size[B](p2) || ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaIsPrefixSameLengthThenSameList @425:58:
debug:  => VALID
info Verified: 924 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (1/3) of lemmaIsPrefixSameLengthThenSameList' VC for lemmaIsPrefixSameLengthThenSameList @425:9...
debug: Cache miss: 'body assertion: Inlined precondition (1/3) of lemmaIsPrefixSameLengthThenSameList' VC for lemmaIsPrefixSameLengthThenSameList @425:9...
debug:  - Now solving 'body assertion: Inlined precondition (1/3) of lemmaIsPrefixSameLengthThenSameList' VC for lemmaIsPrefixSameLengthThenSameList @425:9...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || size[B](p1) != size[B](p2) || !p1.isInstanceOf[Cons] || isPrefix[B](p1.t, tail[B](l))
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (1/3) of lemmaIsPrefixSameLengthThenSameList' VC for lemmaIsPrefixSameLengthThenSameList @425:9:
debug:  => VALID
info Verified: 925 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (2/3) of lemmaIsPrefixSameLengthThenSameList' VC for lemmaIsPrefixSameLengthThenSameList @425:9...
debug: Cache miss: 'body assertion: Inlined precondition (2/3) of lemmaIsPrefixSameLengthThenSameList' VC for lemmaIsPrefixSameLengthThenSameList @425:9...
debug:  - Now solving 'body assertion: Inlined precondition (2/3) of lemmaIsPrefixSameLengthThenSameList' VC for lemmaIsPrefixSameLengthThenSameList @425:9...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || size[B](p1) != size[B](p2) || !p1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p1.t, bdg) || isPrefix[B](tail[B](p2), bdg)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (2/3) of lemmaIsPrefixSameLengthThenSameList' VC for lemmaIsPrefixSameLengthThenSameList @425:9:
debug:  => VALID
info Verified: 926 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition (3/3) of lemmaIsPrefixSameLengthThenSameList' VC for lemmaIsPrefixSameLengthThenSameList @425:9...
debug: Cache miss: 'body assertion: Inlined precondition (3/3) of lemmaIsPrefixSameLengthThenSameList' VC for lemmaIsPrefixSameLengthThenSameList @425:9...
debug:  - Now solving 'body assertion: Inlined precondition (3/3) of lemmaIsPrefixSameLengthThenSameList' VC for lemmaIsPrefixSameLengthThenSameList @425:9...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || size[B](p1) != size[B](p2) || !p1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](p2)
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p1.t, bdg) || !isPrefix[B](bdg, bdg) || size[B](p1.t) == size[B](bdg)
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition (3/3) of lemmaIsPrefixSameLengthThenSameList' VC for lemmaIsPrefixSameLengthThenSameList @425:9:
debug:  => VALID
info Verified: 927 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaIsPrefixSameLengthThenSameList @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaIsPrefixSameLengthThenSameList @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaIsPrefixSameLengthThenSameList @?:?...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || size[B](p1) != size[B](p2) || !p1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](p2)
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p1.t, bdg) || !isPrefix[B](bdg, bdg) || size[B](p1.t) != size[B](bdg) || ListPrimitiveSize[B](bdg) < ListPrimitiveSize[B](l)
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaIsPrefixSameLengthThenSameList @?:?:
debug:  => VALID
info Verified: 928 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsPrefixSameLengthThenSameList @425:9...
debug: Cache miss: 'postcondition' VC for lemmaIsPrefixSameLengthThenSameList @425:9...
debug:  - Now solving 'postcondition' VC for lemmaIsPrefixSameLengthThenSameList @425:9...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || size[B](p1) != size[B](p2) || !p1.isInstanceOf[Cons] || {
  val bdg: List[B] = tail[B](p2)
  val bdg: List[B] = tail[B](l)
  !isPrefix[B](p1.t, bdg) || !isPrefix[B](bdg, bdg) || size[B](p1.t) != size[B](bdg) || {
    val bdg: Unit = lemmaIsPrefixSameLengthThenSameList[B](p1.t, bdg, bdg)
    assume(p1.t == bdg)
    p1 == p2
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaIsPrefixSameLengthThenSameList @425:9:
debug:  => VALID
info Verified: 929 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsPrefixSameLengthThenSameList @426:21...
debug: Cache miss: 'postcondition' VC for lemmaIsPrefixSameLengthThenSameList @426:21...
debug:  - Now solving 'postcondition' VC for lemmaIsPrefixSameLengthThenSameList @426:21...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || size[B](p1) != size[B](p2) || p1.isInstanceOf[Cons] || p1 == p2
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaIsPrefixSameLengthThenSameList @426:21:
debug:  => VALID
info Verified: 930 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaIsPrefixSameLengthThenSameList @423:5...
debug: Cache miss: 'body assertion: match exhaustiveness' VC for lemmaIsPrefixSameLengthThenSameList @423:5...
debug:  - Now solving 'body assertion: match exhaustiveness' VC for lemmaIsPrefixSameLengthThenSameList @423:5...
debug: !isPrefix[B](p1, l) || !isPrefix[B](p2, l) || {
  val bdg: BigInt = size[B](p1)
  val bdg: BigInt = size[B](p2)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: match exhaustiveness' VC for lemmaIsPrefixSameLengthThenSameList @423:5:
debug:  => VALID
info Verified: 931 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaIsPrefixSameLengthThenSameList @423:5...
debug: Cache hit: 'postcondition' VC for lemmaIsPrefixSameLengthThenSameList @423:5...
info Verified: 932 / 982
debug:  - Checking cache: 'precond. (call head[B](scrut._1))' VC for isPrefix @14:13...
debug: Cache miss: 'precond. (call head[B](scrut._1))' VC for isPrefix @14:13...
debug:  - Now solving 'precond. (call head[B](scrut._1))' VC for isPrefix @14:13...
debug: prefix.isInstanceOf[Nil] || l.isInstanceOf[Nil] || prefix != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](scrut._1))' VC for isPrefix @14:13:
debug:  => VALID
info Verified: 933 / 982
debug:  - Checking cache: 'precond. (call head[B](scrut._2))' VC for isPrefix @14:24...
debug: Cache miss: 'precond. (call head[B](scrut._2))' VC for isPrefix @14:24...
debug:  - Now solving 'precond. (call head[B](scrut._2))' VC for isPrefix @14:24...
debug: prefix.isInstanceOf[Nil] || l.isInstanceOf[Nil] || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](scrut._2))' VC for isPrefix @14:24:
debug:  => VALID
info Verified: 934 / 982
debug:  - Checking cache: 'precond. (call tail[B](scrut._1))' VC for isPrefix @14:42...
debug: Cache miss: 'precond. (call tail[B](scrut._1))' VC for isPrefix @14:42...
debug:  - Now solving 'precond. (call tail[B](scrut._1))' VC for isPrefix @14:42...
debug: prefix.isInstanceOf[Nil] || l.isInstanceOf[Nil] || head[B](prefix) != head[B](l) || prefix != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](scrut._1))' VC for isPrefix @14:42:
debug:  => VALID
info Verified: 935 / 982
debug:  - Checking cache: 'precond. (call tail[B](scrut._2))' VC for isPrefix @14:51...
debug: Cache miss: 'precond. (call tail[B](scrut._2))' VC for isPrefix @14:51...
debug:  - Now solving 'precond. (call tail[B](scrut._2))' VC for isPrefix @14:51...
debug: prefix.isInstanceOf[Nil] || l.isInstanceOf[Nil] || head[B](prefix) != head[B](l) || l != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](scrut._2))' VC for isPrefix @14:51:
debug:  => VALID
info Verified: 936 / 982
debug:  - Checking cache: 'non-negative measure' VC for isPrefix @9:7...
debug: Cache miss: 'non-negative measure' VC for isPrefix @9:7...
debug:  - Now solving 'non-negative measure' VC for isPrefix @9:7...
debug: ListPrimitiveSize[B](prefix) + ListPrimitiveSize[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for isPrefix @9:7:
debug:  => VALID
info Verified: 937 / 982
debug:  - Checking cache: 'postcondition' VC for isPrefix @16:31...
debug: Cache miss: 'postcondition' VC for isPrefix @16:31...
debug:  - Now solving 'postcondition' VC for isPrefix @16:31...
debug: !prefix.isInstanceOf[Nil] || size[B](l) >= size[B](prefix)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for isPrefix @16:31:
debug:  => VALID
info Verified: 938 / 982
debug:  - Checking cache: 'postcondition' VC for isPrefix @16:58...
debug: Cache miss: 'postcondition' VC for isPrefix @16:58...
info Verified: 939 / 982
debug:  - Checking cache: 'postcondition' VC for isPrefix @16:31...
debug: Cache miss: 'postcondition' VC for isPrefix @16:31...
info Verified: 940 / 982
debug:  - Checking cache: 'postcondition' VC for isPrefix @16:58...
debug: Cache miss: 'postcondition' VC for isPrefix @16:58...
info Verified: 941 / 982
debug:  - Checking cache: 'measure decreases' VC for isPrefix @14:33...
debug: Cache miss: 'measure decreases' VC for isPrefix @14:33...
debug:  - Now solving 'measure decreases' VC for isPrefix @14:33...
debug: prefix.isInstanceOf[Nil] || l.isInstanceOf[Nil] || head[B](prefix) != head[B](l) || ListPrimitiveSize[B](tail[B](prefix)) + ListPrimitiveSize[B](tail[B](l)) < ListPrimitiveSize[B](prefix) + ListPrimitiveSize[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for isPrefix @14:33:
debug:  => VALID
info Verified: 942 / 982
debug:  - Checking cache: 'postcondition' VC for isPrefix @16:31...
debug: Cache miss: 'postcondition' VC for isPrefix @16:31...
debug:  - Now solving 'postcondition' VC for isPrefix @16:31...
debug: prefix.isInstanceOf[Nil] || l.isInstanceOf[Nil] || head[B](prefix) != head[B](l) || !isPrefix[B](tail[B](prefix), tail[B](l)) || size[B](l) >= size[B](prefix)
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for isPrefix @16:31:
debug:  => VALID
info Verified: 943 / 982
debug:  - Checking cache: 'postcondition' VC for isPrefix @16:58...
debug: Cache miss: 'postcondition' VC for isPrefix @16:58...
debug:  - Now solving 'postcondition' VC for isPrefix @16:58...
debug: prefix.isInstanceOf[Nil] || l.isInstanceOf[Nil] || head[B](prefix) != head[B](l) || {
  val bdg: Boolean = isPrefix[B](tail[B](prefix), tail[B](l))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for isPrefix @16:58:
debug:  => VALID
info Verified: 944 / 982
debug:  - Checking cache: 'postcondition' VC for isPrefix @16:31...
debug: Cache miss: 'postcondition' VC for isPrefix @16:31...
info Verified: 945 / 982
debug:  - Checking cache: 'postcondition' VC for isPrefix @16:58...
debug: Cache miss: 'postcondition' VC for isPrefix @16:58...
info Verified: 946 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaForallContainsThenForEqualLists @797:7...
debug: Cache miss: 'postcondition' VC for lemmaForallContainsThenForEqualLists @797:7...
debug:  - Now solving 'postcondition' VC for lemmaForallContainsThenForEqualLists @797:7...
debug: !forall[B](l1, (b: B) => contains[B](l2, b)) || l1 != l1Bis || l2 != l2Bis || forall[B](l1Bis, (b: B) => contains[B](l2Bis, b))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaForallContainsThenForEqualLists @797:7:
debug:  => VALID
info Verified: 947 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](l, suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:33...
debug: Cache miss: 'precond. (call getPrefix[B](l, suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:33...
debug:  - Now solving 'precond. (call getPrefix[B](l, suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:33...
debug: !isSuffix[B](suffix, l) || !l.isInstanceOf[Cons] || {
  val bdg: BigInt = size[B](l)
  val bdg: BigInt = size[B](suffix)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getPrefix[B](l, suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:33:
debug:  => VALID
info Verified: 948 / 982
debug:  - Checking cache: 'precond. (call head[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:62...
debug: Cache miss: 'precond. (call head[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:62...
debug:  - Now solving 'precond. (call head[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:62...
debug: !isSuffix[B](suffix, l) || !l.isInstanceOf[Cons] || size[B](l) != size[B](suffix) || isEmpty[B](suffix) || {
  val bdg: List[B] = getPrefix[B](l, suffix)
  suffix != Nil[B]()
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:62:
debug:  => VALID
info Verified: 949 / 982
debug:  - Checking cache: 'precond. (call tail[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:91...
debug: Cache miss: 'precond. (call tail[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:91...
debug:  - Now solving 'precond. (call tail[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:91...
debug: !isSuffix[B](suffix, l) || !l.isInstanceOf[Cons] || size[B](l) != size[B](suffix) || isEmpty[B](suffix) || suffix != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:91:
debug:  => VALID
info Verified: 950 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](l, tail[B](suffix)))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:78...
debug: Cache miss: 'precond. (call getPrefix[B](l, tail[B](suffix)))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:78...
debug:  - Now solving 'precond. (call getPrefix[B](l, tail[B](suffix)))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:78...
debug: !isSuffix[B](suffix, l) || !l.isInstanceOf[Cons] || size[B](l) != size[B](suffix) || isEmpty[B](suffix) || isSuffix[B](tail[B](suffix), l)
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getPrefix[B](l, tail[B](suffix)))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:78:
debug:  => VALID
info Verified: 951 / 982
debug:  - Checking cache: 'precond. (call lemmaRemovingHeadOfSuffixThenGetPrefi...)' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @?:?...
debug: Cache miss: 'precond. (call lemmaRemovingHeadOfSuffixThenGetPrefi...)' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @?:?...
debug:  - Now solving 'precond. (call lemmaRemovingHeadOfSuffixThenGetPrefi...)' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @?:?...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](l) == size[B](suffix) || !l.isInstanceOf[Cons] || {
  val bdg: Boolean = isSuffix[B](suffix, l.t)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call lemmaRemovingHeadOfSuffixThenGetPrefi...)' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @?:?:
debug:  => VALID
info Verified: 952 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](l, suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:33...
debug: Cache miss: 'precond. (call getPrefix[B](l, suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:33...
debug:  - Now solving 'precond. (call getPrefix[B](l, suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:33...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](l) == size[B](suffix) || !l.isInstanceOf[Cons] || !isSuffix[B](suffix, l.t) || {
  val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](l.t, suffix)
  assume(isEmpty[B](suffix) || ++[B](getPrefix[B](l.t, suffix), Cons[B](head[B](suffix), Nil[B]())) == getPrefix[B](l.t, tail[B](suffix)))
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getPrefix[B](l, suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:33:
debug:  => VALID
info Verified: 953 / 982
debug:  - Checking cache: 'precond. (call head[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:62...
debug: Cache miss: 'precond. (call head[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:62...
debug:  - Now solving 'precond. (call head[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:62...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](l) == size[B](suffix) || !l.isInstanceOf[Cons] || !isSuffix[B](suffix, l.t) || {
  val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](l.t, suffix)
  val bdg: Boolean = isEmpty[B](suffix)
  assume(bdg || ++[B](getPrefix[B](l.t, suffix), Cons[B](head[B](suffix), Nil[B]())) == getPrefix[B](l.t, tail[B](suffix)))
  bdg || {
    val bdg: List[B] = getPrefix[B](l, suffix)
    suffix != Nil[B]()
  }
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:62:
debug:  => VALID
info Verified: 954 / 982
debug:  - Checking cache: 'precond. (call tail[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:91...
debug: Cache miss: 'precond. (call tail[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:91...
debug:  - Now solving 'precond. (call tail[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:91...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](l) == size[B](suffix) || !l.isInstanceOf[Cons] || !isSuffix[B](suffix, l.t) || {
  val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](l.t, suffix)
  val bdg: Boolean = isEmpty[B](suffix)
  assume(bdg || ++[B](getPrefix[B](l.t, suffix), Cons[B](head[B](suffix), Nil[B]())) == getPrefix[B](l.t, tail[B](suffix)))
  bdg || suffix != Nil[B]()
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:91:
debug:  => VALID
info Verified: 955 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](l, tail[B](suffix)))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:78...
debug: Cache miss: 'precond. (call getPrefix[B](l, tail[B](suffix)))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:78...
debug:  - Now solving 'precond. (call getPrefix[B](l, tail[B](suffix)))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:78...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](l) == size[B](suffix) || !l.isInstanceOf[Cons] || !isSuffix[B](suffix, l.t) || {
  val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](l.t, suffix)
  val bdg: Boolean = isEmpty[B](suffix)
  assume(bdg || ++[B](getPrefix[B](l.t, suffix), Cons[B](head[B](suffix), Nil[B]())) == getPrefix[B](l.t, tail[B](suffix)))
  bdg || isSuffix[B](tail[B](suffix), l)
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getPrefix[B](l, tail[B](suffix)))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:78:
debug:  => VALID
info Verified: 956 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](l, suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:33...
debug: Cache miss: 'precond. (call getPrefix[B](l, suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:33...
debug:  - Now solving 'precond. (call getPrefix[B](l, suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:33...
debug: !isSuffix[B](suffix, l) || {
  val bdg: Boolean = !l.isInstanceOf[Cons] || size[B](l) != size[B](suffix)
  true
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getPrefix[B](l, suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:33:
debug:  => VALID
info Verified: 957 / 982
debug:  - Checking cache: 'precond. (call head[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:62...
debug: Cache miss: 'precond. (call head[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:62...
debug:  - Now solving 'precond. (call head[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:62...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](l) == size[B](suffix) || l.isInstanceOf[Cons] || isEmpty[B](suffix) || {
  val bdg: List[B] = getPrefix[B](l, suffix)
  suffix != Nil[B]()
}
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call head[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:62:
debug:  => VALID
info Verified: 958 / 982
debug:  - Checking cache: 'precond. (call tail[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:91...
debug: Cache miss: 'precond. (call tail[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:91...
debug:  - Now solving 'precond. (call tail[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:91...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](l) == size[B](suffix) || l.isInstanceOf[Cons] || isEmpty[B](suffix) || suffix != Nil[B]()
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call tail[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:91:
debug:  => VALID
info Verified: 959 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](l, tail[B](suffix)))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:78...
debug: Cache miss: 'precond. (call getPrefix[B](l, tail[B](suffix)))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:78...
debug:  - Now solving 'precond. (call getPrefix[B](l, tail[B](suffix)))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:78...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](l) == size[B](suffix) || l.isInstanceOf[Cons] || isEmpty[B](suffix) || isSuffix[B](tail[B](suffix), l)
debug: Solving with: Pfolio
debug:  - Result for 'precond. (call getPrefix[B](l, tail[B](suffix)))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:78:
debug:  => VALID
info Verified: 960 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](l, suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:33...
debug: Cache hit: 'precond. (call getPrefix[B](l, suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:33...
info Verified: 961 / 982
debug:  - Checking cache: 'precond. (call head[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:62...
debug: Cache hit: 'precond. (call head[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:62...
info Verified: 962 / 982
debug:  - Checking cache: 'precond. (call tail[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:91...
debug: Cache hit: 'precond. (call tail[B](suffix))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:91...
info Verified: 963 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B](l, tail[B](suffix)))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:78...
debug: Cache hit: 'precond. (call getPrefix[B](l, tail[B](suffix)))' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @145:78...
info Verified: 964 / 982
debug:  - Checking cache: 'non-negative measure' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @135:15...
debug: Cache miss: 'non-negative measure' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @135:15...
debug:  - Now solving 'non-negative measure' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @135:15...
debug: !isSuffix[B](suffix, l) || size[B](l) >= BigInt("0")
debug: Solving with: Pfolio
debug:  - Result for 'non-negative measure' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @135:15:
debug:  => VALID
info Verified: 965 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @138:55...
debug: Cache miss: 'postcondition' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @138:55...
debug:  - Now solving 'postcondition' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @138:55...
debug: !isSuffix[B](suffix, l) || !l.isInstanceOf[Cons] || size[B](l) != size[B](suffix) || isEmpty[B](suffix) || ++[B](getPrefix[B](l, suffix), Cons[B](head[B](suffix), Nil[B]())) == getPrefix[B](l, tail[B](suffix))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @138:55:
debug:  => VALID
info Verified: 966 / 982
debug:  - Checking cache: 'body assertion: Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @140:9...
debug: Cache miss: 'body assertion: Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @140:9...
debug:  - Now solving 'body assertion: Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @140:9...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](l) == size[B](suffix) || !l.isInstanceOf[Cons] || isSuffix[B](suffix, l.t)
debug: Solving with: Pfolio
debug:  - Result for 'body assertion: Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @140:9:
debug:  => VALID
info Verified: 967 / 982
debug:  - Checking cache: 'measure decreases' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @?:?...
debug: Cache miss: 'measure decreases' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @?:?...
debug:  - Now solving 'measure decreases' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @?:?...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](l) == size[B](suffix) || !l.isInstanceOf[Cons] || !isSuffix[B](suffix, l.t) || size[B](l.t) < size[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @?:?:
debug:  => VALID
info Verified: 968 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @140:9...
debug: Cache miss: 'postcondition' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @140:9...
debug:  - Now solving 'postcondition' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @140:9...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](l) == size[B](suffix) || !l.isInstanceOf[Cons] || !isSuffix[B](suffix, l.t) || {
  val bdg: Unit = lemmaRemovingHeadOfSuffixThenGetPrefixLonger[B](l.t, suffix)
  val bdg: Boolean = isEmpty[B](suffix)
  assume(bdg || ++[B](getPrefix[B](l.t, suffix), Cons[B](head[B](suffix), Nil[B]())) == getPrefix[B](l.t, tail[B](suffix)))
  bdg || ++[B](getPrefix[B](l, suffix), Cons[B](head[B](suffix), Nil[B]())) == getPrefix[B](l, tail[B](suffix))
}
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @140:9:
debug:  => VALID
info Verified: 969 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @142:21...
debug: Cache miss: 'postcondition' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @142:21...
debug:  - Now solving 'postcondition' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @142:21...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](l) == size[B](suffix) || l.isInstanceOf[Cons] || isEmpty[B](suffix) || ++[B](getPrefix[B](l, suffix), Cons[B](head[B](suffix), Nil[B]())) == getPrefix[B](l, tail[B](suffix))
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @142:21:
debug:  => VALID
info Verified: 970 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @137:5...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @137:5...
info Verified: 971 / 982
debug:  - Checking cache: 'postcondition' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @137:5...
debug: Cache hit: 'postcondition' VC for lemmaRemovingHeadOfSuffixThenGetPrefixLonger @137:5...
info Verified: 972 / 982
debug:  - Checking cache: 'precond. (call getPrefix[B]((scrut.t): @DropVCs , su...)' VC for getPrefix @90:64...
debug: Cache hit: 'precond. (call getPrefix[B]((scrut.t): @DropVCs , su...)' VC for getPrefix @90:64...
info Verified: 973 / 982
debug:  - Checking cache: 'non-negative measure' VC for getPrefix @87:15...
debug: Cache hit: 'non-negative measure' VC for getPrefix @87:15...
info Verified: 974 / 982
debug:  - Checking cache: 'postcondition' VC for getPrefix @89:55...
debug: Cache miss: 'postcondition' VC for getPrefix @89:55...
debug:  - Now solving 'postcondition' VC for getPrefix @89:55...
debug: !isSuffix[B](suffix, l) || !l.isInstanceOf[Cons] || size[B](l) != size[B](suffix) || ++[B](Nil[B](), suffix) == l
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for getPrefix @89:55:
debug:  => VALID
info Verified: 975 / 982
debug:  - Checking cache: 'measure decreases' VC for getPrefix @90:64...
debug: Cache miss: 'measure decreases' VC for getPrefix @90:64...
debug:  - Now solving 'measure decreases' VC for getPrefix @90:64...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](l) == size[B](suffix) || !l.isInstanceOf[Cons] || size[B](l.t) < size[B](l)
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for getPrefix @90:64:
debug:  => VALID
info Verified: 976 / 982
debug:  - Checking cache: 'postcondition' VC for getPrefix @90:55...
debug: Cache miss: 'postcondition' VC for getPrefix @90:55...
debug:  - Now solving 'postcondition' VC for getPrefix @90:55...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](l) == size[B](suffix) || !l.isInstanceOf[Cons] || ++[B](Cons[B](l.h, getPrefix[B](l.t, suffix)), suffix) == l
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for getPrefix @90:55:
debug:  => VALID
info Verified: 977 / 982
debug:  - Checking cache: 'postcondition' VC for getPrefix @91:55...
debug: Cache miss: 'postcondition' VC for getPrefix @91:55...
debug:  - Now solving 'postcondition' VC for getPrefix @91:55...
debug: !isSuffix[B](suffix, l) || l.isInstanceOf[Cons] && size[B](l) == size[B](suffix) || l.isInstanceOf[Cons] || ++[B](Nil[B](), suffix) == l
debug: Solving with: Pfolio
debug:  - Result for 'postcondition' VC for getPrefix @91:55:
debug:  => VALID
info Verified: 978 / 982
debug:  - Checking cache: 'body assertion: match exhaustiveness' VC for getPrefix @88:5...
debug: Cache hit: 'body assertion: match exhaustiveness' VC for getPrefix @88:5...
info Verified: 979 / 982
debug:  - Checking cache: 'postcondition' VC for getPrefix @88:5...
debug: Cache hit: 'postcondition' VC for getPrefix @88:5...
info Verified: 980 / 982
debug:  - Checking cache: 'non-negative measure' VC for isSuffix @76:15...
debug: Cache hit: 'non-negative measure' VC for isSuffix @76:15...
info Verified: 981 / 982
debug:  - Checking cache: 'measure decreases' VC for isSuffix @78:62...
debug: Cache miss: 'measure decreases' VC for isSuffix @78:62...
debug:  - Now solving 'measure decreases' VC for isSuffix @78:62...
debug: !lTot.isInstanceOf[Cons] || {
  val bdg: BigInt = size[B](l1)
  val bdg: BigInt = size[B](lTot)
  bdg >= bdg || size[B](lTot.t) < bdg
}
debug: Solving with: Pfolio
debug:  - Result for 'measure decreases' VC for isSuffix @78:62:
debug:  => VALID
info Verified: 982 / 982
Done in 125.77s
  
 stainless summary 
                                                                                                                                                                                                                           
                           concatWithoutDuplicates                                           measure decreases                                                                                               valid             U:smt-z3    0.2 
                           concatWithoutDuplicates                                           measure decreases                                                                                               valid             U:smt-z3    0.2 
                           concatWithoutDuplicates                                           precond. (call concatWithoutDuplicates[B](baseList, ...)                                                        valid             U:smt-z3    0.1 
                           concatWithoutDuplicates                                           precond. (call concatWithoutDuplicates[B](baseList, ...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:571:15:    concatWithoutDuplicates                                           non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:573:5:     concatWithoutDuplicates                                           body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:573:5:     concatWithoutDuplicates                                           postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:575:9:     concatWithoutDuplicates                                           body assertion: Inlined precondition of concatWithoutDuplicates                                                 valid from cache              0.0 
ListUtils.scala:575:9:     concatWithoutDuplicates                                           postcondition                                                                                                   valid             U:smt-z3    0.4 
ListUtils.scala:577:9:     concatWithoutDuplicates                                           body assertion: Inlined precondition of concatWithoutDuplicates                                                 valid             U:smt-cvc4  0.1 
ListUtils.scala:577:9:     concatWithoutDuplicates                                           postcondition                                                                                                   valid             U:smt-z3    0.2 
ListUtils.scala:580:51:    concatWithoutDuplicates                                           postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:58:5:      consecutiveSubseq                                                 body assertion: match exhaustiveness                                                                            trivial                       0.0 
ListUtils.scala:60:46:     consecutiveSubseq                                                 measure decreases                                                                                               valid             U:smt-z3    0.1 
ListUtils.scala:61:49:     consecutiveSubseq                                                 non-negative measure                                                                                            valid from cache              0.0 
ListUtils.scala:67:6:      consecutiveSubseqAtHead                                           non-negative measure                                                                                            valid from cache              0.0 
ListUtils.scala:70:9:      consecutiveSubseqAtHead                                           measure decreases                                                                                               valid             U:smt-z3    0.1 
ListUtils.scala:49:5:      getIndex                                                          body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:49:5:      getIndex                                                          non-negative measure                                                                                            valid from cache              0.0 
ListUtils.scala:49:5:      getIndex                                                          postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:50:39:     getIndex                                                          postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:51:39:     getIndex                                                          postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:51:43:     getIndex                                                          measure decreases                                                                                               valid             U:smt-z3    0.1 
ListUtils.scala:51:43:     getIndex                                                          precond. (call getIndex[B]((scrut.t): @DropVCs , e))                                                            valid             U:smt-z3    0.1 
ListUtils.scala:52:39:     getIndex                                                          postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:87:15:     getPrefix                                                         non-negative measure                                                                                            valid from cache              0.0 
ListUtils.scala:88:5:      getPrefix                                                         body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:88:5:      getPrefix                                                         postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:89:55:     getPrefix                                                         postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:90:55:     getPrefix                                                         postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:90:64:     getPrefix                                                         measure decreases                                                                                               valid             U:smt-z3    0.1 
ListUtils.scala:90:64:     getPrefix                                                         precond. (call getPrefix[B]((scrut.t): @DropVCs , su...)                                                        valid from cache              0.0 
ListUtils.scala:91:55:     getPrefix                                                         postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:40:5:      getSuffix                                                         body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.0 
ListUtils.scala:40:5:      getSuffix                                                         postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:41:28:     getSuffix                                                         measure decreases                                                                                               valid             U:smt-z3    0.1 
ListUtils.scala:41:28:     getSuffix                                                         postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:41:28:     getSuffix                                                         precond. (call getSuffix[B](tail[B](l), (scrut.t): @... (require 1/2))                                          valid             U:smt-z3    0.1 
ListUtils.scala:41:28:     getSuffix                                                         precond. (call getSuffix[B](tail[B](l), (scrut.t): @... (require 2/2))                                          valid             U:smt-z3    0.1 
ListUtils.scala:41:38:     getSuffix                                                         precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:44:34:     getSuffix                                                         non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:44:34:     getSuffix                                                         postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:9:7:       isPrefix                                                          non-negative measure                                                                                            valid             U:smt-z3    0.0 
ListUtils.scala:14:13:     isPrefix                                                          precond. (call head[B](scrut._1))                                                                               valid             U:smt-z3    0.0 
ListUtils.scala:14:24:     isPrefix                                                          precond. (call head[B](scrut._2))                                                                               valid             U:smt-z3    0.0 
ListUtils.scala:14:33:     isPrefix                                                          measure decreases                                                                                               valid             U:smt-z3    0.1 
ListUtils.scala:14:42:     isPrefix                                                          precond. (call tail[B](scrut._1))                                                                               valid             U:smt-z3    0.0 
ListUtils.scala:14:51:     isPrefix                                                          precond. (call tail[B](scrut._2))                                                                               valid             U:smt-z3    0.0 
ListUtils.scala:16:31:     isPrefix                                                          postcondition                                                                                                   trivial                       0.0 
ListUtils.scala:16:31:     isPrefix                                                          postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:16:31:     isPrefix                                                          postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:16:31:     isPrefix                                                          postcondition                                                                                                   trivial                       0.0 
ListUtils.scala:16:58:     isPrefix                                                          postcondition                                                                                                   trivial                       0.0 
ListUtils.scala:16:58:     isPrefix                                                          postcondition                                                                                                   trivial                       0.0 
ListUtils.scala:16:58:     isPrefix                                                          postcondition                                                                                                   trivial                       0.0 
ListUtils.scala:16:58:     isPrefix                                                          postcondition                                                                                                   valid             U:smt-z3    0.0 
ListUtils.scala:76:15:     isSuffix                                                          non-negative measure                                                                                            valid from cache              0.0 
ListUtils.scala:78:62:     isSuffix                                                          measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaAddHeadSuffixToPrefixStillPrefix                             measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaAddHeadSuffixToPrefixStillPrefix                             precond. (call lemmaAddHeadSuffixToPrefixStillPrefix... (require 1/2))                                          valid             U:smt-cvc4  0.1 
                           lemmaAddHeadSuffixToPrefixStillPrefix                             precond. (call lemmaAddHeadSuffixToPrefixStillPrefix... (require 2/2))                                          valid from cache              0.0 
ListUtils.scala:504:5:     lemmaAddHeadSuffixToPrefixStillPrefix                             body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:504:5:     lemmaAddHeadSuffixToPrefixStillPrefix                             postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:505:28:    lemmaAddHeadSuffixToPrefixStillPrefix                             body assertion: Inlined precondition (1/2) of lemmaAddHeadSuffixToPrefixStillPrefix                             valid             U:smt-z3    0.1 
ListUtils.scala:505:28:    lemmaAddHeadSuffixToPrefixStillPrefix                             body assertion: Inlined precondition (2/2) of lemmaAddHeadSuffixToPrefixStillPrefix                             valid             U:smt-z3    0.1 
ListUtils.scala:505:28:    lemmaAddHeadSuffixToPrefixStillPrefix                             postcondition                                                                                                   valid             U:smt-z3    0.2 
ListUtils.scala:505:70:    lemmaAddHeadSuffixToPrefixStillPrefix                             precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:506:28:    lemmaAddHeadSuffixToPrefixStillPrefix                             postcondition                                                                                                   valid             U:smt-z3    0.4 
ListUtils.scala:508:34:    lemmaAddHeadSuffixToPrefixStillPrefix                             precond. (call getSuffix[B](l, p) (require 1/2))                                                                valid from cache              0.0 
ListUtils.scala:508:34:    lemmaAddHeadSuffixToPrefixStillPrefix                             precond. (call getSuffix[B](l, p) (require 1/2))                                                                valid             U:smt-cvc4  0.1 
ListUtils.scala:508:34:    lemmaAddHeadSuffixToPrefixStillPrefix                             precond. (call getSuffix[B](l, p) (require 1/2))                                                                valid             U:smt-z3    0.1 
ListUtils.scala:508:34:    lemmaAddHeadSuffixToPrefixStillPrefix                             precond. (call getSuffix[B](l, p) (require 2/2))                                                                valid from cache              0.0 
ListUtils.scala:508:34:    lemmaAddHeadSuffixToPrefixStillPrefix                             precond. (call getSuffix[B](l, p) (require 2/2))                                                                valid             U:smt-z3    0.1 
ListUtils.scala:508:34:    lemmaAddHeadSuffixToPrefixStillPrefix                             precond. (call getSuffix[B](l, p) (require 2/2))                                                                valid             U:smt-z3    0.1 
ListUtils.scala:508:34:    lemmaAddHeadSuffixToPrefixStillPrefix                             precond. (call head[B](getSuffix[B](l, p)))                                                                     valid             U:smt-z3    0.2 
ListUtils.scala:508:34:    lemmaAddHeadSuffixToPrefixStillPrefix                             precond. (call head[B](getSuffix[B](l, p)))                                                                     valid from cache              0.0 
ListUtils.scala:508:34:    lemmaAddHeadSuffixToPrefixStillPrefix                             precond. (call head[B](getSuffix[B](l, p)))                                                                     valid             U:smt-z3    0.1 
ListUtils.scala:508:57:    lemmaAddHeadSuffixToPrefixStillPrefix                             non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:353:5:     lemmaChangeCutStillConcatTotal                                    postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:353:47:    lemmaChangeCutStillConcatTotal                                    precond. (call head[B](l2))                                                                                     valid             U:smt-z3    0.1 
ListUtils.scala:353:57:    lemmaChangeCutStillConcatTotal                                    precond. (call tail[B](l2))                                                                                     valid from cache              0.0 
ListUtils.scala:355:27:    lemmaChangeCutStillConcatTotal                                    precond. (call head[B](l2))                                                                                     valid             U:smt-z3    0.1 
ListUtils.scala:355:40:    lemmaChangeCutStillConcatTotal                                    precond. (call tail[B](l2))                                                                                     valid from cache              0.0 
                           lemmaConcatAssociativity                                          measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaConcatAssociativity                                          precond. (call lemmaConcatAssociativity[B](l1, elmt,...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:319:12:    lemmaConcatAssociativity                                          body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:320:5:     lemmaConcatAssociativity                                          body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:320:5:     lemmaConcatAssociativity                                          postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:321:28:    lemmaConcatAssociativity                                          body assertion: Inlined precondition of lemmaConcatAssociativity                                                valid             U:smt-z3    0.1 
ListUtils.scala:321:28:    lemmaConcatAssociativity                                          postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:321:67:    lemmaConcatAssociativity                                          precond. (call tail[B](tot))                                                                                    valid             U:smt-z3    0.1 
ListUtils.scala:322:28:    lemmaConcatAssociativity                                          postcondition                                                                                                   valid             U:smt-z3    0.2 
ListUtils.scala:324:15:    lemmaConcatAssociativity                                          non-negative measure                                                                                            valid             U:smt-z3    0.2 
                           lemmaConcatThenFirstSubseqOfTot                                   measure decreases                                                                                               valid             U:smt-z3    0.1 
ListUtils.scala:729:15:    lemmaConcatThenFirstSubseqOfTot                                   non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:730:5:     lemmaConcatThenFirstSubseqOfTot                                   body assertion: match exhaustiveness                                                                            trivial                       0.0 
ListUtils.scala:730:5:     lemmaConcatThenFirstSubseqOfTot                                   postcondition                                                                                                   trivial                       0.0 
ListUtils.scala:731:28:    lemmaConcatThenFirstSubseqOfTot                                   postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:732:28:    lemmaConcatThenFirstSubseqOfTot                                   postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaConcatThenSecondSubseqOfTot                                  measure decreases                                                                                               valid from cache              0.0 
ListUtils.scala:739:15:    lemmaConcatThenSecondSubseqOfTot                                  non-negative measure                                                                                            valid from cache              0.0 
ListUtils.scala:740:5:     lemmaConcatThenSecondSubseqOfTot                                  body assertion: match exhaustiveness                                                                            trivial                       0.0 
ListUtils.scala:740:5:     lemmaConcatThenSecondSubseqOfTot                                  postcondition                                                                                                   trivial                       0.0 
ListUtils.scala:741:28:    lemmaConcatThenSecondSubseqOfTot                                  postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:742:28:    lemmaConcatThenSecondSubseqOfTot                                  postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaConcatTwoListThenFirstIsPrefix                               measure decreases                                                                                               valid from cache              0.0 
ListUtils.scala:274:5:     lemmaConcatTwoListThenFirstIsPrefix                               body assertion: match exhaustiveness                                                                            trivial                       0.0 
ListUtils.scala:274:5:     lemmaConcatTwoListThenFirstIsPrefix                               postcondition                                                                                                   trivial                       0.0 
ListUtils.scala:275:28:    lemmaConcatTwoListThenFirstIsPrefix                               postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:276:28:    lemmaConcatTwoListThenFirstIsPrefix                               postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:278:28:    lemmaConcatTwoListThenFirstIsPrefix                               non-negative measure                                                                                            valid from cache              0.0 
                           lemmaConcatTwoListsWhichNotContainThenTotNotContain               measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaConcatTwoListsWhichNotContainThenTotNotContain               precond. (call lemmaConcatTwoListsWhichNotContainThe... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaConcatTwoListsWhichNotContainThenTotNotContain               precond. (call lemmaConcatTwoListsWhichNotContainThe... (require 2/2))                                          valid from cache              0.0 
ListUtils.scala:757:5:     lemmaConcatTwoListsWhichNotContainThenTotNotContain               body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:757:5:     lemmaConcatTwoListsWhichNotContainThenTotNotContain               postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:758:39:    lemmaConcatTwoListsWhichNotContainThenTotNotContain               body assertion: Inlined precondition of check                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:758:39:    lemmaConcatTwoListsWhichNotContainThenTotNotContain               postcondition                                                                                                   valid             U:smt-z3    0.0 
ListUtils.scala:760:9:     lemmaConcatTwoListsWhichNotContainThenTotNotContain               body assertion: Inlined precondition (1/2) of lemmaConcatTwoListsWhichNotContainThenTotNotContain               valid             U:smt-z3    0.1 
ListUtils.scala:760:9:     lemmaConcatTwoListsWhichNotContainThenTotNotContain               body assertion: Inlined precondition (2/2) of lemmaConcatTwoListsWhichNotContainThenTotNotContain               valid from cache              0.0 
ListUtils.scala:760:9:     lemmaConcatTwoListsWhichNotContainThenTotNotContain               postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:761:21:    lemmaConcatTwoListsWhichNotContainThenTotNotContain               postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:763:17:    lemmaConcatTwoListsWhichNotContainThenTotNotContain               non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaConsecutiveSubseqThenSubseq                                  measure decreases                                                                                               valid             U:smt-z3    0.2 
                           lemmaConsecutiveSubseqThenSubseq                                  measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaConsecutiveSubseqThenSubseq                                  precond. (call lemmaConsecutiveSubseqThenSubseq[B](l...)                                                        valid             U:smt-z3    0.1 
                           lemmaConsecutiveSubseqThenSubseq                                  precond. (call lemmaConsecutiveSubseqThenSubseq[B](l...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:167:15:    lemmaConsecutiveSubseqThenSubseq                                  non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:170:9:     lemmaConsecutiveSubseqThenSubseq                                  body assertion: Inlined precondition of lemmaConsecutiveSubseqThenSubseq                                        valid             U:smt-cvc4  0.2 
ListUtils.scala:170:9:     lemmaConsecutiveSubseqThenSubseq                                  postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:172:9:     lemmaConsecutiveSubseqThenSubseq                                  body assertion: Inlined precondition of lemmaConsecutiveSubseqThenSubseq                                        valid             U:smt-z3    0.2 
ListUtils.scala:172:9:     lemmaConsecutiveSubseqThenSubseq                                  postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:173:17:    lemmaConsecutiveSubseqThenSubseq                                  postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:180:7:     lemmaContainsAndNotHdThenTlContains                               postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:182:13:    lemmaContainsAndNotHdThenTlContains                               precond. (call head[B](l))                                                                                      valid from cache              0.0 
ListUtils.scala:184:15:    lemmaContainsAndNotHdThenTlContains                               precond. (call tail[B](l))                                                                                      valid from cache              0.0 
                           lemmaForallContainsAddingElmtInPreserves                          measure decreases                                                                                               valid             U:smt-z3    0.3 
                           lemmaForallContainsAddingElmtInPreserves                          precond. (call lemmaForallContainsAddingElmtInPreser... (require 1/2))                                          valid             U:smt-z3    0.4 
                           lemmaForallContainsAddingElmtInPreserves                          precond. (call lemmaForallContainsAddingElmtInPreser... (require 2/2))                                          valid             U:smt-z3    0.2 
ListUtils.scala:869:5:     lemmaForallContainsAddingElmtInPreserves                          body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:869:5:     lemmaForallContainsAddingElmtInPreserves                          postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:871:9:     lemmaForallContainsAddingElmtInPreserves                          body assertion: Inlined precondition (1/2) of lemmaForallContainsAddingElmtInPreserves                          valid             U:smt-z3    0.3 
ListUtils.scala:871:9:     lemmaForallContainsAddingElmtInPreserves                          body assertion: Inlined precondition (2/2) of lemmaForallContainsAddingElmtInPreserves                          valid             U:smt-z3    0.1 
ListUtils.scala:871:9:     lemmaForallContainsAddingElmtInPreserves                          postcondition                                                                                                   valid             U:smt-z3    0.4 
ListUtils.scala:872:21:    lemmaForallContainsAddingElmtInPreserves                          postcondition                                                                                                   valid             U:smt-cvc4  0.2 
ListUtils.scala:875:23:    lemmaForallContainsAddingElmtInPreserves                          non-negative measure                                                                                            valid             U:smt-z3    0.3 
                           lemmaForallContainsAddingInSndListPreserves                       measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaForallContainsAddingInSndListPreserves                       precond. (call lemmaForallContainsAddingInSndListPre...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:850:5:     lemmaForallContainsAddingInSndListPreserves                       body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:850:5:     lemmaForallContainsAddingInSndListPreserves                       postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:852:9:     lemmaForallContainsAddingInSndListPreserves                       body assertion: Inlined precondition of lemmaForallContainsAddingInSndListPreserves                             valid             U:smt-z3    0.1 
ListUtils.scala:852:9:     lemmaForallContainsAddingInSndListPreserves                       postcondition                                                                                                   valid             U:smt-z3    0.2 
ListUtils.scala:853:21:    lemmaForallContainsAddingInSndListPreserves                       postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:856:15:    lemmaForallContainsAddingInSndListPreserves                       non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaForallContainsAndNoDuplicateThenSmallerList                  measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaForallContainsAndNoDuplicateThenSmallerList                  precond. (call lemmaForallContainsAndNoDuplicateThen... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaForallContainsAndNoDuplicateThenSmallerList                  precond. (call lemmaForallContainsAndNoDuplicateThen... (require 2/2))                                          valid             U:smt-z3    0.1 
                           lemmaForallContainsAndNoDuplicateThenSmallerList                  precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:817:15:    lemmaForallContainsAndNoDuplicateThenSmallerList                  non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:819:5:     lemmaForallContainsAndNoDuplicateThenSmallerList                  body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:819:5:     lemmaForallContainsAndNoDuplicateThenSmallerList                  postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:822:9:     lemmaForallContainsAndNoDuplicateThenSmallerList                  precond. (call forallContainsSubset[B](lIn, l))                                                                 valid             U:smt-z3    0.1 
ListUtils.scala:823:16:    lemmaForallContainsAndNoDuplicateThenSmallerList                  body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:824:16:    lemmaForallContainsAndNoDuplicateThenSmallerList                  body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:826:16:    lemmaForallContainsAndNoDuplicateThenSmallerList                  body assertion                                                                                                  valid             U:smt-z3    0.2 
ListUtils.scala:827:9:     lemmaForallContainsAndNoDuplicateThenSmallerList                  precond. (call subsetContains[B]((scrut.t): @DropVCs...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:828:9:     lemmaForallContainsAndNoDuplicateThenSmallerList                  body assertion: Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList                  valid             U:smt-z3    0.1 
ListUtils.scala:828:9:     lemmaForallContainsAndNoDuplicateThenSmallerList                  body assertion: Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList                  valid             U:smt-z3    0.1 
ListUtils.scala:829:16:    lemmaForallContainsAndNoDuplicateThenSmallerList                  body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:830:16:    lemmaForallContainsAndNoDuplicateThenSmallerList                  body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:831:16:    lemmaForallContainsAndNoDuplicateThenSmallerList                  body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:832:16:    lemmaForallContainsAndNoDuplicateThenSmallerList                  body assertion                                                                                                  valid from cache              0.0 
ListUtils.scala:833:9:     lemmaForallContainsAndNoDuplicateThenSmallerList                  body assertion: Inlined precondition of lemmaRemoveElmtContainedSizeSmaller                                     valid from cache              0.0 
ListUtils.scala:834:9:     lemmaForallContainsAndNoDuplicateThenSmallerList                  postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:834:16:    lemmaForallContainsAndNoDuplicateThenSmallerList                  body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:836:21:    lemmaForallContainsAndNoDuplicateThenSmallerList                  postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallContainsConcatPreserves                                measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaForallContainsConcatPreserves                                precond. (call lemmaForallContainsConcatPreserves[B]... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaForallContainsConcatPreserves                                precond. (call lemmaForallContainsConcatPreserves[B]... (require 2/2))                                          valid             U:smt-z3    0.1 
ListUtils.scala:884:5:     lemmaForallContainsConcatPreserves                                body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:884:5:     lemmaForallContainsConcatPreserves                                postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:885:21:    lemmaForallContainsConcatPreserves                                postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:887:9:     lemmaForallContainsConcatPreserves                                body assertion: Inlined precondition (1/2) of lemmaForallContainsConcatPreserves                                valid             U:smt-z3    0.1 
ListUtils.scala:887:9:     lemmaForallContainsConcatPreserves                                body assertion: Inlined precondition (2/2) of lemmaForallContainsConcatPreserves                                valid             U:smt-z3    0.1 
ListUtils.scala:887:9:     lemmaForallContainsConcatPreserves                                postcondition                                                                                                   valid             U:smt-z3    0.2 
ListUtils.scala:890:16:    lemmaForallContainsConcatPreserves                                non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaForallContainsPreservedIfSameContent                         measure decreases                                                                                               valid             U:smt-cvc4  0.1 
                           lemmaForallContainsPreservedIfSameContent                         precond. (call lemmaForallContainsPreservedIfSameCon... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaForallContainsPreservedIfSameContent                         precond. (call lemmaForallContainsPreservedIfSameCon... (require 2/2))                                          valid             U:smt-z3    0.1 
ListUtils.scala:915:5:     lemmaForallContainsPreservedIfSameContent                         body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:915:5:     lemmaForallContainsPreservedIfSameContent                         postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:916:21:    lemmaForallContainsPreservedIfSameContent                         postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:918:9:     lemmaForallContainsPreservedIfSameContent                         precond. (call forallContained[B](l1, (b: B) => cont...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:919:9:     lemmaForallContainsPreservedIfSameContent                         body assertion: Inlined precondition (1/2) of lemmaForallContainsPreservedIfSameContent                         valid             U:smt-z3    0.1 
ListUtils.scala:919:9:     lemmaForallContainsPreservedIfSameContent                         body assertion: Inlined precondition (2/2) of lemmaForallContainsPreservedIfSameContent                         valid             U:smt-z3    0.1 
ListUtils.scala:919:9:     lemmaForallContainsPreservedIfSameContent                         postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:922:15:    lemmaForallContainsPreservedIfSameContent                         non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaForallContainsPreservedRemoveElmt                            body assertion: match exhaustiveness                                                                            valid from cache              0.0 
                           lemmaForallContainsPreservedRemoveElmt                            measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaForallContainsPreservedRemoveElmt                            postcondition                                                                                                   valid from cache              0.0 
                           lemmaForallContainsPreservedRemoveElmt                            postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallContainsPreservedRemoveElmt                            postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallContainsPreservedRemoveElmt                            precond. (call lemmaForallContainsPreservedRemoveElm...)                                                        valid from cache              0.0 
ListUtils.scala:894:57:    lemmaForallContainsPreservedRemoveElmt                            non-negative measure                                                                                            valid from cache              0.0 
                           lemmaForallContainsPreservedRemoveElmtInRefList                   body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
                           lemmaForallContainsPreservedRemoveElmtInRefList                   measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaForallContainsPreservedRemoveElmtInRefList                   postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallContainsPreservedRemoveElmtInRefList                   postcondition                                                                                                   valid from cache              0.0 
                           lemmaForallContainsPreservedRemoveElmtInRefList                   postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallContainsPreservedRemoveElmtInRefList                   precond. (call lemmaForallContainsPreservedRemoveElm... (require 1/3))                                          valid             U:smt-z3    0.1 
                           lemmaForallContainsPreservedRemoveElmtInRefList                   precond. (call lemmaForallContainsPreservedRemoveElm... (require 2/3))                                          valid             U:smt-z3    0.1 
                           lemmaForallContainsPreservedRemoveElmtInRefList                   precond. (call lemmaForallContainsPreservedRemoveElm... (require 3/3))                                          valid             U:smt-z3    0.1 
ListUtils.scala:901:66:    lemmaForallContainsPreservedRemoveElmtInRefList                   non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:797:7:     lemmaForallContainsThenForEqualLists                              postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallContainsThenInOtherList                                measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaForallContainsThenInOtherList                                precond. (call lemmaForallContainsThenInOtherList[B]... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaForallContainsThenInOtherList                                precond. (call lemmaForallContainsThenInOtherList[B]... (require 2/2))                                          valid             U:smt-z3    0.1 
ListUtils.scala:776:5:     lemmaForallContainsThenInOtherList                                body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.0 
ListUtils.scala:776:5:     lemmaForallContainsThenInOtherList                                non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:776:5:     lemmaForallContainsThenInOtherList                                postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:777:39:    lemmaForallContainsThenInOtherList                                postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:778:39:    lemmaForallContainsThenInOtherList                                body assertion: Inlined precondition (1/2) of lemmaForallContainsThenInOtherList                                valid             U:smt-z3    0.1 
ListUtils.scala:778:39:    lemmaForallContainsThenInOtherList                                body assertion: Inlined precondition (2/2) of lemmaForallContainsThenInOtherList                                valid             U:smt-z3    0.1 
ListUtils.scala:778:39:    lemmaForallContainsThenInOtherList                                postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:779:39:    lemmaForallContainsThenInOtherList                                postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallNotContainedNoDupThenConcatNoDup                       body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
                           lemmaForallNotContainedNoDupThenConcatNoDup                       measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaForallNotContainedNoDupThenConcatNoDup                       precond. (call lemmaForallNotContainedNoDupThenConca... (require 1/3))                                          valid             U:smt-z3    0.1 
                           lemmaForallNotContainedNoDupThenConcatNoDup                       precond. (call lemmaForallNotContainedNoDupThenConca... (require 2/3))                                          valid             U:smt-z3    0.1 
                           lemmaForallNotContainedNoDupThenConcatNoDup                       precond. (call lemmaForallNotContainedNoDupThenConca... (require 3/3))                                          valid             U:smt-z3    0.1 
ListUtils.scala:976:62:    lemmaForallNotContainedNoDupThenConcatNoDup                       non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:981:15:    lemmaForallNotContainedNoDupThenConcatNoDup                       postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:981:15:    lemmaForallNotContainedNoDupThenConcatNoDup                       postcondition                                                                                                   valid             U:smt-z3    0.2 
ListUtils.scala:981:15:    lemmaForallNotContainedNoDupThenConcatNoDup                       postcondition                                                                                                   valid             U:smt-z3    0.3 
                           lemmaForallNotContainsCannotContain                               body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
                           lemmaForallNotContainsCannotContain                               measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaForallNotContainsCannotContain                               postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallNotContainsCannotContain                               postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallNotContainsCannotContain                               postcondition                                                                                                   valid from cache              0.0 
                           lemmaForallNotContainsCannotContain                               precond. (call lemmaForallNotContainsCannotContain[B... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaForallNotContainsCannotContain                               precond. (call lemmaForallNotContainsCannotContain[B... (require 2/2))                                          valid             U:smt-z3    0.1 
ListUtils.scala:949:54:    lemmaForallNotContainsCannotContain                               non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForConcat                                   body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForConcat                                   measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForConcat                                   postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForConcat                                   postcondition                                                                                                   valid from cache              0.0 
                           lemmaForallNotContainsForConcat                                   postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForConcat                                   precond. (call lemmaForallNotContainsForConcat[B]((s... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForConcat                                   precond. (call lemmaForallNotContainsForConcat[B]((s... (require 2/2))                                          valid             U:smt-z3    0.1 
ListUtils.scala:933:50:    lemmaForallNotContainsForConcat                                   non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForConcat                                   body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForConcat                                   measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForConcat                                   postcondition                                                                                                   valid             U:smt-z3    0.3 
                           lemmaForallNotContainsForConcat                                   postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForConcat                                   postcondition                                                                                                   valid from cache              0.0 
                           lemmaForallNotContainsForConcat                                   precond. (call lemmaForallNotContainsForConcat[B]((s... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForConcat                                   precond. (call lemmaForallNotContainsForConcat[B]((s... (require 2/2))                                          valid             U:smt-z3    0.1 
ListUtils.scala:941:50:    lemmaForallNotContainsForConcat                                   non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForSubseq                                   body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForSubseq                                   measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForSubseq                                   postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForSubseq                                   postcondition                                                                                                   valid from cache              0.0 
                           lemmaForallNotContainsForSubseq                                   postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallNotContainsForSubseq                                   precond. (call lemmaForallNotContainsForSubseq[B]((s...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:926:50:    lemmaForallNotContainsForSubseq                                   non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:972:51:    lemmaForallNotContainsNilRefList                                  non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:972:71:    lemmaForallNotContainsNilRefList                                  body assertion: match exhaustiveness                                                                            trivial                       0.0 
ListUtils.scala:972:71:    lemmaForallNotContainsNilRefList                                  measure decreases                                                                                               valid             U:smt-z3    0.1 
ListUtils.scala:972:71:    lemmaForallNotContainsNilRefList                                  postcondition                                                                                                   trivial                       0.0 
ListUtils.scala:972:71:    lemmaForallNotContainsNilRefList                                  postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:972:71:    lemmaForallNotContainsNilRefList                                  postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallNotContainsPreservedAddNewElmtInRefList                body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
                           lemmaForallNotContainsPreservedAddNewElmtInRefList                measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaForallNotContainsPreservedAddNewElmtInRefList                postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallNotContainsPreservedAddNewElmtInRefList                postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallNotContainsPreservedAddNewElmtInRefList                postcondition                                                                                                   valid from cache              0.0 
                           lemmaForallNotContainsPreservedAddNewElmtInRefList                precond. (call lemmaForallNotContainsPreservedAddNew... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaForallNotContainsPreservedAddNewElmtInRefList                precond. (call lemmaForallNotContainsPreservedAddNew... (require 2/2))                                          valid             U:smt-z3    0.1 
ListUtils.scala:964:69:    lemmaForallNotContainsPreservedAddNewElmtInRefList                non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaForallThenDisjunction1                                       body assertion: match exhaustiveness                                                                            valid from cache              0.0 
                           lemmaForallThenDisjunction1                                       measure decreases                                                                                               valid from cache              0.0 
                           lemmaForallThenDisjunction1                                       postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallThenDisjunction1                                       postcondition                                                                                                   valid from cache              0.0 
                           lemmaForallThenDisjunction1                                       postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallThenDisjunction1                                       precond. (call lemmaForallThenDisjunction1[B]((scrut...)                                                        valid from cache              0.0 
ListUtils.scala:791:46:    lemmaForallThenDisjunction1                                       non-negative measure                                                                                            valid from cache              0.0 
                           lemmaForallThenDisjunction2                                       body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.0 
                           lemmaForallThenDisjunction2                                       measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaForallThenDisjunction2                                       postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallThenDisjunction2                                       postcondition                                                                                                   valid from cache              0.0 
                           lemmaForallThenDisjunction2                                       postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaForallThenDisjunction2                                       precond. (call lemmaForallThenDisjunction2[B]((scrut...)                                                        valid             U:smt-z3    0.2 
ListUtils.scala:785:46:    lemmaForallThenDisjunction2                                       non-negative measure                                                                                            valid             U:smt-z3    0.2 
ListUtils.scala:235:7:     lemmaGetIndexBiggerAndHeadEqThenTailContains                      postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:242:13:    lemmaGetIndexBiggerAndHeadEqThenTailContains                      precond. (call head[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:243:13:    lemmaGetIndexBiggerAndHeadEqThenTailContains                      precond. (call getIndex[B](l, e1))                                                                              valid from cache              0.0 
ListUtils.scala:243:31:    lemmaGetIndexBiggerAndHeadEqThenTailContains                      precond. (call getIndex[B](l, e2))                                                                              valid from cache              0.0 
ListUtils.scala:245:15:    lemmaGetIndexBiggerAndHeadEqThenTailContains                      precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
                           lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call lemmaContainsAndNotHdThenTlContains[B... (require 1/2))                                          valid from cache              0.0 
                           lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call lemmaContainsAndNotHdThenTlContains[B... (require 2/2))                                          valid from cache              0.0 
                           lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call lemmaGetIndexBiggerAndHeadEqThenTailC... (require 1/4))                                          valid             U:smt-z3    0.1 
                           lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call lemmaGetIndexBiggerAndHeadEqThenTailC... (require 2/4))                                          valid from cache              0.0 
                           lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call lemmaGetIndexBiggerAndHeadEqThenTailC... (require 3/4))                                          valid from cache              0.0 
                           lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call lemmaGetIndexBiggerAndHeadEqThenTailC... (require 4/4))                                          valid from cache              0.0 
                           lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call lemmaGetIndexBiggerAndHeadNotEqThenTa... (require 1/3))                                          valid             U:smt-z3    0.1 
                           lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call lemmaGetIndexBiggerAndHeadNotEqThenTa... (require 2/3))                                          valid from cache              0.0 
                           lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call lemmaGetIndexBiggerAndHeadNotEqThenTa... (require 3/3))                                          valid from cache              0.0 
                           lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 1/2))                                          valid             U:smt-z3    0.2 
                           lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 1/2))                                          valid             U:smt-z3    0.2 
                           lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 2/2))                                          valid from cache              0.0 
                           lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 2/2))                                          valid from cache              0.0 
ListUtils.scala:195:13:    lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call getIndex[B](l, e1))                                                                              valid             U:smt-z3    0.1 
ListUtils.scala:195:31:    lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call getIndex[B](l, e2))                                                                              valid from cache              0.0 
ListUtils.scala:198:5:     lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:200:9:     lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion: Inlined precondition (1/4) of lemmaGetIndexBiggerAndHeadEqThenTailContains                      valid from cache              0.0 
ListUtils.scala:200:9:     lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion: Inlined precondition (2/4) of lemmaGetIndexBiggerAndHeadEqThenTailContains                      valid from cache              0.0 
ListUtils.scala:200:9:     lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion: Inlined precondition (3/4) of lemmaGetIndexBiggerAndHeadEqThenTailContains                      valid             U:smt-z3    0.2 
ListUtils.scala:200:9:     lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion: Inlined precondition (4/4) of lemmaGetIndexBiggerAndHeadEqThenTailContains                      valid from cache              0.0 
ListUtils.scala:202:16:    lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion                                                                                                  valid from cache              0.0 
ListUtils.scala:204:9:     lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion: Inlined precondition (1/2) of lemmaContainsAndNotHdThenTlContains                               valid from cache              0.0 
ListUtils.scala:204:9:     lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion: Inlined precondition (2/2) of lemmaContainsAndNotHdThenTlContains                               valid             U:smt-z3    0.1 
ListUtils.scala:205:9:     lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion: Inlined precondition (1/2) of lemmaNotHeadSoGetIndexTailIsMinusOne                              valid from cache              0.0 
ListUtils.scala:205:9:     lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion: Inlined precondition (2/2) of lemmaNotHeadSoGetIndexTailIsMinusOne                              valid             U:smt-z3    0.2 
ListUtils.scala:206:9:     lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion: Inlined precondition (1/2) of lemmaNotHeadSoGetIndexTailIsMinusOne                              valid from cache              0.0 
ListUtils.scala:206:9:     lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion: Inlined precondition (2/2) of lemmaNotHeadSoGetIndexTailIsMinusOne                              valid             U:smt-z3    0.2 
ListUtils.scala:208:9:     lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion: Inlined precondition (1/3) of lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   valid             U:smt-z3    0.2 
ListUtils.scala:208:9:     lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion: Inlined precondition (2/3) of lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   valid             U:smt-z3    0.2 
ListUtils.scala:208:9:     lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion: Inlined precondition (3/3) of lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   valid             U:smt-z3    0.3 
ListUtils.scala:210:21:    lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion: Inlined precondition of check                                                                   valid             U:smt-z3    0.2 
ListUtils.scala:212:5:     lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:212:12:    lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   body assertion                                                                                                  valid             U:smt-z3    0.4 
ListUtils.scala:212:12:    lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.2 
ListUtils.scala:214:15:    lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   non-negative measure                                                                                            valid             U:smt-z3    0.2 
ListUtils.scala:214:15:    lemmaGetIndexBiggerAndHeadNotEqThenTailContains                   precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.2 
                           lemmaGetSuffixOnListWithItSelfIsEmpty                             measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaGetSuffixOnListWithItSelfIsEmpty                             precond. (call lemmaIsPrefixRefl[B](l1, l2))                                                                    trivial                       0.0 
ListUtils.scala:514:5:     lemmaGetSuffixOnListWithItSelfIsEmpty                             body assertion: Inlined precondition of lemmaIsPrefixRefl                                                       trivial                       0.0 
ListUtils.scala:516:5:     lemmaGetSuffixOnListWithItSelfIsEmpty                             body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:516:5:     lemmaGetSuffixOnListWithItSelfIsEmpty                             postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:517:28:    lemmaGetSuffixOnListWithItSelfIsEmpty                             postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:518:28:    lemmaGetSuffixOnListWithItSelfIsEmpty                             postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:520:15:    lemmaGetSuffixOnListWithItSelfIsEmpty                             precond. (call getSuffix[B](l, l) (require 1/2))                                                                valid             U:smt-z3    0.0 
ListUtils.scala:520:15:    lemmaGetSuffixOnListWithItSelfIsEmpty                             precond. (call getSuffix[B](l, l) (require 1/2))                                                                valid             U:smt-z3    0.0 
ListUtils.scala:520:15:    lemmaGetSuffixOnListWithItSelfIsEmpty                             precond. (call getSuffix[B](l, l) (require 1/2))                                                                valid             U:smt-z3    0.1 
ListUtils.scala:520:15:    lemmaGetSuffixOnListWithItSelfIsEmpty                             precond. (call getSuffix[B](l, l) (require 2/2))                                                                valid from cache              0.0 
ListUtils.scala:520:15:    lemmaGetSuffixOnListWithItSelfIsEmpty                             precond. (call getSuffix[B](l, l) (require 2/2))                                                                valid from cache              0.0 
ListUtils.scala:520:15:    lemmaGetSuffixOnListWithItSelfIsEmpty                             precond. (call getSuffix[B](l, l) (require 2/2))                                                                valid from cache              0.0 
ListUtils.scala:520:28:    lemmaGetSuffixOnListWithItSelfIsEmpty                             non-negative measure                                                                                            valid from cache              0.0 
                           lemmaIsPrefixRefl                                                 measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaIsPrefixRefl                                                 non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaIsPrefixRefl                                                 precond. (call lemmaIsPrefixRefl[B](l1, l2))                                                                    trivial                       0.0 
ListUtils.scala:264:5:     lemmaIsPrefixRefl                                                 body assertion: match exhaustiveness                                                                            trivial                       0.0 
ListUtils.scala:264:5:     lemmaIsPrefixRefl                                                 postcondition                                                                                                   trivial                       0.0 
ListUtils.scala:265:28:    lemmaIsPrefixRefl                                                 body assertion: Inlined precondition of lemmaIsPrefixRefl                                                       valid             U:smt-z3    0.1 
ListUtils.scala:265:28:    lemmaIsPrefixRefl                                                 postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:265:50:    lemmaIsPrefixRefl                                                 precond. (call tail[B](l2))                                                                                     valid             U:smt-z3    0.1 
ListUtils.scala:266:28:    lemmaIsPrefixRefl                                                 postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaIsPrefixSameLengthThenSameList                               measure decreases                                                                                               valid             U:smt-z3    0.2 
                           lemmaIsPrefixSameLengthThenSameList                               precond. (call lemmaIsPrefixSameLengthThenSameList[B... (require 1/3))                                          valid             U:smt-z3    0.1 
                           lemmaIsPrefixSameLengthThenSameList                               precond. (call lemmaIsPrefixSameLengthThenSameList[B... (require 2/3))                                          valid from cache              0.0 
                           lemmaIsPrefixSameLengthThenSameList                               precond. (call lemmaIsPrefixSameLengthThenSameList[B... (require 3/3))                                          valid from cache              0.0 
ListUtils.scala:423:5:     lemmaIsPrefixSameLengthThenSameList                               body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:423:5:     lemmaIsPrefixSameLengthThenSameList                               postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:425:9:     lemmaIsPrefixSameLengthThenSameList                               body assertion: Inlined precondition (1/3) of lemmaIsPrefixSameLengthThenSameList                               valid             U:smt-z3    0.1 
ListUtils.scala:425:9:     lemmaIsPrefixSameLengthThenSameList                               body assertion: Inlined precondition (2/3) of lemmaIsPrefixSameLengthThenSameList                               valid             U:smt-z3    0.1 
ListUtils.scala:425:9:     lemmaIsPrefixSameLengthThenSameList                               body assertion: Inlined precondition (3/3) of lemmaIsPrefixSameLengthThenSameList                               valid             U:smt-z3    0.1 
ListUtils.scala:425:9:     lemmaIsPrefixSameLengthThenSameList                               postcondition                                                                                                   valid             U:smt-z3    0.2 
ListUtils.scala:425:49:    lemmaIsPrefixSameLengthThenSameList                               precond. (call tail[B](p2))                                                                                     valid             U:smt-z3    0.1 
ListUtils.scala:425:58:    lemmaIsPrefixSameLengthThenSameList                               non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:425:58:    lemmaIsPrefixSameLengthThenSameList                               precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:426:21:    lemmaIsPrefixSameLengthThenSameList                               postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaIsPrefixThenSmallerEqSize                                    measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaIsPrefixThenSmallerEqSize                                    precond. (call lemmaIsPrefixThenSmallerEqSize[B](p, l))                                                         valid             U:smt-z3    0.1 
ListUtils.scala:491:26:    lemmaIsPrefixThenSmallerEqSize                                    postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:492:26:    lemmaIsPrefixThenSmallerEqSize                                    postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:493:26:    lemmaIsPrefixThenSmallerEqSize                                    body assertion: Inlined precondition of lemmaIsPrefixThenSmallerEqSize                                          valid             U:smt-z3    0.1 
ListUtils.scala:493:26:    lemmaIsPrefixThenSmallerEqSize                                    postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:493:57:    lemmaIsPrefixThenSmallerEqSize                                    precond. (call tail[B](scrut._1))                                                                               valid             U:smt-z3    0.1 
ListUtils.scala:493:66:    lemmaIsPrefixThenSmallerEqSize                                    precond. (call tail[B](scrut._2))                                                                               valid             U:smt-z3    0.1 
ListUtils.scala:495:25:    lemmaIsPrefixThenSmallerEqSize                                    non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaIsSuffixThenSubseq                                           measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaIsSuffixThenSubseq                                           precond. (call lemmaIsSuffixThenSubseq[B](l1, l2))                                                              valid from cache              0.0 
ListUtils.scala:99:15:     lemmaIsSuffixThenSubseq                                           non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:101:56:    lemmaIsSuffixThenSubseq                                           body assertion: Inlined precondition of lemmaIsSuffixThenSubseq                                                 valid from cache              0.0 
ListUtils.scala:101:56:    lemmaIsSuffixThenSubseq                                           postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:102:56:    lemmaIsSuffixThenSubseq                                           postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:103:56:    lemmaIsSuffixThenSubseq                                           postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaIsSuffixThenTailIsSuffix                                     measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaIsSuffixThenTailIsSuffix                                     precond. (call lemmaIsSuffixThenTailIsSuffix[B](l, s...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:113:15:    lemmaIsSuffixThenTailIsSuffix                                     non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:114:5:     lemmaIsSuffixThenTailIsSuffix                                     body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:114:5:     lemmaIsSuffixThenTailIsSuffix                                     postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:115:59:    lemmaIsSuffixThenTailIsSuffix                                     body assertion: Inlined precondition of lemmaIsSuffixThenTailIsSuffix                                           valid             U:smt-z3    0.1 
ListUtils.scala:115:59:    lemmaIsSuffixThenTailIsSuffix                                     postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:117:16:    lemmaIsSuffixThenTailIsSuffix                                     body assertion                                                                                                  valid from cache              0.0 
ListUtils.scala:119:11:    lemmaIsSuffixThenTailIsSuffix                                     postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:119:18:    lemmaIsSuffixThenTailIsSuffix                                     body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:122:11:    lemmaIsSuffixThenTailIsSuffix                                     postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:122:18:    lemmaIsSuffixThenTailIsSuffix                                     body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:122:18:    lemmaIsSuffixThenTailIsSuffix                                     precond. (call head[B](suffix))                                                                                 valid             U:smt-z3    0.1 
ListUtils.scala:122:33:    lemmaIsSuffixThenTailIsSuffix                                     precond. (call head[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:123:18:    lemmaIsSuffixThenTailIsSuffix                                     body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:123:18:    lemmaIsSuffixThenTailIsSuffix                                     precond. (call tail[B](suffix))                                                                                 valid             U:smt-z3    0.1 
ListUtils.scala:123:33:    lemmaIsSuffixThenTailIsSuffix                                     precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:124:18:    lemmaIsSuffixThenTailIsSuffix                                     body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:124:27:    lemmaIsSuffixThenTailIsSuffix                                     precond. (call tail[B](suffix))                                                                                 valid             U:smt-z3    0.1 
ListUtils.scala:130:42:    lemmaIsSuffixThenTailIsSuffix                                     precond. (call tail[B](suffix))                                                                                 valid             U:smt-z3    0.1 
ListUtils.scala:130:42:    lemmaIsSuffixThenTailIsSuffix                                     precond. (call tail[B](suffix))                                                                                 valid             U:smt-z3    0.1 
ListUtils.scala:130:42:    lemmaIsSuffixThenTailIsSuffix                                     precond. (call tail[B](suffix))                                                                                 valid             U:smt-z3    0.1 
ListUtils.scala:130:42:    lemmaIsSuffixThenTailIsSuffix                                     precond. (call tail[B](suffix))                                                                                 valid             U:smt-z3    0.1 
                           lemmaListContainsThenFilterContainsNotEmpty                       measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaListContainsThenFilterContainsNotEmpty                       precond. (call lemmaListContainsThenFilterContainsNo... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaListContainsThenFilterContainsNotEmpty                       precond. (call lemmaListContainsThenFilterContainsNo... (require 2/2))                                          valid from cache              0.0 
ListUtils.scala:1151:15:   lemmaListContainsThenFilterContainsNotEmpty                       non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:1152:5:    lemmaListContainsThenFilterContainsNotEmpty                       body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:1152:5:    lemmaListContainsThenFilterContainsNotEmpty                       postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:1155:11:   lemmaListContainsThenFilterContainsNotEmpty                       body assertion: Inlined precondition (1/2) of lemmaListContainsThenFilterContainsNotEmpty                       valid             U:smt-z3    0.1 
ListUtils.scala:1155:11:   lemmaListContainsThenFilterContainsNotEmpty                       body assertion: Inlined precondition (2/2) of lemmaListContainsThenFilterContainsNotEmpty                       valid from cache              0.0 
ListUtils.scala:1155:11:   lemmaListContainsThenFilterContainsNotEmpty                       postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:1156:10:   lemmaListContainsThenFilterContainsNotEmpty                       postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:1158:21:   lemmaListContainsThenFilterContainsNotEmpty                       body assertion: Inlined precondition of check                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:1158:21:   lemmaListContainsThenFilterContainsNotEmpty                       postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaListNotContainsThenFilterContainsEmpty                       measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaListNotContainsThenFilterContainsEmpty                       precond. (call lemmaListNotContainsThenFilterContain... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaListNotContainsThenFilterContainsEmpty                       precond. (call lemmaListNotContainsThenFilterContain... (require 2/2))                                          valid from cache              0.0 
ListUtils.scala:1167:15:   lemmaListNotContainsThenFilterContainsEmpty                       non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:1168:5:    lemmaListNotContainsThenFilterContainsEmpty                       body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:1168:5:    lemmaListNotContainsThenFilterContainsEmpty                       postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:1170:9:    lemmaListNotContainsThenFilterContainsEmpty                       body assertion: Inlined precondition (1/2) of lemmaListNotContainsThenFilterContainsEmpty                       valid             U:smt-z3    0.1 
ListUtils.scala:1170:9:    lemmaListNotContainsThenFilterContainsEmpty                       body assertion: Inlined precondition (2/2) of lemmaListNotContainsThenFilterContainsEmpty                       valid from cache              0.0 
ListUtils.scala:1170:9:    lemmaListNotContainsThenFilterContainsEmpty                       postcondition                                                                                                   valid             U:smt-z3    0.3 
ListUtils.scala:1172:21:   lemmaListNotContainsThenFilterContainsEmpty                       postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                precond. (call lemmaLongerPrefixContainsHeadOfSuffix... (require 1/4))                                          valid             U:smt-z3    0.1 
                           lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                precond. (call lemmaLongerPrefixContainsHeadOfSuffix... (require 2/4))                                          valid from cache              0.0 
                           lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                precond. (call lemmaLongerPrefixContainsHeadOfSuffix... (require 3/4))                                          valid from cache              0.0 
                           lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                precond. (call lemmaLongerPrefixContainsHeadOfSuffix... (require 4/4))                                          valid from cache              0.0 
ListUtils.scala:296:5:     lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:296:5:     lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:298:9:     lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                body assertion: Inlined precondition (1/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                valid             U:smt-z3    0.1 
ListUtils.scala:298:9:     lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                body assertion: Inlined precondition (2/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                valid             U:smt-z3    0.1 
ListUtils.scala:298:9:     lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                body assertion: Inlined precondition (3/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                valid             U:smt-z3    0.1 
ListUtils.scala:298:9:     lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                body assertion: Inlined precondition (4/4) of lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                valid             U:smt-z3    0.1 
ListUtils.scala:298:9:     lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:301:11:    lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                precond. (call tail[B](p2))                                                                                     valid             U:smt-z3    0.1 
ListUtils.scala:302:11:    lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:302:11:    lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:304:21:    lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:306:27:    lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                precond. (call head[B](s1))                                                                                     valid             U:smt-z3    0.1 
ListUtils.scala:306:27:    lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                precond. (call head[B](s1))                                                                                     valid             U:smt-z3    0.1 
ListUtils.scala:306:27:    lemmaLongerPrefixContainsHeadOfSuffixOfSmallerPref                precond. (call head[B](s1))                                                                                     valid             U:smt-z3    0.1 
                           lemmaMoveElementToOtherListKeepsConcatEq                          measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaMoveElementToOtherListKeepsConcatEq                          precond. (call lemmaMoveElementToOtherListKeepsConca...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:533:5:     lemmaMoveElementToOtherListKeepsConcatEq                          body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:533:5:     lemmaMoveElementToOtherListKeepsConcatEq                          postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:535:9:     lemmaMoveElementToOtherListKeepsConcatEq                          body assertion: Inlined precondition of lemmaMoveElementToOtherListKeepsConcatEq                                valid             U:smt-z3    0.1 
ListUtils.scala:535:9:     lemmaMoveElementToOtherListKeepsConcatEq                          postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:535:65:    lemmaMoveElementToOtherListKeepsConcatEq                          precond. (call tail[B](tot))                                                                                    valid             U:smt-z3    0.1 
ListUtils.scala:536:21:    lemmaMoveElementToOtherListKeepsConcatEq                          postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:539:43:    lemmaMoveElementToOtherListKeepsConcatEq                          non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaNoDuplicateConcatThenForallNotContains                       body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
                           lemmaNoDuplicateConcatThenForallNotContains                       measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaNoDuplicateConcatThenForallNotContains                       postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaNoDuplicateConcatThenForallNotContains                       postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaNoDuplicateConcatThenForallNotContains                       postcondition                                                                                                   valid from cache              0.0 
                           lemmaNoDuplicateConcatThenForallNotContains                       precond. (call lemmaNoDuplicateConcatThenForallNotCo...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:957:62:    lemmaNoDuplicateConcatThenForallNotContains                       non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaForallContainsAndNoDuplicateThen... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaForallContainsAndNoDuplicateThen... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaForallContainsAndNoDuplicateThen... (require 2/2))                                          valid             U:smt-z3    0.1 
                           lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaForallContainsAndNoDuplicateThen... (require 2/2))                                          valid             U:smt-z3    0.1 
                           lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaForallContainsPreservedRemoveElm... (require 1/3))                                          valid             U:smt-z3    0.1 
                           lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaForallContainsPreservedRemoveElm... (require 2/3))                                          valid             U:smt-z3    0.1 
                           lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaForallContainsPreservedRemoveElm... (require 3/3))                                          valid from cache              0.0 
                           lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaForallContainsPreservedRemoveElm...)                                                        valid             U:smt-z3    0.1 
                           lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)                                                        valid             U:smt-z3    0.2 
                           lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 2/2))                                          valid from cache              0.0 
                           lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaRemoveOneElmtPreservesNoDuplicat...)                                                        valid             U:smt-z3    0.1 
                           lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaSubsetContentThenForallContains[...)                                                        valid             U:smt-z3    0.1 
                           lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaSubsetContentThenForallContains[...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:1065:5:    lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition of lemmaSubsetContentThenForallContains                                    valid             U:smt-z3    0.1 
ListUtils.scala:1066:5:    lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition of lemmaSubsetContentThenForallContains                                    valid             U:smt-z3    0.1 
ListUtils.scala:1067:12:   lemmaNoDuplicatePreservedSameContent                              body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:1068:12:   lemmaNoDuplicatePreservedSameContent                              body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:1069:5:    lemmaNoDuplicatePreservedSameContent                              body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:1072:16:   lemmaNoDuplicatePreservedSameContent                              body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:1074:9:    lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition of lemmaRemoveOneElmtPreservesNoDuplicate                                  valid from cache              0.0 
ListUtils.scala:1075:9:    lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition (1/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         valid from cache              0.0 
ListUtils.scala:1075:9:    lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition (2/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         valid from cache              0.0 
ListUtils.scala:1077:16:   lemmaNoDuplicatePreservedSameContent                              body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:1078:9:    lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition of lemmaForallContainsPreservedRemoveElmt                                  valid             U:smt-z3    0.1 
ListUtils.scala:1079:16:   lemmaNoDuplicatePreservedSameContent                              body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:1080:9:    lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList                  valid             U:smt-z3    0.1 
ListUtils.scala:1080:9:    lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList                  valid             U:smt-z3    0.1 
ListUtils.scala:1081:16:   lemmaNoDuplicatePreservedSameContent                              body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:1082:16:   lemmaNoDuplicatePreservedSameContent                              body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:1083:16:   lemmaNoDuplicatePreservedSameContent                              body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:1084:16:   lemmaNoDuplicatePreservedSameContent                              body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:1086:9:    lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition (1/3) of lemmaForallContainsPreservedRemoveElmtInRefList                   valid             U:smt-z3    0.1 
ListUtils.scala:1086:9:    lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition (2/3) of lemmaForallContainsPreservedRemoveElmtInRefList                   valid             U:smt-z3    0.1 
ListUtils.scala:1086:9:    lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition (3/3) of lemmaForallContainsPreservedRemoveElmtInRefList                   valid from cache              0.0 
ListUtils.scala:1087:9:    lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition of check                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:1088:9:    lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition (1/2) of lemmaForallContainsAndNoDuplicateThenSmallerList                  valid             U:smt-z3    0.1 
ListUtils.scala:1088:9:    lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition (2/2) of lemmaForallContainsAndNoDuplicateThenSmallerList                  valid             U:smt-z3    0.1 
ListUtils.scala:1089:16:   lemmaNoDuplicatePreservedSameContent                              body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:1091:11:   lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition of lemmaRemoveElmtContainedSizeSmaller                                     valid from cache              0.0 
ListUtils.scala:1092:18:   lemmaNoDuplicatePreservedSameContent                              body assertion                                                                                                  valid             U:smt-z3    0.2 
ListUtils.scala:1093:18:   lemmaNoDuplicatePreservedSameContent                              body assertion                                                                                                  valid             U:smt-z3    0.2 
ListUtils.scala:1094:18:   lemmaNoDuplicatePreservedSameContent                              body assertion                                                                                                  valid             U:smt-z3    0.2 
ListUtils.scala:1095:11:   lemmaNoDuplicatePreservedSameContent                              body assertion: Inlined precondition of check                                                                   valid from cache              0.0 
ListUtils.scala:1098:9:    lemmaNoDuplicatePreservedSameContent                              measure decreases                                                                                               valid             U:smt-z3    0.2 
ListUtils.scala:1098:9:    lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaNoDuplicatePreservedSameContent[... (require 1/3))                                          valid             U:smt-z3    0.2 
ListUtils.scala:1098:9:    lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaNoDuplicatePreservedSameContent[... (require 2/3))                                          valid             U:smt-z3    0.3 
ListUtils.scala:1098:9:    lemmaNoDuplicatePreservedSameContent                              precond. (call lemmaNoDuplicatePreservedSameContent[... (require 3/3))                                          valid             U:smt-z3    0.4 
ListUtils.scala:1101:15:   lemmaNoDuplicatePreservedSameContent                              postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:1101:15:   lemmaNoDuplicatePreservedSameContent                              postcondition                                                                                                   valid             U:smt-z3    0.3 
ListUtils.scala:1101:15:   lemmaNoDuplicatePreservedSameContent                              postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:1101:37:   lemmaNoDuplicatePreservedSameContent                              non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaNotHeadSoGetIndexTailIsMinusOne                              measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaNotHeadSoGetIndexTailIsMinusOne                              precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaNotHeadSoGetIndexTailIsMinusOne                              precond. (call lemmaNotHeadSoGetIndexTailIsMinusOne[... (require 2/2))                                          valid from cache              0.0 
ListUtils.scala:251:13:    lemmaNotHeadSoGetIndexTailIsMinusOne                              precond. (call head[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:254:9:     lemmaNotHeadSoGetIndexTailIsMinusOne                              precond. (call head[B](tail[B](l)))                                                                             valid             U:smt-z3    0.2 
ListUtils.scala:254:9:     lemmaNotHeadSoGetIndexTailIsMinusOne                              precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:255:7:     lemmaNotHeadSoGetIndexTailIsMinusOne                              body assertion: Inlined precondition (1/2) of lemmaNotHeadSoGetIndexTailIsMinusOne                              valid             U:smt-z3    0.1 
ListUtils.scala:255:7:     lemmaNotHeadSoGetIndexTailIsMinusOne                              body assertion: Inlined precondition (2/2) of lemmaNotHeadSoGetIndexTailIsMinusOne                              valid from cache              0.0 
ListUtils.scala:255:7:     lemmaNotHeadSoGetIndexTailIsMinusOne                              postcondition                                                                                                   valid             U:smt-z3    0.2 
ListUtils.scala:255:44:    lemmaNotHeadSoGetIndexTailIsMinusOne                              precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:256:6:     lemmaNotHeadSoGetIndexTailIsMinusOne                              postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:257:15:    lemmaNotHeadSoGetIndexTailIsMinusOne                              precond. (call getIndex[B](l, e))                                                                               valid             U:smt-z3    0.1 
ListUtils.scala:257:15:    lemmaNotHeadSoGetIndexTailIsMinusOne                              precond. (call getIndex[B](l, e))                                                                               valid             U:smt-z3    0.1 
ListUtils.scala:257:33:    lemmaNotHeadSoGetIndexTailIsMinusOne                              precond. (call getIndex[B](tail[B](l), e))                                                                      valid from cache              0.0 
ListUtils.scala:257:33:    lemmaNotHeadSoGetIndexTailIsMinusOne                              precond. (call getIndex[B](tail[B](l), e))                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:257:42:    lemmaNotHeadSoGetIndexTailIsMinusOne                              non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:257:42:    lemmaNotHeadSoGetIndexTailIsMinusOne                              precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:257:42:    lemmaNotHeadSoGetIndexTailIsMinusOne                              precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.2 
                           lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  precond. (call lemmaPrefixFromSameListAndStrictlySma... (require 1/3))                                          valid             U:smt-z3    0.1 
                           lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  precond. (call lemmaPrefixFromSameListAndStrictlySma... (require 2/3))                                          valid from cache              0.0 
                           lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  precond. (call lemmaPrefixFromSameListAndStrictlySma... (require 3/3))                                          valid from cache              0.0 
ListUtils.scala:553:5:     lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:553:5:     lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:555:9:     lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  body assertion: Inlined precondition (1/3) of lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  valid             U:smt-z3    0.1 
ListUtils.scala:555:9:     lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  body assertion: Inlined precondition (2/3) of lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  valid             U:smt-z3    0.1 
ListUtils.scala:555:9:     lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  body assertion: Inlined precondition (3/3) of lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  valid             U:smt-z3    0.1 
ListUtils.scala:555:9:     lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:556:11:    lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  precond. (call tail[B](s1))                                                                                     valid             U:smt-z3    0.3 
ListUtils.scala:558:11:    lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:558:11:    lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:560:18:    lemmaPrefixFromSameListAndStrictlySmallerThenPrefixFromEachOther  postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaPrefixStaysPrefixWhenAddingToSuffix                          measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaPrefixStaysPrefixWhenAddingToSuffix                          precond. (call lemmaPrefixStaysPrefixWhenAddingToSuf...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:398:5:     lemmaPrefixStaysPrefixWhenAddingToSuffix                          body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.0 
ListUtils.scala:398:5:     lemmaPrefixStaysPrefixWhenAddingToSuffix                          postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:400:9:     lemmaPrefixStaysPrefixWhenAddingToSuffix                          body assertion: Inlined precondition of lemmaPrefixStaysPrefixWhenAddingToSuffix                                valid             U:smt-z3    0.1 
ListUtils.scala:400:9:     lemmaPrefixStaysPrefixWhenAddingToSuffix                          postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:400:54:    lemmaPrefixStaysPrefixWhenAddingToSuffix                          precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:401:21:    lemmaPrefixStaysPrefixWhenAddingToSuffix                          postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:403:27:    lemmaPrefixStaysPrefixWhenAddingToSuffix                          non-negative measure                                                                                            valid from cache              0.0 
                           lemmaRemoveElmtContainedSizeSmaller                               measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaRemoveElmtContainedSizeSmaller                               measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaRemoveElmtContainedSizeSmaller                               precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)                                                        valid             U:smt-z3    0.0 
                           lemmaRemoveElmtContainedSizeSmaller                               precond. (call lemmaRemoveElmtContainedSizeSmaller[B...)                                                        valid             U:smt-z3    0.0 
ListUtils.scala:989:5:     lemmaRemoveElmtContainedSizeSmaller                               body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:989:5:     lemmaRemoveElmtContainedSizeSmaller                               postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:991:16:    lemmaRemoveElmtContainedSizeSmaller                               body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:993:11:    lemmaRemoveElmtContainedSizeSmaller                               body assertion: Inlined precondition of lemmaRemoveElmtContainedSizeSmaller                                     valid from cache              0.0 
ListUtils.scala:993:11:    lemmaRemoveElmtContainedSizeSmaller                               postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:994:10:    lemmaRemoveElmtContainedSizeSmaller                               postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:996:28:    lemmaRemoveElmtContainedSizeSmaller                               body assertion: Inlined precondition of lemmaRemoveElmtContainedSizeSmaller                                     valid             U:smt-z3    0.1 
ListUtils.scala:996:28:    lemmaRemoveElmtContainedSizeSmaller                               postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:997:28:    lemmaRemoveElmtContainedSizeSmaller                               body assertion: Inlined precondition of check                                                                   valid             U:smt-z3    0.0 
ListUtils.scala:997:28:    lemmaRemoveElmtContainedSizeSmaller                               postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:999:30:    lemmaRemoveElmtContainedSizeSmaller                               non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaRemoveLastConcatenatedPrefixStillPrefix                      measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaRemoveLastConcatenatedPrefixStillPrefix                      precond. (call lemmaRemoveLastConcatenatedPrefixStil...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:366:5:     lemmaRemoveLastConcatenatedPrefixStillPrefix                      body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:366:5:     lemmaRemoveLastConcatenatedPrefixStillPrefix                      postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:368:9:     lemmaRemoveLastConcatenatedPrefixStillPrefix                      body assertion: Inlined precondition of lemmaRemoveLastConcatenatedPrefixStillPrefix                            valid             U:smt-z3    0.1 
ListUtils.scala:368:9:     lemmaRemoveLastConcatenatedPrefixStillPrefix                      postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:368:64:    lemmaRemoveLastConcatenatedPrefixStillPrefix                      precond. (call tail[B](tot))                                                                                    valid             U:smt-z3    0.1 
ListUtils.scala:369:21:    lemmaRemoveLastConcatenatedPrefixStillPrefix                      postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:371:24:    lemmaRemoveLastConcatenatedPrefixStillPrefix                      non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaRemoveLastFromBothSidePreservesEq                            measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaRemoveLastFromBothSidePreservesEq                            precond. (call lemmaRemoveLastFromBothSidePreservesE... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaRemoveLastFromBothSidePreservesEq                            precond. (call lemmaRemoveLastFromBothSidePreservesE... (require 2/2))                                          valid from cache              0.0 
ListUtils.scala:442:5:     lemmaRemoveLastFromBothSidePreservesEq                            body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:442:5:     lemmaRemoveLastFromBothSidePreservesEq                            postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:443:28:    lemmaRemoveLastFromBothSidePreservesEq                            body assertion: Inlined precondition (1/2) of lemmaRemoveLastFromBothSidePreservesEq                            valid             U:smt-z3    0.1 
ListUtils.scala:443:28:    lemmaRemoveLastFromBothSidePreservesEq                            body assertion: Inlined precondition (2/2) of lemmaRemoveLastFromBothSidePreservesEq                            valid from cache              0.0 
ListUtils.scala:443:28:    lemmaRemoveLastFromBothSidePreservesEq                            postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:443:74:    lemmaRemoveLastFromBothSidePreservesEq                            precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:444:28:    lemmaRemoveLastFromBothSidePreservesEq                            postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:446:20:    lemmaRemoveLastFromBothSidePreservesEq                            precond. (call removeLast[B](s))                                                                                valid from cache              0.0 
ListUtils.scala:446:20:    lemmaRemoveLastFromBothSidePreservesEq                            precond. (call removeLast[B](s))                                                                                valid             U:smt-z3    0.1 
ListUtils.scala:446:20:    lemmaRemoveLastFromBothSidePreservesEq                            precond. (call removeLast[B](s))                                                                                valid             U:smt-z3    0.1 
ListUtils.scala:446:37:    lemmaRemoveLastFromBothSidePreservesEq                            precond. (call removeLast[B](l))                                                                                valid from cache              0.0 
ListUtils.scala:446:37:    lemmaRemoveLastFromBothSidePreservesEq                            precond. (call removeLast[B](l))                                                                                valid             U:smt-z3    0.1 
ListUtils.scala:446:37:    lemmaRemoveLastFromBothSidePreservesEq                            precond. (call removeLast[B](l))                                                                                valid             U:smt-z3    0.1 
ListUtils.scala:446:48:    lemmaRemoveLastFromBothSidePreservesEq                            non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaRemoveLastFromLMakesItPrefix                                 measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaRemoveLastFromLMakesItPrefix                                 precond. (call lemmaRemoveLastFromLMakesItPrefix[B](l))                                                         trivial                       0.0 
ListUtils.scala:454:5:     lemmaRemoveLastFromLMakesItPrefix                                 body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:454:5:     lemmaRemoveLastFromLMakesItPrefix                                 postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:455:31:    lemmaRemoveLastFromLMakesItPrefix                                 postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:456:31:    lemmaRemoveLastFromLMakesItPrefix                                 body assertion: Inlined precondition of lemmaRemoveLastFromLMakesItPrefix                                       valid             U:smt-z3    0.1 
ListUtils.scala:456:31:    lemmaRemoveLastFromLMakesItPrefix                                 postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:459:24:    lemmaRemoveLastFromLMakesItPrefix                                 precond. (call removeLast[B](l))                                                                                trivial                       0.0 
ListUtils.scala:459:24:    lemmaRemoveLastFromLMakesItPrefix                                 precond. (call removeLast[B](l))                                                                                trivial                       0.0 
ListUtils.scala:459:24:    lemmaRemoveLastFromLMakesItPrefix                                 precond. (call removeLast[B](l))                                                                                valid             U:smt-z3    0.1 
ListUtils.scala:459:39:    lemmaRemoveLastFromLMakesItPrefix                                 non-negative measure                                                                                            valid             U:smt-z3    0.0 
ListUtils.scala:407:7:     lemmaRemoveLastPrefixDecreasesSize                                postcondition                                                                                                   valid             U:smt-z3    0.2 
ListUtils.scala:409:15:    lemmaRemoveLastPrefixDecreasesSize                                precond. (call removeLast[B](l))                                                                                valid             U:smt-z3    0.1 
                           lemmaRemoveLastPrefixStillPrefix                                  measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaRemoveLastPrefixStillPrefix                                  precond. (call lemmaRemoveLastPrefixStillPrefix[B](p... (require 1/3))                                          valid             U:smt-z3    0.1 
                           lemmaRemoveLastPrefixStillPrefix                                  precond. (call lemmaRemoveLastPrefixStillPrefix[B](p... (require 2/3))                                          valid from cache              0.0 
                           lemmaRemoveLastPrefixStillPrefix                                  precond. (call lemmaRemoveLastPrefixStillPrefix[B](p... (require 3/3))                                          valid from cache              0.0 
ListUtils.scala:381:5:     lemmaRemoveLastPrefixStillPrefix                                  body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:381:5:     lemmaRemoveLastPrefixStillPrefix                                  postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:382:28:    lemmaRemoveLastPrefixStillPrefix                                  body assertion: Inlined precondition (1/3) of lemmaRemoveLastPrefixStillPrefix                                  valid             U:smt-z3    0.1 
ListUtils.scala:382:28:    lemmaRemoveLastPrefixStillPrefix                                  body assertion: Inlined precondition (2/3) of lemmaRemoveLastPrefixStillPrefix                                  valid             U:smt-z3    0.1 
ListUtils.scala:382:28:    lemmaRemoveLastPrefixStillPrefix                                  body assertion: Inlined precondition (3/3) of lemmaRemoveLastPrefixStillPrefix                                  valid             U:smt-z3    0.1 
ListUtils.scala:382:28:    lemmaRemoveLastPrefixStillPrefix                                  postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:382:65:    lemmaRemoveLastPrefixStillPrefix                                  precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:383:28:    lemmaRemoveLastPrefixStillPrefix                                  postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:386:27:    lemmaRemoveLastPrefixStillPrefix                                  precond. (call removeLast[B](l))                                                                                valid from cache              0.0 
ListUtils.scala:386:27:    lemmaRemoveLastPrefixStillPrefix                                  precond. (call removeLast[B](l))                                                                                valid             U:smt-z3    0.1 
ListUtils.scala:386:27:    lemmaRemoveLastPrefixStillPrefix                                  precond. (call removeLast[B](l))                                                                                valid             U:smt-z3    0.1 
ListUtils.scala:386:38:    lemmaRemoveLastPrefixStillPrefix                                  non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 1/2))                                          valid             U:smt-z3    0.1 
                           lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         precond. (call lemmaRemoveOneElmtNoDuplicateSizeMinu... (require 2/2))                                          valid from cache              0.0 
                           lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         precond. (call lemmaRemoveOneElmtNotContainedSameLis...)                                                        valid             U:smt-z3    0.0 
ListUtils.scala:1008:5:    lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.0 
ListUtils.scala:1008:5:    lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:1009:39:   lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:1010:39:   lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         body assertion: Inlined precondition of lemmaRemoveOneElmtNotContainedSameList                                  valid             U:smt-z3    0.1 
ListUtils.scala:1010:39:   lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:1011:39:   lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         body assertion: Inlined precondition (1/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         valid             U:smt-z3    0.1 
ListUtils.scala:1011:39:   lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         body assertion: Inlined precondition (2/2) of lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         valid             U:smt-z3    0.2 
ListUtils.scala:1011:39:   lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:1014:44:   lemmaRemoveOneElmtNoDuplicateSizeMinusOne                         non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaRemoveOneElmtNotContainedSameList                            body assertion: match exhaustiveness                                                                            valid from cache              0.0 
                           lemmaRemoveOneElmtNotContainedSameList                            measure decreases                                                                                               valid from cache              0.0 
                           lemmaRemoveOneElmtNotContainedSameList                            postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaRemoveOneElmtNotContainedSameList                            postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaRemoveOneElmtNotContainedSameList                            postcondition                                                                                                   valid from cache              0.0 
                           lemmaRemoveOneElmtNotContainedSameList                            precond. (call lemmaRemoveOneElmtNotContainedSameLis...)                                                        valid from cache              0.0 
ListUtils.scala:1105:57:   lemmaRemoveOneElmtNotContainedSameList                            non-negative measure                                                                                            valid from cache              0.0 
                           lemmaRemoveOneElmtPreservesNoDuplicate                            body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
                           lemmaRemoveOneElmtPreservesNoDuplicate                            measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaRemoveOneElmtPreservesNoDuplicate                            precond. (call lemmaRemoveOneElmtPreservesNoDuplicat...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:1112:57:   lemmaRemoveOneElmtPreservesNoDuplicate                            non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:1115:15:   lemmaRemoveOneElmtPreservesNoDuplicate                            postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:1115:15:   lemmaRemoveOneElmtPreservesNoDuplicate                            postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:1115:15:   lemmaRemoveOneElmtPreservesNoDuplicate                            postcondition                                                                                                   valid from cache              0.0 
                           lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call lemmaRemovingHeadOfSuffixThenGetPrefi...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:135:15:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      non-negative measure                                                                                            valid             U:smt-z3    0.0 
ListUtils.scala:137:5:     lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:137:5:     lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:138:55:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:140:9:     lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      body assertion: Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger                            valid             U:smt-z3    0.1 
ListUtils.scala:140:9:     lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:142:21:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:145:33:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call getPrefix[B](l, suffix))                                                                         valid             U:smt-z3    0.1 
ListUtils.scala:145:33:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call getPrefix[B](l, suffix))                                                                         valid from cache              0.0 
ListUtils.scala:145:33:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call getPrefix[B](l, suffix))                                                                         valid             U:smt-z3    0.0 
ListUtils.scala:145:33:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call getPrefix[B](l, suffix))                                                                         valid             U:smt-z3    0.1 
ListUtils.scala:145:62:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call head[B](suffix))                                                                                 valid             U:smt-z3    0.1 
ListUtils.scala:145:62:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call head[B](suffix))                                                                                 valid             U:smt-z3    0.1 
ListUtils.scala:145:62:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call head[B](suffix))                                                                                 valid             U:smt-z3    0.1 
ListUtils.scala:145:62:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call head[B](suffix))                                                                                 valid from cache              0.0 
ListUtils.scala:145:78:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call getPrefix[B](l, tail[B](suffix)))                                                                valid             U:smt-z3    0.1 
ListUtils.scala:145:78:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call getPrefix[B](l, tail[B](suffix)))                                                                valid             U:smt-z3    0.1 
ListUtils.scala:145:78:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call getPrefix[B](l, tail[B](suffix)))                                                                valid from cache              0.0 
ListUtils.scala:145:78:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call getPrefix[B](l, tail[B](suffix)))                                                                valid             U:smt-z3    0.1 
ListUtils.scala:145:91:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call tail[B](suffix))                                                                                 valid             U:smt-z3    0.1 
ListUtils.scala:145:91:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call tail[B](suffix))                                                                                 valid             U:smt-z3    0.1 
ListUtils.scala:145:91:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call tail[B](suffix))                                                                                 valid from cache              0.0 
ListUtils.scala:145:91:    lemmaRemovingHeadOfSuffixThenGetPrefixLonger                      precond. (call tail[B](suffix))                                                                                 valid             U:smt-z3    0.1 
                           lemmaSameContentSameSizeSmallerEqOneSameList                      measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaSameContentSameSizeSmallerEqOneSameList                      precond. (call lemmaSameContentSameSizeSmallerEqOneS... (require 1/3))                                          valid             U:smt-z3    0.1 
                           lemmaSameContentSameSizeSmallerEqOneSameList                      precond. (call lemmaSameContentSameSizeSmallerEqOneS... (require 2/3))                                          valid from cache              0.0 
                           lemmaSameContentSameSizeSmallerEqOneSameList                      precond. (call lemmaSameContentSameSizeSmallerEqOneS... (require 3/3))                                          valid from cache              0.0 
ListUtils.scala:1182:15:   lemmaSameContentSameSizeSmallerEqOneSameList                      non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:1184:5:    lemmaSameContentSameSizeSmallerEqOneSameList                      body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:1184:5:    lemmaSameContentSameSizeSmallerEqOneSameList                      postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:1186:9:    lemmaSameContentSameSizeSmallerEqOneSameList                      postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:1186:16:   lemmaSameContentSameSizeSmallerEqOneSameList                      body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:1189:16:   lemmaSameContentSameSizeSmallerEqOneSameList                      body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:1189:16:   lemmaSameContentSameSizeSmallerEqOneSameList                      precond. (call head[B](l2))                                                                                     valid             U:smt-z3    0.1 
ListUtils.scala:1190:16:   lemmaSameContentSameSizeSmallerEqOneSameList                      body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:1191:9:    lemmaSameContentSameSizeSmallerEqOneSameList                      body assertion: Inlined precondition (1/3) of lemmaSameContentSameSizeSmallerEqOneSameList                      valid             U:smt-z3    0.1 
ListUtils.scala:1191:9:    lemmaSameContentSameSizeSmallerEqOneSameList                      body assertion: Inlined precondition (2/3) of lemmaSameContentSameSizeSmallerEqOneSameList                      valid             U:smt-z3    0.1 
ListUtils.scala:1191:9:    lemmaSameContentSameSizeSmallerEqOneSameList                      body assertion: Inlined precondition (3/3) of lemmaSameContentSameSizeSmallerEqOneSameList                      valid             U:smt-z3    0.1 
ListUtils.scala:1191:9:    lemmaSameContentSameSizeSmallerEqOneSameList                      postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:1191:58:   lemmaSameContentSameSizeSmallerEqOneSameList                      precond. (call tail[B](l2))                                                                                     valid             U:smt-z3    0.1 
                           lemmaSameIndexThenSameElement                                     measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaSameIndexThenSameElement                                     precond. (call lemmaSameIndexThenSameElement[B](l, e... (require 1/3))                                          valid             U:smt-z3    0.1 
                           lemmaSameIndexThenSameElement                                     precond. (call lemmaSameIndexThenSameElement[B](l, e... (require 2/3))                                          valid from cache              0.0 
                           lemmaSameIndexThenSameElement                                     precond. (call lemmaSameIndexThenSameElement[B](l, e... (require 3/3))                                          valid from cache              0.0 
ListUtils.scala:221:13:    lemmaSameIndexThenSameElement                                     precond. (call getIndex[B](l, e1))                                                                              valid from cache              0.0 
ListUtils.scala:221:32:    lemmaSameIndexThenSameElement                                     precond. (call getIndex[B](l, e2))                                                                              valid from cache              0.0 
ListUtils.scala:224:9:     lemmaSameIndexThenSameElement                                     precond. (call getIndex[B](l, e1))                                                                              valid             U:smt-z3    0.1 
ListUtils.scala:225:7:     lemmaSameIndexThenSameElement                                     postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:225:14:    lemmaSameIndexThenSameElement                                     body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:225:14:    lemmaSameIndexThenSameElement                                     precond. (call head[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:226:14:    lemmaSameIndexThenSameElement                                     body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:226:14:    lemmaSameIndexThenSameElement                                     precond. (call head[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:227:14:    lemmaSameIndexThenSameElement                                     body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:229:7:     lemmaSameIndexThenSameElement                                     body assertion: Inlined precondition (1/3) of lemmaSameIndexThenSameElement                                     valid             U:smt-z3    0.1 
ListUtils.scala:229:7:     lemmaSameIndexThenSameElement                                     body assertion: Inlined precondition (2/3) of lemmaSameIndexThenSameElement                                     valid             U:smt-z3    0.1 
ListUtils.scala:229:7:     lemmaSameIndexThenSameElement                                     body assertion: Inlined precondition (3/3) of lemmaSameIndexThenSameElement                                     valid             U:smt-z3    0.1 
ListUtils.scala:229:7:     lemmaSameIndexThenSameElement                                     postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:229:37:    lemmaSameIndexThenSameElement                                     non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:229:37:    lemmaSameIndexThenSameElement                                     precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
                           lemmaSamePrefixThenSameSuffix                                     measure decreases                                                                                               valid             U:smt-z3    0.2 
                           lemmaSamePrefixThenSameSuffix                                     precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 1/5))                                          valid             U:smt-z3    0.1 
                           lemmaSamePrefixThenSameSuffix                                     precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 2/5))                                          valid from cache              0.0 
                           lemmaSamePrefixThenSameSuffix                                     precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 3/5))                                          valid from cache              0.0 
                           lemmaSamePrefixThenSameSuffix                                     precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 4/5))                                          valid from cache              0.0 
                           lemmaSamePrefixThenSameSuffix                                     precond. (call lemmaSamePrefixThenSameSuffix[B](p1, ... (require 5/5))                                          valid from cache              0.0 
ListUtils.scala:477:5:     lemmaSamePrefixThenSameSuffix                                     body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:477:5:     lemmaSamePrefixThenSameSuffix                                     postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:479:9:     lemmaSamePrefixThenSameSuffix                                     body assertion: Inlined precondition (1/5) of lemmaSamePrefixThenSameSuffix                                     valid             U:smt-z3    0.1 
ListUtils.scala:479:9:     lemmaSamePrefixThenSameSuffix                                     body assertion: Inlined precondition (2/5) of lemmaSamePrefixThenSameSuffix                                     valid             U:smt-z3    0.1 
ListUtils.scala:479:9:     lemmaSamePrefixThenSameSuffix                                     body assertion: Inlined precondition (3/5) of lemmaSamePrefixThenSameSuffix                                     valid             U:smt-z3    0.1 
ListUtils.scala:479:9:     lemmaSamePrefixThenSameSuffix                                     body assertion: Inlined precondition (4/5) of lemmaSamePrefixThenSameSuffix                                     valid             U:smt-z3    0.1 
ListUtils.scala:479:9:     lemmaSamePrefixThenSameSuffix                                     body assertion: Inlined precondition (5/5) of lemmaSamePrefixThenSameSuffix                                     valid             U:smt-z3    0.5 
ListUtils.scala:479:9:     lemmaSamePrefixThenSameSuffix                                     postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:479:47:    lemmaSamePrefixThenSameSuffix                                     precond. (call tail[B](p2))                                                                                     valid             U:smt-z3    0.1 
ListUtils.scala:479:60:    lemmaSamePrefixThenSameSuffix                                     non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:479:60:    lemmaSamePrefixThenSameSuffix                                     precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:480:21:    lemmaSamePrefixThenSameSuffix                                     postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaSubSeqAddSameElmtPreserves                                   measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaSubSeqAddSameElmtPreserves                                   measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaSubSeqAddSameElmtPreserves                                   measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaSubSeqAddSameElmtPreserves                                   precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)                                                        valid             U:smt-z3    0.0 
                           lemmaSubSeqAddSameElmtPreserves                                   precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)                                                        valid             U:smt-z3    0.1 
                           lemmaSubSeqAddSameElmtPreserves                                   precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)                                                        valid             U:smt-z3    0.0 
ListUtils.scala:711:15:    lemmaSubSeqAddSameElmtPreserves                                   non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:712:5:     lemmaSubSeqAddSameElmtPreserves                                   body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:712:5:     lemmaSubSeqAddSameElmtPreserves                                   postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:713:39:    lemmaSubSeqAddSameElmtPreserves                                   postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:714:39:    lemmaSubSeqAddSameElmtPreserves                                   body assertion: Inlined precondition of lemmaSubSeqAddSameElmtPreserves                                         valid             U:smt-z3    0.1 
ListUtils.scala:714:39:    lemmaSubSeqAddSameElmtPreserves                                   postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:717:11:    lemmaSubSeqAddSameElmtPreserves                                   body assertion: Inlined precondition of lemmaSubSeqAddSameElmtPreserves                                         valid from cache              0.0 
ListUtils.scala:717:11:    lemmaSubSeqAddSameElmtPreserves                                   postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:719:18:    lemmaSubSeqAddSameElmtPreserves                                   body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:720:11:    lemmaSubSeqAddSameElmtPreserves                                   body assertion: Inlined precondition of lemmaSubSeqAddSameElmtPreserves                                         valid from cache              0.0 
ListUtils.scala:720:11:    lemmaSubSeqAddSameElmtPreserves                                   postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaSubSeqTransitive                                             measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaSubSeqTransitive                                             measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaSubSeqTransitive                                             measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaSubSeqTransitive                                             measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaSubSeqTransitive                                             measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaSubSeqTransitive                                             measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaSubSeqTransitive                                             measure decreases                                                                                               valid             U:smt-z3    0.2 
                           lemmaSubSeqTransitive                                             non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaSubSeqTransitive                                             precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))                                              valid             U:smt-z3    0.1 
                           lemmaSubSeqTransitive                                             precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))                                              valid             U:smt-z3    0.1 
                           lemmaSubSeqTransitive                                             precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))                                              valid             U:smt-z3    0.1 
                           lemmaSubSeqTransitive                                             precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))                                              valid             U:smt-z3    0.1 
                           lemmaSubSeqTransitive                                             precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))                                              valid             U:smt-z3    0.1 
                           lemmaSubSeqTransitive                                             precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))                                              valid             U:smt-z3    0.1 
                           lemmaSubSeqTransitive                                             precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))                                              valid             U:smt-z3    0.1 
                           lemmaSubSeqTransitive                                             precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))                                              valid from cache              0.0 
                           lemmaSubSeqTransitive                                             precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))                                              valid from cache              0.0 
                           lemmaSubSeqTransitive                                             precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))                                              valid from cache              0.0 
                           lemmaSubSeqTransitive                                             precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))                                              valid from cache              0.0 
                           lemmaSubSeqTransitive                                             precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))                                              valid from cache              0.0 
                           lemmaSubSeqTransitive                                             precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))                                              valid from cache              0.0 
                           lemmaSubSeqTransitive                                             precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))                                              valid from cache              0.0 
ListUtils.scala:676:9:     lemmaSubSeqTransitive                                             body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive                                             valid             U:smt-z3    0.1 
ListUtils.scala:676:9:     lemmaSubSeqTransitive                                             body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive                                             valid             U:smt-z3    0.1 
ListUtils.scala:676:9:     lemmaSubSeqTransitive                                             postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:682:15:    lemmaSubSeqTransitive                                             body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive                                             valid from cache              0.0 
ListUtils.scala:682:15:    lemmaSubSeqTransitive                                             body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive                                             valid from cache              0.0 
ListUtils.scala:682:15:    lemmaSubSeqTransitive                                             postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:684:15:    lemmaSubSeqTransitive                                             body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive                                             valid             U:smt-z3    0.1 
ListUtils.scala:684:15:    lemmaSubSeqTransitive                                             body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive                                             valid from cache              0.0 
ListUtils.scala:684:15:    lemmaSubSeqTransitive                                             postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:687:13:    lemmaSubSeqTransitive                                             body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive                                             valid             U:smt-z3    0.1 
ListUtils.scala:687:13:    lemmaSubSeqTransitive                                             body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive                                             valid from cache              0.0 
ListUtils.scala:687:13:    lemmaSubSeqTransitive                                             postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:692:15:    lemmaSubSeqTransitive                                             body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive                                             valid             U:smt-z3    0.1 
ListUtils.scala:692:15:    lemmaSubSeqTransitive                                             body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive                                             valid             U:smt-z3    0.1 
ListUtils.scala:692:15:    lemmaSubSeqTransitive                                             postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:694:15:    lemmaSubSeqTransitive                                             body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive                                             valid from cache              0.0 
ListUtils.scala:694:15:    lemmaSubSeqTransitive                                             body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive                                             valid             U:smt-z3    0.1 
ListUtils.scala:694:15:    lemmaSubSeqTransitive                                             postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:697:13:    lemmaSubSeqTransitive                                             body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive                                             valid             U:smt-z3    0.1 
ListUtils.scala:697:13:    lemmaSubSeqTransitive                                             body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive                                             valid             U:smt-z3    0.1 
ListUtils.scala:697:13:    lemmaSubSeqTransitive                                             postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:702:17:    lemmaSubSeqTransitive                                             postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaSubseqOfEmptyIsEmpty                                         body assertion: match exhaustiveness                                                                            valid from cache              0.0 
                           lemmaSubseqOfEmptyIsEmpty                                         measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaSubseqOfEmptyIsEmpty                                         postcondition                                                                                                   valid from cache              0.0 
                           lemmaSubseqOfEmptyIsEmpty                                         postcondition                                                                                                   valid from cache              0.0 
                           lemmaSubseqOfEmptyIsEmpty                                         postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaSubseqOfEmptyIsEmpty                                         precond. (call lemmaSubseqOfEmptyIsEmpty[B]((scrut.t... (require 1/2))                                          valid             U:smt-z3    0.0 
                           lemmaSubseqOfEmptyIsEmpty                                         precond. (call lemmaSubseqOfEmptyIsEmpty[B]((scrut.t... (require 2/2))                                          valid             U:smt-z3    0.1 
ListUtils.scala:628:44:    lemmaSubseqOfEmptyIsEmpty                                         non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaSubseqRefl                                                   measure decreases                                                                                               valid             U:smt-z3    0.0 
ListUtils.scala:619:15:    lemmaSubseqRefl                                                   non-negative measure                                                                                            valid from cache              0.0 
ListUtils.scala:620:5:     lemmaSubseqRefl                                                   body assertion: match exhaustiveness                                                                            trivial                       0.0 
ListUtils.scala:620:5:     lemmaSubseqRefl                                                   postcondition                                                                                                   trivial                       0.0 
ListUtils.scala:621:28:    lemmaSubseqRefl                                                   postcondition                                                                                                   valid             U:smt-z3    0.0 
ListUtils.scala:622:28:    lemmaSubseqRefl                                                   postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaSubsetContentThenForallContains                              body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.0 
                           lemmaSubsetContentThenForallContains                              measure decreases                                                                                               valid             U:smt-z3    0.1 
                           lemmaSubsetContentThenForallContains                              postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaSubsetContentThenForallContains                              postcondition                                                                                                   valid from cache              0.0 
                           lemmaSubsetContentThenForallContains                              postcondition                                                                                                   valid             U:smt-z3    0.1 
                           lemmaSubsetContentThenForallContains                              precond. (call lemmaSubsetContentThenForallContains[...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:1119:55:   lemmaSubsetContentThenForallContains                              non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           lemmaTailIsSubseqOfBiggerList                                     precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))                                              valid             U:smt-z3    0.1 
                           lemmaTailIsSubseqOfBiggerList                                     precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))                                              valid from cache              0.0 
ListUtils.scala:662:7:     lemmaTailIsSubseqOfBiggerList                                     body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive                                             valid from cache              0.0 
ListUtils.scala:662:7:     lemmaTailIsSubseqOfBiggerList                                     body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive                                             valid from cache              0.0 
ListUtils.scala:662:7:     lemmaTailIsSubseqOfBiggerList                                     postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:662:29:    lemmaTailIsSubseqOfBiggerList                                     precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:664:6:     lemmaTailIsSubseqOfBiggerList                                     postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:665:45:    lemmaTailIsSubseqOfBiggerList                                     precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:665:45:    lemmaTailIsSubseqOfBiggerList                                     precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:636:5:     lemmaTailIsSubseqOfList                                           body assertion: match exhaustiveness                                                                            trivial                       0.0 
ListUtils.scala:636:5:     lemmaTailIsSubseqOfList                                           postcondition                                                                                                   trivial                       0.0 
ListUtils.scala:637:21:    lemmaTailIsSubseqOfList                                           postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:640:9:     lemmaTailIsSubseqOfList                                           precond. (call subseqTail[B](l, l))                                                                             valid             U:smt-z3    0.1 
ListUtils.scala:641:9:     lemmaTailIsSubseqOfList                                           postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:641:16:    lemmaTailIsSubseqOfList                                           body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:643:42:    lemmaTailIsSubseqOfList                                           postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:650:5:     lemmaTailIsSubseqOfListBis                                        body assertion: match exhaustiveness                                                                            trivial                       0.0 
ListUtils.scala:650:5:     lemmaTailIsSubseqOfListBis                                        postcondition                                                                                                   trivial                       0.0 
ListUtils.scala:651:28:    lemmaTailIsSubseqOfListBis                                        postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:652:28:    lemmaTailIsSubseqOfListBis                                        postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:654:45:    lemmaTailIsSubseqOfListBis                                        precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:654:45:    lemmaTailIsSubseqOfListBis                                        precond. (call tail[B](l))                                                                                      trivial                       0.0 
ListUtils.scala:654:45:    lemmaTailIsSubseqOfListBis                                        precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.0 
                           lemmaTwoListsConcatAssociativity                                  measure decreases                                                                                               valid from cache              0.0 
ListUtils.scala:333:15:    lemmaTwoListsConcatAssociativity                                  non-negative measure                                                                                            valid from cache              0.0 
ListUtils.scala:334:5:     lemmaTwoListsConcatAssociativity                                  body assertion: match exhaustiveness                                                                            trivial                       0.0 
ListUtils.scala:334:5:     lemmaTwoListsConcatAssociativity                                  postcondition                                                                                                   trivial                       0.0 
ListUtils.scala:336:9:     lemmaTwoListsConcatAssociativity                                  postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:338:21:    lemmaTwoListsConcatAssociativity                                  postcondition                                                                                                   valid             U:smt-z3    0.1 
                           noDuplicateConcatListNotContainedPreserves                        measure decreases                                                                                               valid             U:smt-z3    0.1 
                           noDuplicateConcatListNotContainedPreserves                        precond. (call noDuplicateConcatListNotContainedPres... (require 1/3))                                          valid             U:smt-z3    0.1 
                           noDuplicateConcatListNotContainedPreserves                        precond. (call noDuplicateConcatListNotContainedPres... (require 2/3))                                          valid from cache              0.0 
                           noDuplicateConcatListNotContainedPreserves                        precond. (call noDuplicateConcatListNotContainedPres... (require 3/3))                                          valid             U:smt-z3    0.1 
ListUtils.scala:1032:5:    noDuplicateConcatListNotContainedPreserves                        body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:1032:5:    noDuplicateConcatListNotContainedPreserves                        postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:1033:28:   noDuplicateConcatListNotContainedPreserves                        body assertion: Inlined precondition (1/3) of noDuplicateConcatListNotContainedPreserves                        valid             U:smt-z3    0.0 
ListUtils.scala:1033:28:   noDuplicateConcatListNotContainedPreserves                        body assertion: Inlined precondition (2/3) of noDuplicateConcatListNotContainedPreserves                        valid             U:smt-z3    0.1 
ListUtils.scala:1033:28:   noDuplicateConcatListNotContainedPreserves                        body assertion: Inlined precondition (3/3) of noDuplicateConcatListNotContainedPreserves                        valid             U:smt-z3    0.1 
ListUtils.scala:1033:28:   noDuplicateConcatListNotContainedPreserves                        postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:1034:28:   noDuplicateConcatListNotContainedPreserves                        postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:1037:35:   noDuplicateConcatListNotContainedPreserves                        non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           noDuplicateConcatListNotContainedPreservesBis                     measure decreases                                                                                               valid             U:smt-z3    0.2 
                           noDuplicateConcatListNotContainedPreservesBis                     precond. (call lemmaForallNotContainsForConcat[B](l,... (require 1/2))                                          valid             U:smt-z3    0.1 
                           noDuplicateConcatListNotContainedPreservesBis                     precond. (call lemmaForallNotContainsForConcat[B](l,... (require 2/2))                                          valid             U:smt-z3    0.1 
                           noDuplicateConcatListNotContainedPreservesBis                     precond. (call lemmaForallNotContainsForSubseq[B](l,...)                                                        valid             U:smt-z3    0.1 
                           noDuplicateConcatListNotContainedPreservesBis                     precond. (call noDuplicateConcatListNotContainedPres... (require 1/4))                                          valid             U:smt-z3    0.1 
                           noDuplicateConcatListNotContainedPreservesBis                     precond. (call noDuplicateConcatListNotContainedPres... (require 2/4))                                          valid from cache              0.0 
                           noDuplicateConcatListNotContainedPreservesBis                     precond. (call noDuplicateConcatListNotContainedPres... (require 3/4))                                          valid             U:smt-z3    0.1 
                           noDuplicateConcatListNotContainedPreservesBis                     precond. (call noDuplicateConcatListNotContainedPres... (require 4/4))                                          valid             U:smt-z3    0.1 
ListUtils.scala:1048:5:    noDuplicateConcatListNotContainedPreservesBis                     body assertion: match exhaustiveness                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:1048:5:    noDuplicateConcatListNotContainedPreservesBis                     postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:1050:16:   noDuplicateConcatListNotContainedPreservesBis                     body assertion                                                                                                  valid             U:smt-z3    0.1 
ListUtils.scala:1051:9:    noDuplicateConcatListNotContainedPreservesBis                     body assertion: Inlined precondition (1/2) of lemmaForallNotContainsForConcat                                   valid             U:smt-z3    0.1 
ListUtils.scala:1051:9:    noDuplicateConcatListNotContainedPreservesBis                     body assertion: Inlined precondition (2/2) of lemmaForallNotContainsForConcat                                   valid             U:smt-z3    0.1 
ListUtils.scala:1052:9:    noDuplicateConcatListNotContainedPreservesBis                     body assertion: Inlined precondition of lemmaForallNotContainsForSubseq                                         valid             U:smt-z3    0.1 
ListUtils.scala:1053:9:    noDuplicateConcatListNotContainedPreservesBis                     body assertion: Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis                     valid             U:smt-z3    0.1 
ListUtils.scala:1053:9:    noDuplicateConcatListNotContainedPreservesBis                     body assertion: Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis                     valid             U:smt-z3    0.1 
ListUtils.scala:1053:9:    noDuplicateConcatListNotContainedPreservesBis                     body assertion: Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis                     valid             U:smt-z3    0.1 
ListUtils.scala:1053:9:    noDuplicateConcatListNotContainedPreservesBis                     body assertion: Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis                     valid             U:smt-z3    0.2 
ListUtils.scala:1053:9:    noDuplicateConcatListNotContainedPreservesBis                     postcondition                                                                                                   valid             U:smt-z3    0.2 
ListUtils.scala:1055:21:   noDuplicateConcatListNotContainedPreservesBis                     postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:1057:35:   noDuplicateConcatListNotContainedPreservesBis                     non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:1018:7:    noDuplicateConcatNotContainedPreserves                            postcondition                                                                                                   valid             U:smt-z3    0.1 
                           notContainsAThenTailNotContains                                   body assertion: match exhaustiveness                                                                            valid from cache              0.0 
                           notContainsAThenTailNotContains                                   measure decreases                                                                                               valid             U:smt-z3    0.2 
                           notContainsAThenTailNotContains                                   postcondition                                                                                                   valid             U:smt-z3    0.1 
                           notContainsAThenTailNotContains                                   postcondition                                                                                                   valid             U:smt-z3    0.1 
                           notContainsAThenTailNotContains                                   postcondition                                                                                                   valid from cache              0.0 
                           notContainsAThenTailNotContains                                   precond. (call notContainsAThenTailNotContains[B]((s...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:1139:15:   notContainsAThenTailNotContains                                   non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:1144:29:   notContainsAThenTailNotContains                                   precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:1144:29:   notContainsAThenTailNotContains                                   precond. (call tail[B](l))                                                                                      valid from cache              0.0 
ListUtils.scala:1144:29:   notContainsAThenTailNotContains                                   precond. (call tail[B](l))                                                                                      valid             U:smt-z3    0.1 
                           notContainsAddNotEqThenNotContains                                body assertion: match exhaustiveness                                                                            valid from cache              0.0 
                           notContainsAddNotEqThenNotContains                                measure decreases                                                                                               valid             U:smt-z3    0.1 
                           notContainsAddNotEqThenNotContains                                postcondition                                                                                                   valid from cache              0.0 
                           notContainsAddNotEqThenNotContains                                postcondition                                                                                                   valid             U:smt-z3    0.1 
                           notContainsAddNotEqThenNotContains                                postcondition                                                                                                   valid             U:smt-z3    0.1 
                           notContainsAddNotEqThenNotContains                                precond. (call notContainsAddNotEqThenNotContains[B]... (require 1/2))                                          valid             U:smt-z3    0.1 
                           notContainsAddNotEqThenNotContains                                precond. (call notContainsAddNotEqThenNotContains[B]... (require 2/2))                                          valid             U:smt-z3    0.1 
ListUtils.scala:1127:15:   notContainsAddNotEqThenNotContains                                non-negative measure                                                                                            valid             U:smt-z3    0.1 
                           removeDuplicates                                                  precond. (call lemmaForallNotContainsPreservedAddNew... (require 1/2))                                          valid             U:smt-z3    0.2 
                           removeDuplicates                                                  precond. (call lemmaForallNotContainsPreservedAddNew... (require 2/2))                                          valid             U:smt-z3    0.1 
                           removeDuplicates                                                  precond. (call lemmaIsSuffixThenTailIsSuffix[B](l, s...)                                                        valid             U:smt-z3    0.2 
                           removeDuplicates                                                  precond. (call lemmaIsSuffixThenTailIsSuffix[B](l, s...)                                                        valid             U:smt-z3    0.1 
                           removeDuplicates                                                  precond. (call lemmaRemovingHeadOfSuffixThenGetPrefi...)                                                        valid             U:smt-z3    0.1 
                           removeDuplicates                                                  precond. (call lemmaRemovingHeadOfSuffixThenGetPrefi...)                                                        valid             U:smt-z3    0.1 
                           removeDuplicates                                                  precond. (call lemmaSubSeqAddSameElmtPreserves[B](lS...)                                                        valid from cache              0.0 
                           removeDuplicates                                                  precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))                                              valid from cache              0.0 
                           removeDuplicates                                                  precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 1/2))                                              valid from cache              0.0 
                           removeDuplicates                                                  precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))                                              valid from cache              0.0 
                           removeDuplicates                                                  precond. (call lemmaSubSeqTransitive[B](l1, l2, l3) (require 2/2))                                              valid from cache              0.0 
                           removeDuplicates                                                  precond. (call noDuplicateConcatListNotContainedPres... (require 1/4))                                          valid             U:smt-z3    0.1 
                           removeDuplicates                                                  precond. (call noDuplicateConcatListNotContainedPres... (require 2/4))                                          valid from cache              0.0 
                           removeDuplicates                                                  precond. (call noDuplicateConcatListNotContainedPres... (require 3/4))                                          valid             U:smt-z3    0.1 
                           removeDuplicates                                                  precond. (call noDuplicateConcatListNotContainedPres... (require 4/4))                                          valid             U:smt-z3    0.2 
ListUtils.scala:585:35:    removeDuplicates                                                  precond. (call getPrefix[B](totList, list))                                                                     valid             U:smt-z3    0.1 
ListUtils.scala:589:5:     removeDuplicates                                                  body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:589:5:     removeDuplicates                                                  postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:591:9:     removeDuplicates                                                  body assertion: Inlined precondition of lemmaIsSuffixThenTailIsSuffix                                           valid from cache              0.0 
ListUtils.scala:592:9:     removeDuplicates                                                  body assertion: Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger                            valid from cache              0.0 
ListUtils.scala:593:41:    removeDuplicates                                                  precond. (call getPrefix[B](totList, list))                                                                     valid             U:smt-z3    0.1 
ListUtils.scala:594:9:     removeDuplicates                                                  body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive                                             valid from cache              0.0 
ListUtils.scala:594:9:     removeDuplicates                                                  body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive                                             valid from cache              0.0 
ListUtils.scala:594:36:    removeDuplicates                                                  precond. (call getPrefix[B](totList, list))                                                                     valid             U:smt-z3    0.1 
ListUtils.scala:594:62:    removeDuplicates                                                  precond. (call getPrefix[B](totList, list))                                                                     valid from cache              0.0 
ListUtils.scala:596:9:     removeDuplicates                                                  measure decreases                                                                                               valid             U:smt-z3    0.1 
ListUtils.scala:596:9:     removeDuplicates                                                  postcondition                                                                                                   valid             U:smt-z3    0.3 
ListUtils.scala:596:9:     removeDuplicates                                                  precond. (call removeDuplicates[B](totList, (scrut.t... (require 1/4))                                          valid             U:smt-z3    0.1 
ListUtils.scala:596:9:     removeDuplicates                                                  precond. (call removeDuplicates[B](totList, (scrut.t... (require 2/4))                                          valid             U:smt-z3    0.2 
ListUtils.scala:596:9:     removeDuplicates                                                  precond. (call removeDuplicates[B](totList, (scrut.t... (require 3/4))                                          valid             U:smt-z3    0.3 
ListUtils.scala:596:9:     removeDuplicates                                                  precond. (call removeDuplicates[B](totList, (scrut.t... (require 4/4))                                          valid             U:smt-z3    0.3 
ListUtils.scala:599:9:     removeDuplicates                                                  body assertion: Inlined precondition of lemmaIsSuffixThenTailIsSuffix                                           valid from cache              0.0 
ListUtils.scala:600:9:     removeDuplicates                                                  body assertion: Inlined precondition of lemmaRemovingHeadOfSuffixThenGetPrefixLonger                            valid from cache              0.0 
ListUtils.scala:601:41:    removeDuplicates                                                  precond. (call getPrefix[B](totList, list))                                                                     valid             U:smt-z3    0.1 
ListUtils.scala:602:9:     removeDuplicates                                                  body assertion: Inlined precondition (1/2) of lemmaSubSeqTransitive                                             valid from cache              0.0 
ListUtils.scala:602:9:     removeDuplicates                                                  body assertion: Inlined precondition (2/2) of lemmaSubSeqTransitive                                             valid from cache              0.0 
ListUtils.scala:602:36:    removeDuplicates                                                  precond. (call getPrefix[B](totList, list))                                                                     valid             U:smt-z3    0.1 
ListUtils.scala:602:62:    removeDuplicates                                                  precond. (call getPrefix[B](totList, list))                                                                     valid from cache              0.0 
ListUtils.scala:604:9:     removeDuplicates                                                  body assertion: Inlined precondition of lemmaSubSeqAddSameElmtPreserves                                         valid from cache              0.0 
ListUtils.scala:604:46:    removeDuplicates                                                  precond. (call getPrefix[B](totList, list))                                                                     valid             U:smt-cvc4  0.2 
ListUtils.scala:607:9:     removeDuplicates                                                  body assertion: Inlined precondition (1/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList                valid             U:smt-z3    0.1 
ListUtils.scala:607:9:     removeDuplicates                                                  body assertion: Inlined precondition (2/2) of lemmaForallNotContainsPreservedAddNewElmtInRefList                valid             U:smt-z3    0.1 
ListUtils.scala:608:9:     removeDuplicates                                                  body assertion: Inlined precondition (1/4) of noDuplicateConcatListNotContainedPreservesBis                     valid             U:smt-z3    0.1 
ListUtils.scala:608:9:     removeDuplicates                                                  body assertion: Inlined precondition (2/4) of noDuplicateConcatListNotContainedPreservesBis                     valid             U:smt-z3    0.3 
ListUtils.scala:608:9:     removeDuplicates                                                  body assertion: Inlined precondition (3/4) of noDuplicateConcatListNotContainedPreservesBis                     valid             U:smt-z3    0.4 
ListUtils.scala:608:9:     removeDuplicates                                                  body assertion: Inlined precondition (4/4) of noDuplicateConcatListNotContainedPreservesBis                     valid             U:smt-z3    0.1 
ListUtils.scala:610:9:     removeDuplicates                                                  measure decreases                                                                                               valid             U:smt-z3    0.2 
ListUtils.scala:610:9:     removeDuplicates                                                  postcondition                                                                                                   valid             U:smt-z3    0.4 
ListUtils.scala:610:9:     removeDuplicates                                                  precond. (call removeDuplicates[B](totList, (scrut.t... (require 1/4))                                          valid             U:smt-z3    0.1 
ListUtils.scala:610:9:     removeDuplicates                                                  precond. (call removeDuplicates[B](totList, (scrut.t... (require 2/4))                                          valid             U:smt-z3    0.2 
ListUtils.scala:610:9:     removeDuplicates                                                  precond. (call removeDuplicates[B](totList, (scrut.t... (require 3/4))                                          valid             U:smt-z3    0.3 
ListUtils.scala:610:9:     removeDuplicates                                                  precond. (call removeDuplicates[B](totList, (scrut.t... (require 4/4))                                          valid             U:smt-z3    0.4 
ListUtils.scala:614:100:   removeDuplicates                                                  non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:614:108:   removeDuplicates                                                  postcondition                                                                                                   valid             U:smt-z3    0.2 
ListUtils.scala:582:24:    removeDuplicates$default$3                                        postcondition                                                                                                   trivial                       0.1 
ListUtils.scala:21:24:     removeLast                                                        body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:21:24:     removeLast                                                        postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:22:31:     removeLast                                                        postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:23:31:     removeLast                                                        postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:23:40:     removeLast                                                        measure decreases                                                                                               valid             U:smt-z3    0.1 
ListUtils.scala:23:40:     removeLast                                                        precond. (call removeLast[B]((scrut.t): @DropVCs ))                                                             valid from cache              0.0 
ListUtils.scala:26:34:     removeLast                                                        precond. (call last[B](l))                                                                                      trivial                       0.0 
ListUtils.scala:26:34:     removeLast                                                        precond. (call last[B](l))                                                                                      trivial                       0.0 
ListUtils.scala:26:34:     removeLast                                                        precond. (call last[B](l))                                                                                      valid             U:smt-z3    0.1 
ListUtils.scala:26:45:     removeLast                                                        non-negative measure                                                                                            valid from cache              0.0 
ListUtils.scala:30:5:      reverseList                                                       body assertion: match exhaustiveness                                                                            trivial                       0.0 
ListUtils.scala:30:5:      reverseList                                                       non-negative measure                                                                                            valid from cache              0.0 
ListUtils.scala:31:28:     reverseList                                                       measure decreases                                                                                               valid from cache              0.0 
                           subseqForall                                                      measure decreases                                                                                               valid             U:smt-z3    0.2 
                           subseqForall                                                      precond. (call lemmaTailIsSubseqOfBiggerList[B](l, l...)                                                        valid             U:smt-z3    0.2 
                           subseqForall                                                      precond. (call subseqForall[B](l, lSub, p) (require 1/2))                                                       valid             U:smt-z3    0.1 
                           subseqForall                                                      precond. (call subseqForall[B](l, lSub, p) (require 2/2))                                                       valid from cache              0.0 
ListUtils.scala:152:15:    subseqForall                                                      non-negative measure                                                                                            valid             U:smt-z3    0.1 
ListUtils.scala:153:5:     subseqForall                                                      body assertion: match exhaustiveness                                                                            valid from cache              0.0 
ListUtils.scala:153:5:     subseqForall                                                      postcondition                                                                                                   valid from cache              0.0 
ListUtils.scala:155:9:     subseqForall                                                      body assertion: Inlined precondition of lemmaTailIsSubseqOfBiggerList                                           valid from cache              0.0 
ListUtils.scala:156:9:     subseqForall                                                      precond. (call subseqContains[B](lSub, l, (scrut.h):...)                                                        valid             U:smt-z3    0.2 
ListUtils.scala:157:9:     subseqForall                                                      precond. (call forallContained[B](l, p, (scrut.h): @...)                                                        valid             U:smt-z3    0.1 
ListUtils.scala:158:9:     subseqForall                                                      body assertion: Inlined precondition (1/2) of subseqForall                                                      valid             U:smt-z3    0.1 
ListUtils.scala:158:9:     subseqForall                                                      body assertion: Inlined precondition (2/2) of subseqForall                                                      valid from cache              0.0 
ListUtils.scala:158:9:     subseqForall                                                      postcondition                                                                                                   valid             U:smt-z3    0.1 
ListUtils.scala:160:21:    subseqForall                                                      postcondition                                                                                                   valid             U:smt-z3    0.1 
................................................................................................................................................................................................................................................
total: 982  valid: 982  (227 from cache, 35 trivial) invalid: 0    unknown: 0    time:   70.67                                                                                                                                                 

Verification pipeline summary:
  cache, anti-aliasing, imperative elimination, 
  no-inc:smt-z3:z3, smt-cvc4, smt-z3, batched
Shutting down executor service.
